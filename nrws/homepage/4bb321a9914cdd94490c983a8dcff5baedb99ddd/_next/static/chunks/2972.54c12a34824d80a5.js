(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [2972], {
        15667: (e, t, n) => {
            "use strict";

            function r(e) {
                return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.mediumDevice = t.default = void 0;
            var i = function(e, t) {
                    if (e && e.__esModule) return e;
                    if (null === e || "object" !== r(e) && "function" != typeof e) return {
                        default: e
                    };
                    var n = f(void 0);
                    if (n && n.has(e)) return n.get(e);
                    var i = {},
                        a = Object.defineProperty && Object.getOwnPropertyDescriptor;
                    for (var o in e)
                        if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                            var s = a ? Object.getOwnPropertyDescriptor(e, o) : null;
                            s && (s.get || s.set) ? Object.defineProperty(i, o, s) : i[o] = e[o]
                        }
                    return i.default = e, n && n.set(e, i), i
                }(n(96540)),
                a = d(n(5556)),
                o = d(n(20053)),
                s = n(10929),
                l = n(5321),
                u = d(n(61106)),
                c = d(n(27870)),
                h = d(n(32724));

            function d(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }

            function f(e) {
                if ("function" != typeof WeakMap) return null;
                var t = new WeakMap,
                    n = new WeakMap;
                return (f = function(e) {
                    return e ? n : t
                })(e)
            }

            function p() {
                return (p = Object.assign ? Object.assign.bind() : function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = arguments[t];
                        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                    }
                    return e
                }).apply(this, arguments)
            }

            function m(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }

            function v(e, t) {
                return (v = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }

            function g(e) {
                if (void 0 === e) throw ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }

            function y(e) {
                return (y = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }
            n(11364);
            var _ = "ar-button",
                x = "(min-width: 768px)";
            t.mediumDevice = x;
            var b = function(e) {
                ! function(e, t) {
                    if ("function" != typeof t && null !== t) throw TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }), Object.defineProperty(e, "prototype", {
                        writable: !1
                    }), t && v(e, t)
                }(d, e);
                var t, n, a = (t = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
                    } catch (e) {
                        return !1
                    }
                }(), function() {
                    var e, n = y(d);
                    return e = t ? Reflect.construct(n, arguments, y(this).constructor) : n.apply(this, arguments),
                        function(e, t) {
                            if (t && ("object" === r(t) || "function" == typeof t)) return t;
                            if (void 0 !== t) throw TypeError("Derived constructors may only return object or undefined");
                            return g(e)
                        }(this, e)
                });

                function d(e) {
                    var t;
                    return ! function(e, t) {
                        if (!(e instanceof t)) throw TypeError("Cannot call a class as a function")
                    }(this, d), (t = a.call(this, e)).initializeARButton = function() {
                        var e, n = t.props,
                            r = n.arConfig,
                            i = n.getARButtonAvailability,
                            a = n.isEnabled,
                            o = n.forceIos3D,
                            u = n.forceAndroid3D,
                            c = n.modalTitle,
                            h = n.clickInterceptor;
                        if (!(a && (r || h))) return null;
                        var d = !window.matchMedia(x).matches,
                            f = !!t.getIosVersion(),
                            p = (0, s.getIsAndroid)(),
                            m = p && t.getIsSupportedAndroid(),
                            v = t.getIsBrowserSupportArLinks(),
                            g = (0, s.getIsInAppBrowser)(),
                            y = !1;
                        f ? (e = l.PLATFORMS.IOS, y = !0) : p && (e = l.PLATFORMS.ANDROID, y = !0);
                        var _ = f && o || p && u || p && !m || g || d && f && !v,
                            b = r[f && !_ ? (0, s.getIosARFileFormat)() : (0, s.getAndroidARFileFormat)()];
                        if (!(b || h)) return null;
                        var w = (0, s.getARType)({
                                shouldShowARButton: y,
                                force3D: _,
                                modalTitle: c
                            }),
                            M = (0, s.getARDescription)(w);
                        t.setState({
                            isInitialized: !0,
                            arFileUrl: b,
                            platform: e,
                            arType: w
                        }), i(!0, {
                            arType: w,
                            description: M
                        })
                    }, t.onARButtonClick = function(e) {
                        (0, t.props.onClick)(e)
                    }, t.getNativeARButtonMarkup = function(e) {
                        var n, r = t.props,
                            a = r.className,
                            s = r.children,
                            l = r.arIconClassName,
                            c = r.arIconType,
                            h = r.arIconTheme,
                            d = r.dataTest,
                            f = (0, o.default)((m(n = {}, _, !0), m(n, a, !!a), n)),
                            v = t.onClickInterceptorProxy(t.onARButtonClick);
                        return i.default.createElement("a", p({
                            className: f,
                            onClick: v,
                            "data-test": d
                        }, e), i.default.createElement(u.default, {
                            iconTheme: h,
                            iconType: c,
                            className: l
                        }, s))
                    }, t.onQRModalButtonClick = function(e) {
                        t.setState({
                            modalQROpen: !0
                        }), t.onARButtonClick(e)
                    }, t.onQRModalClose = function(e) {
                        var n = t.props.onQRModalCloseCb;
                        t.setState({
                            modalQROpen: !1
                        }), n(e)
                    }, t.getModelViewerMarkup = function() {
                        var e = t.state,
                            n = e.model3DViewerOpen,
                            r = e.arFileUrl,
                            a = t.getARButtonMarkup({
                                onClickHandler: t.onModelViewerButtonClick
                            });
                        return i.default.createElement(i.default.Fragment, null, a, i.default.createElement(h.default, p({
                            open: n,
                            onClose: t.onModelViewerClose
                        }, {
                            href: r
                        })))
                    }, t.onModelViewerButtonClick = function(e) {
                        t.setState({
                            model3DViewerOpen: !0
                        }), t.onARButtonClick(e)
                    }, t.onModelViewerClose = function(e) {
                        var n = t.props.onModelViewerCloseCb;
                        t.setState({
                            model3DViewerOpen: !1
                        }), n(e)
                    }, t.onClickInterceptorProxy = function(e) {
                        var n = t.props.clickInterceptor;
                        return function(r) {
                            n && n(r) || e.call(g(t), r)
                        }
                    }, t.getARButtonMarkup = function(e) {
                        var n, r = e.onClickHandler,
                            a = t.props,
                            s = a.className,
                            l = a.children,
                            c = a.arIconClassName,
                            h = a.arIconType,
                            d = a.arIconTheme,
                            f = a.dataTest,
                            p = (0, o.default)((m(n = {}, _, !0), m(n, "".concat(_, "--dialog"), !0), m(n, s, !!s), n)),
                            v = t.onClickInterceptorProxy(void 0 === r ? null : r);
                        return i.default.createElement("button", {
                            type: "button",
                            className: p,
                            onClick: v,
                            "data-test": f
                        }, i.default.createElement(u.default, {
                            iconTheme: d,
                            iconType: h,
                            className: c
                        }, l))
                    }, t.getQRModal = function() {
                        var e = t.props,
                            n = e.modalTitle,
                            r = e.modalBody,
                            a = e.qrUrl,
                            o = e.qrSize,
                            s = t.state.modalQROpen,
                            l = "function" == typeof a ? a() : a;
                        return i.default.createElement(c.default, {
                            open: s,
                            url: l,
                            size: o,
                            title: n,
                            body: r,
                            onClose: t.onQRModalClose
                        })
                    }, t.getQRModalMarkup = function() {
                        var e = t.getARButtonMarkup({
                                onClickHandler: t.onQRModalButtonClick
                            }),
                            n = t.getQRModal();
                        return i.default.createElement(i.default.Fragment, null, n, e)
                    }, t.getAndroidARButton = function() {
                        var e = new URL(t.state.arFileUrl),
                            n = e.protocol.replace(":", ""),
                            r = l.ANDROID_AR_URL_TEMPLATE.replace("{sceneViewerVersion}", "1.0").replace("{constructedARFileUrl}", e).replace("{mode}", "ar_preferred").replace("{scheme}", n).replace("{constructedFallbackUrl}", "https://developers.google.com/ar");
                        return t.getNativeARButtonMarkup({
                            href: r
                        })
                    }, t.getIosARButton = function() {
                        var e = t.state.arFileUrl;
                        return t.getNativeARButtonMarkup({
                            href: e,
                            rel: "ar"
                        })
                    }, t.getNativeARButton = function() {
                        var e = t.state.platform,
                            n = null;
                        switch (e) {
                            case l.PLATFORMS.IOS:
                                n = t.getIosARButton();
                                break;
                            case l.PLATFORMS.ANDROID:
                                n = t.getAndroidARButton()
                        }
                        return n
                    }, t.state = {
                        isInitialized: !1,
                        arFileUrl: "",
                        platform: void 0,
                        modalQROpen: !1,
                        model3DViewerOpen: !1
                    }, t
                }
                return n = [{
                        key: "componentDidMount",
                        value: function() {
                            this.initializeARButton()
                        }
                    }, {
                        key: "componentDidUpdate",
                        value: function(e) {
                            var t = this.props.arConfig;
                            e.arConfig !== t && this.initializeARButton()
                        }
                    }, {
                        key: "getIosVersion",
                        value: function() {
                            return (0, s.getIosVersion)()
                        }
                    }, {
                        key: "getIsSupportedAndroid",
                        value: function() {
                            return (0, s.getIsSupportedAndroid)()
                        }
                    }, {
                        key: "getIsBrowserSupportArLinks",
                        value: function() {
                            var e = document.createElement("a");
                            try {
                                return e.relList.supports("ar")
                            } catch (e) {
                                return !1
                            }
                        }
                    }, {
                        key: "render",
                        value: function() {
                            var e = this.state,
                                t = e.isInitialized,
                                n = e.arType;
                            if (!t) return null;
                            var r = null;
                            switch (n) {
                                case l.AR_BUTTON_TYPE.MODEL_VIEWER:
                                    r = this.getModelViewerMarkup();
                                    break;
                                case l.AR_BUTTON_TYPE.NATIVE_AR_EXPERIENCE:
                                    r = this.getNativeARButton();
                                    break;
                                case l.AR_BUTTON_TYPE.QR_MODAL:
                                    r = this.getQRModalMarkup()
                            }
                            return r
                        }
                    }],
                    function(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }(d.prototype, n), Object.defineProperty(d, "prototype", {
                        writable: !1
                    }), d
            }(i.PureComponent);
            b.propTypes = {
                onClick: a.default.func,
                onQRModalCloseCb: a.default.func,
                onModelViewerCloseCb: a.default.func,
                getARButtonAvailability: a.default.func,
                className: a.default.string,
                arIconClassName: a.default.string,
                arIconType: a.default.oneOf(["default", "animated"]),
                arIconTheme: a.default.oneOf(["light", "dark"]),
                children: a.default.oneOfType([a.default.node, a.default.arrayOf(a.default.node)]),
                arConfig: a.default.shape({
                    usdz: a.default.string,
                    reality: a.default.string,
                    glb: a.default.string
                }),
                isEnabled: a.default.bool,
                modalTitle: a.default.string,
                modalBody: a.default.string,
                qrUrl: a.default.oneOfType([a.default.string, a.default.func]),
                qrSize: a.default.number,
                dataTest: a.default.string,
                forceIos3D: a.default.bool,
                forceAndroid3D: a.default.bool,
                clickInterceptor: a.default.func
            }, b.defaultProps = {
                onClick: function() {
                    return null
                },
                onQRModalCloseCb: function() {
                    return null
                },
                onModelViewerCloseCb: function() {
                    return null
                },
                getARButtonAvailability: function() {},
                arIconType: "animated",
                className: "",
                arIconClassName: "",
                arIconTheme: "dark",
                arConfig: {},
                isEnabled: !1,
                modalTitle: "",
                modalBody: "",
                qrSize: 108,
                dataTest: "",
                forceIos3D: !1,
                forceAndroid3D: !1,
                clickInterceptor: null
            }, t.default = b
        },
        5321: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.PLATFORMS = t.AR_FILE_EXTENSIONS = t.AR_CORE_MIN_SUPPORTED_ANRDOID = t.AR_BUTTON_TYPE = t.AR_BUTTON_DESCRIPTION = t.ANDROID_AR_URL_TEMPLATE = void 0, t.PLATFORMS = {
                ANDROID: "ANDROID",
                IOS: "IOS"
            }, t.AR_BUTTON_TYPE = {
                MODEL_VIEWER: "MODEL_VIEWER",
                QR_MODAL: "QR_MODAL",
                NATIVE_AR_EXPERIENCE: "NATIVE_AR_EXPERIENCE",
                CUSTOM_AR_EXPERIENCE: "CUSTOM_AR_EXPERIENCE"
            }, t.AR_BUTTON_DESCRIPTION = {
                MODEL_VIEWER: "3D model viewer",
                QR_MODAL: "QR code modal",
                NATIVE_AR_EXPERIENCE: "ar experience"
            }, t.ANDROID_AR_URL_TEMPLATE = "intent://arvr.google.com/scene-viewer/{sceneViewerVersion}?file={constructedARFileUrl}&mode={mode}#Intent;scheme={scheme};package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url={constructedFallbackUrl};end;", t.AR_CORE_MIN_SUPPORTED_ANRDOID = 7, t.AR_FILE_EXTENSIONS = {
                USDZ: "usdz",
                GLB: "glb"
            }
        },
        10929: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.getIsSupportedAndroid = t.getIsInAppBrowser = t.getIsAndroid = t.getIosVersion = t.getIosARFileFormat = t.getAndroidARFileFormat = t.getARType = t.getARDescription = void 0;
            var r = n(5321),
                i = function() {
                    return window && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : ""
                };
            t.getIosVersion = function() {
                var e = i(),
                    t = e.indexOf("OS ");
                return (e.indexOf("iPhone") > -1 || e.indexOf("iPad") > -1) && t > -1 ? window.Number(e.substr(t + 3, 3).replace("_", ".")) : null
            };
            var a = function() {
                var e = !1,
                    t = i();
                return (t.indexOf("FB") > -1 || t.indexOf("Instagram") > -1 || t.indexOf("MicroMessenger") > -1) && (e = !0), e
            };
            t.getIsInAppBrowser = a, t.getIsAndroid = function() {
                var e = i().toLowerCase();
                return /android/i.test(e)
            }, t.getIsSupportedAndroid = function() {
                var e = i().toLowerCase();
                if (/android/i.test(e) && !a()) {
                    var t = e.match(/android\s([0-9.]*)/),
                        n = t ? t[1] : void 0;
                    return !!n && parseFloat(n, 10) >= r.AR_CORE_MIN_SUPPORTED_ANRDOID
                }
                return !1
            }, t.getIosARFileFormat = function() {
                return r.AR_FILE_EXTENSIONS.USDZ
            }, t.getAndroidARFileFormat = function() {
                return r.AR_FILE_EXTENSIONS.GLB
            }, t.getARType = function(e) {
                var t = e.shouldShowARButton,
                    n = e.force3D,
                    i = e.modalTitle;
                return t ? n ? r.AR_BUTTON_TYPE.MODEL_VIEWER : r.AR_BUTTON_TYPE.NATIVE_AR_EXPERIENCE : !t && i ? r.AR_BUTTON_TYPE.QR_MODAL : null
            }, t.getARDescription = function(e) {
                switch (e) {
                    case r.AR_BUTTON_TYPE.MODEL_VIEWER:
                        return r.AR_BUTTON_DESCRIPTION.MODEL_VIEWER;
                    case r.AR_BUTTON_TYPE.NATIVE_AR_EXPERIENCE:
                        return r.AR_BUTTON_DESCRIPTION.NATIVE_AR_EXPERIENCE;
                    case r.AR_BUTTON_TYPE.QR_MODAL:
                        return r.AR_BUTTON_DESCRIPTION.QR_MODAL;
                    default:
                        return ""
                }
            }
        },
        90155: (e, t, n) => {
            "use strict";

            function r(e) {
                return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = void 0;
            var i = function(e, t) {
                    if (e && e.__esModule) return e;
                    if (null === e || "object" !== r(e) && "function" != typeof e) return {
                        default: e
                    };
                    var n = h(void 0);
                    if (n && n.has(e)) return n.get(e);
                    var i = {},
                        a = Object.defineProperty && Object.getOwnPropertyDescriptor;
                    for (var o in e)
                        if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                            var s = a ? Object.getOwnPropertyDescriptor(e, o) : null;
                            s && (s.get || s.set) ? Object.defineProperty(i, o, s) : i[o] = e[o]
                        }
                    return i.default = e, n && n.set(e, i), i
                }(n(96540)),
                a = c(n(20053)),
                o = c(n(79347)),
                s = c(n(5556));
            n(18801);
            var l = c(n(30704)),
                u = c(n(30408));

            function c(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }

            function h(e) {
                if ("function" != typeof WeakMap) return null;
                var t = new WeakMap,
                    n = new WeakMap;
                return (h = function(e) {
                    return e ? n : t
                })(e)
            }
            var d = "ar-logo",
                f = "".concat(d, "__icon"),
                p = "".concat(d, "__content"),
                m = function(e) {
                    var t, n = e.iconTheme,
                        r = e.iconType,
                        s = e.className,
                        c = e.children,
                        h = (0, i.useMemo)(function() {
                            return "light" !== n ? l.default : u.default
                        }, [n]),
                        m = (0, a.default)(s, (f in (t = {}) ? Object.defineProperty(t, f, {
                            value: !0,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : t[f] = !0, t)),
                        v = (0, i.useMemo)(function() {
                            return "animated" === r ? i.default.createElement("img", {
                                className: m,
                                src: h,
                                alt: "ar-logo",
                                loading: "lazy"
                            }) : i.default.createElement("div", {
                                className: m
                            }, i.default.createElement(o.default, {
                                iconName: "ar-logo"
                            }))
                        }, [r, m, h]);
                    return i.default.createElement(i.default.Fragment, null, i.default.createElement("img", null), i.default.createElement("div", {
                        className: d,
                        "data-test": "ar-logo"
                    }, v, i.default.createElement("div", {
                        className: p
                    }, c)))
                };
            m.propTypes = {
                iconTheme: s.default.oneOf(["light", "dark"]),
                iconType: s.default.oneOf(["default", "animated"]),
                className: s.default.string,
                children: s.default.oneOfType([s.default.node, s.default.arrayOf(s.default.node)])
            }, m.defaultProps = {
                iconTheme: "dark",
                iconType: "animated",
                className: "",
                children: null
            }, t.default = m
        },
        61106: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), Object.defineProperty(t, "default", {
                enumerable: !0,
                get: function() {
                    return r.default
                }
            });
            var r = function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }(n(90155))
        },
        72134: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), Object.defineProperty(t, "withLazyLoad", {
                enumerable: !0,
                get: function() {
                    return r.default
                }
            });
            var r = function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }(n(67974))
        },
        67974: (e, t, n) => {
            "use strict";

            function r(e) {
                return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = void 0;
            var i = function(e, t) {
                if (e && e.__esModule) return e;
                if (null === e || "object" !== r(e) && "function" != typeof e) return {
                    default: e
                };
                var n = a(void 0);
                if (n && n.has(e)) return n.get(e);
                var i = {},
                    o = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var s in e)
                    if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
                        var l = o ? Object.getOwnPropertyDescriptor(e, s) : null;
                        l && (l.get || l.set) ? Object.defineProperty(i, s, l) : i[s] = e[s]
                    }
                return i.default = e, n && n.set(e, i), i
            }(n(96540));

            function a(e) {
                if ("function" != typeof WeakMap) return null;
                var t = new WeakMap,
                    n = new WeakMap;
                return (a = function(e) {
                    return e ? n : t
                })(e)
            }
            t.default = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                    n = function(n) {
                        return i.default.createElement(i.Suspense, {
                            fallback: t
                        }, i.default.createElement(e, n))
                    };
                return n.displayName = "WithLazyLoad(".concat(e.displayName || e.name, ")"), n
            }
        },
        72972: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "yj", {
                enumerable: !0,
                get: function() {
                    return i.AR_BUTTON_DESCRIPTION
                }
            }), Object.defineProperty(t, "WS", {
                enumerable: !0,
                get: function() {
                    return i.AR_BUTTON_TYPE
                }
            }), Object.defineProperty(t, "Ay", {
                enumerable: !0,
                get: function() {
                    return r.default
                }
            });
            var r = a(n(15667)),
                i = n(5321);

            function a(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            a(n(61106))
        },
        32724: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = void 0;
            var r = n(96540);

            function i(e) {
                return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function a(e) {
                if ("function" != typeof WeakMap) return null;
                var t = new WeakMap,
                    n = new WeakMap;
                return (a = function(e) {
                    return e ? n : t
                })(e)
            }
            var o = (0, n(72134).withLazyLoad)((0, r.lazy)(function() {
                return Promise.resolve().then(function() {
                    return function(e, t) {
                        if (e && e.__esModule) return e;
                        if (null === e || "object" !== i(e) && "function" != typeof e) return {
                            default: e
                        };
                        var n = a(void 0);
                        if (n && n.has(e)) return n.get(e);
                        var r = {},
                            o = Object.defineProperty && Object.getOwnPropertyDescriptor;
                        for (var s in e)
                            if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
                                var l = o ? Object.getOwnPropertyDescriptor(e, s) : null;
                                l && (l.get || l.set) ? Object.defineProperty(r, s, l) : r[s] = e[s]
                            }
                        return r.default = e, n && n.set(e, r), r
                    }(n(47680))
                })
            }));
            t.default = o
        },
        47680: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = void 0;
            var r = o(n(96540)),
                i = o(n(5556));
            n(8930);
            var a = n(26899);

            function o(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            n(16012);
            var s = "google-viewer-modal",
                l = {
                    root: s,
                    close: "".concat(s, "__close-btn"),
                    contentContainer: "".concat(s, "__content-container")
                },
                u = function(e) {
                    var t = e.open,
                        n = e.onClose,
                        i = e.href;
                    return r.default.createElement(a.Modal, {
                        open: t,
                        isFullscreen: !0,
                        onClose: n,
                        contentClassName: l.root,
                        closeButtonClassName: l.close,
                        childrenContainerClassName: l.contentContainer
                    }, r.default.createElement("model-viewer", {
                        src: i,
                        alt: "",
                        "shadow-intensity": "1",
                        "camera-controls": !0,
                        "auto-rotate": !0,
                        "ar-modes": "webxr",
                        ar: !0
                    }))
                };
            u.propTypes = {
                open: i.default.bool.isRequired,
                href: i.default.string.isRequired,
                onClose: i.default.func.isRequired
            }, u.displayName = "ModelViewer", t.default = u
        },
        27870: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = void 0;
            var r = n(96540);

            function i(e) {
                return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function a(e) {
                if ("function" != typeof WeakMap) return null;
                var t = new WeakMap,
                    n = new WeakMap;
                return (a = function(e) {
                    return e ? n : t
                })(e)
            }
            var o = (0, n(72134).withLazyLoad)((0, r.lazy)(function() {
                return Promise.resolve().then(function() {
                    return function(e, t) {
                        if (e && e.__esModule) return e;
                        if (null === e || "object" !== i(e) && "function" != typeof e) return {
                            default: e
                        };
                        var n = a(void 0);
                        if (n && n.has(e)) return n.get(e);
                        var r = {},
                            o = Object.defineProperty && Object.getOwnPropertyDescriptor;
                        for (var s in e)
                            if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
                                var l = o ? Object.getOwnPropertyDescriptor(e, s) : null;
                                l && (l.get || l.set) ? Object.defineProperty(r, s, l) : r[s] = e[s]
                            }
                        return r.default = e, n && n.set(e, r), r
                    }(n(98730))
                })
            }));
            t.default = o
        },
        98730: (e, t, n) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = void 0;
            var r = s(n(96540)),
                i = s(n(5556)),
                a = s(n(15286)),
                o = n(26899);

            function s(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            n(80161);
            var l = "qr-modal",
                u = {
                    root: l,
                    title: "".concat(l, "__title"),
                    body: "".concat(l, "__body"),
                    close: "".concat(l, "__close-btn")
                },
                c = function(e) {
                    var t = e.open,
                        n = e.title,
                        i = e.body,
                        s = e.url,
                        l = e.size,
                        c = e.onClose;
                    return t && (s || window.location.href) ? r.default.createElement(o.Modal, {
                        open: !0,
                        isFullscreen: !0,
                        onClose: c,
                        contentClassName: u.root,
                        closeButtonClassName: u.close
                    }, r.default.createElement("p", {
                        className: u.title
                    }, n), r.default.createElement("div", {
                        className: u.body,
                        dangerouslySetInnerHTML: {
                            __html: i
                        }
                    }), r.default.createElement(a.default, {
                        value: s || window.location.href,
                        size: void 0 === l ? 108 : l
                    })) : null
                };
            c.propTypes = {
                open: i.default.bool,
                title: i.default.string,
                body: i.default.string,
                url: i.default.string,
                size: i.default.number,
                onClose: i.default.func
            }, c.displayName = "QRModal", t.default = c
        },
        8930: (e, t, n) => {
            "use strict";
            n.r(t), n.d(t, {
                ModelViewerElement: () => mj
            });
            var r, i, a, o, s, l, u, c, h, d, f, p, m, v, g, y, _, x, b, w, M, S, T = n(41374),
                E = n(14880),
                k = n(30494),
                A = n(99407),
                R = n(50467),
                C = n(23239);

            function L(e, t, n) {
                return (L = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, n) {
                    var r = function(e, t) {
                        for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = (0, C._)(e)););
                        return e
                    }(e, t);
                    if (r) {
                        var i = Object.getOwnPropertyDescriptor(r, t);
                        return i.get ? i.get.call(n || e) : i.value
                    }
                })(e, t, n || e)
            }
            var P = n(20884),
                I = n(71893),
                D = n(2008),
                O = n(93038),
                N = n(84577),
                F = n(68101),
                U = n(61642),
                B = n(11853),
                z = n(87218);

            function H() {
                var e = (0, N._)(['\n<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"\n	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"\n	 viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">\n<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>\n<g id="Art_layer">\n	<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>\n	<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>\n	<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>\n	<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>\n	<g>\n		<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3\n			l5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62\n			l4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>\n	</g>\n</g>\n</svg>']);
                return H = function() {
                    return e
                }, e
            }

            function V() {
                var e = (0, N._)(['\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">\n    <defs>\n        <path id="A" d="M.001.232h24.997V36H.001z" />\n    </defs>\n    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">\n        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />\n        <g transform="translate(11 3)">\n            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />\n            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />\n            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />\n            <g transform="translate(0 .769)">\n                <mask id="B" fill="#fff">\n                    <use xlink:href="#A" />\n                </mask>\n                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />\n            </g>\n        </g>\n    </g>\n</svg>']);
                return V = function() {
                    return e
                }, e
            }

            function G() {
                var e = (0, N._)(['\n<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">\n    \x3c!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement\n         support for dynamic re-coloring of UI components --\x3e\n    <defs>\n      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">\n        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>\n        <feOffset dx="0" dy="0" result="offsetblur"/>\n        <feFlood flood-color="#000000"/>\n        <feComposite in2="offsetblur" operator="in"/>\n        <feMerge>\n          <feMergeNode/>\n          <feMergeNode in="SourceGraphic"/>\n        </feMerge>\n      </filter>\n    </defs>\n    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>']);
                return G = function() {
                    return e
                }, e
            }

            function W() {
                var e = (0, N._)(['\n<style>\n:host {\n  display: block;\n  position: relative;\n  contain: strict;\n  width: 300px;\n  height: 150px;\n}\n\n/* NOTE: This ruleset is our integration surface area with the\n * :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196 */\n:host([data-js-focus-visible]:focus:not(.focus-visible)),\n:host([data-js-focus-visible]) :focus:not(.focus-visible) {\n  outline: none;\n}\n\n.container {\n  position: relative;\n}\n\n.userInput {\n  width: 100%;\n  height: 100%;\n  display: block;\n  position: relative;\n  overflow: hidden;\n}\n\ncanvas {\n  position: absolute;\n  display: none;\n  pointer-events: none;\n  /* NOTE(cdata): Chrome 76 and below apparently have a bug\n   * that causes our canvas not to display pixels unless it is\n   * on its own render layer\n   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893\n   */\n  transform: translateZ(0);\n}\n\ncanvas.show {\n  display: block;\n}\n\n/* Adapted from HTML5 Boilerplate\n *\n * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */\n.screen-reader-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  white-space: nowrap;\n  width: 1px;\n}\n\n.slot {\n  position: absolute;\n  pointer-events: none;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.slot > * {\n  pointer-events: initial;\n}\n\n.annotation-wrapper ::slotted(*) {\n  opacity: var(--max-hotspot-opacity, 1);\n  transition: opacity 0.3s;\n}\n\n.pointer-tumbling .annotation-wrapper ::slotted(*) {\n  pointer-events: none;\n}\n\n.annotation-wrapper ::slotted(*) {\n  pointer-events: initial;\n}\n\n.annotation-wrapper.hide ::slotted(*) {\n  opacity: var(--min-hotspot-opacity, 0.25);\n}\n\n.slot.poster {\n  opacity: 0;\n  transition: opacity 0.3s 0.3s;\n  background-color: inherit;\n}\n\n.slot.poster.show {\n  opacity: 1;\n  transition: none;\n}\n\n.slot.poster.quick {\n  transition: none;\n}\n\n.slot.poster > * {\n  pointer-events: initial;\n}\n\n.slot.poster:not(.show) > * {\n  pointer-events: none;\n}\n\n#default-poster {\n  width: 100%;\n  height: 100%;\n  /* The default poster is a <button> so we need to set display\n   * to prevent it from being affected by text-align: */\n  display: block;\n  position: absolute;\n  border: none;\n  padding: 0;\n  background-size: contain;\n  background-repeat: no-repeat;\n  background-position: center;\n  background-color: var(--poster-color, #fff);\n  background-image: var(--poster-image, none);\n}\n\n#default-progress-bar {\n  display: block;\n  position: relative;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  overflow: hidden;\n}\n\n#default-progress-bar > .mask {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: var(--progress-mask, #fff);\n  transition: opacity 0.3s;\n  opacity: 0.2;\n}\n\n#default-progress-bar > .bar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: var(--progress-bar-height, 5px);\n  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));\n  transition: transform 0.09s;\n  transform-origin: top left;\n  transform: scaleX(0);\n  overflow: hidden;\n}\n\n#default-progress-bar > .bar.hide {\n  transition: opacity 0.3s 1s;\n  opacity: 0;\n}\n\n.slot.interaction-prompt {\n  display: var(--interaction-prompt-display, flex);\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  align-items: center;\n  justify-content: center;\n\n  opacity: 0;\n  will-change: opacity;\n  overflow: hidden;\n  transition: opacity 0.3s;\n}\n\n.slot.interaction-prompt.visible {\n  opacity: 1;\n}\n\n.slot.interaction-prompt > .animated-container {\n  will-change: transform, opacity;\n}\n\n.slot.interaction-prompt > * {\n  pointer-events: none;\n}\n\n.slot.ar-button {\n  -moz-user-select: none;\n  -webkit-tap-highlight-color: transparent;\n  user-select: none;\n\n  display: var(--ar-button-display, block);\n}\n\n.slot.ar-button:not(.enabled) {\n  display: none;\n}\n\n.fab {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  width: 40px;\n  height: 40px;\n  cursor: pointer;\n  background-color: #fff;\n  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);\n  border-radius: 100px;\n}\n\n.fab > * {\n  opacity: 0.87;\n}\n\n#default-ar-button {\n  position: absolute;\n  bottom: 16px;\n  right: 16px;\n  transform: scale(var(--ar-button-scale, 1));\n  transform-origin: bottom right;\n}\n\n.slot.default {\n  pointer-events: none;\n}\n\n.slot.progress-bar {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button:not(.enabled) {\n  display: none;\n}\n\n#default-exit-webxr-ar-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  top: 16px;\n  right: 16px;\n  width: 40px;\n  height: 40px;\n  box-sizing: border-box;\n}\n\n#default-exit-webxr-ar-button > svg {\n  fill: #fff;\n}\n</style>\n<div class="container">\n  <div class="userInput" tabindex="0" role="img"\n      aria-label="A depiction of a 3D model"\n      aria-live="polite">\n      <div class="slot canvas">\n        <slot name="canvas">\n          <canvas></canvas>\n        </slot>\n      </div>\n  </div>\n\n  \x3c!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM\n        will have their <slot> elements removed by ShadyCSS --\x3e\n  <div class="slot poster">\n    <slot name="poster">\n      <button type="button" id="default-poster" aria-hidden="true" aria-label="Activate to view in 3D!"></button>\n    </slot>\n  </div>\n\n  <div class="slot ar-button">\n    <slot name="ar-button">\n      <a id="default-ar-button" part="default-ar-button" class="fab"\n          tabindex="2"\n          aria-label="View this 3D model up close">\n        ', '\n      </a>\n    </slot>\n  </div>\n\n  <div class="slot interaction-prompt">\n    <div class="animated-container">\n      <slot name="interaction-prompt" aria-hidden="true">\n        ', '\n      </slot>\n    </div>\n  </div>\n\n  <div class="slot default">\n    <slot></slot>\n\n    <div class="slot progress-bar">\n      <slot name="progress-bar">\n        <div id="default-progress-bar" aria-hidden="true">\n          <div class="mask" part="default-progress-mask"></div>\n          <div class="bar" part="default-progress-bar"></div>\n        </div>\n      </slot>\n    </div>\n    \n    <div class="slot exit-webxr-ar-button">\n      <slot name="exit-webxr-ar-button">\n        <a id="default-exit-webxr-ar-button" part="default-exit-webxr-ar-button"\n            tabindex="3"\n            aria-label="Exit AR"\n            aria-hidden="true">\n          ', "\n        </a>\n      </slot>\n    </div>\n  </div>\n</div>"]);
                return W = function() {
                    return e
                }, e
            }
            var j = null != window.customElements && void 0 !== window.customElements.polyfillWrapFlushCallback,
                q = function(e, t) {
                    for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; t !== n;) {
                        var r = t.nextSibling;
                        e.removeChild(t), t = r
                    }
                },
                X = "{{lit-".concat(String(Math.random()).slice(2), "}}"),
                Y = "\x3c!--".concat(X, "--\x3e"),
                J = new RegExp("".concat(X, "|").concat(Y)),
                Z = function e(t, n) {
                    (0, k._)(this, e), this.parts = [], this.element = n;
                    for (var r = [], i = [], a = document.createTreeWalker(n.content, 133, null, !1), o = 0, s = -1, l = 0, u = t.strings, c = t.values.length; l < c;) {
                        var h = a.nextNode();
                        if (null !== h) {
                            if (s++, 1 === h.nodeType) {
                                if (h.hasAttributes()) {
                                    for (var d = h.attributes, f = d.length, p = 0, m = 0; m < f; m++) K(d[m].name, "$lit$") && p++;
                                    for (; p-- > 0;) {
                                        var v = u[l],
                                            g = ee.exec(v)[2],
                                            y = g.toLowerCase() + "$lit$",
                                            _ = h.getAttribute(y);
                                        h.removeAttribute(y);
                                        var x = _.split(J);
                                        this.parts.push({
                                            type: "attribute",
                                            index: s,
                                            name: g,
                                            strings: x
                                        }), l += x.length - 1
                                    }
                                }
                                "TEMPLATE" === h.tagName && (i.push(h), a.currentNode = h.content)
                            } else if (3 === h.nodeType) {
                                var b = h.data;
                                if (b.indexOf(X) >= 0) {
                                    for (var w = h.parentNode, M = b.split(J), S = M.length - 1, T = 0; T < S; T++) {
                                        var E = void 0,
                                            A = M[T];
                                        if ("" === A) E = $();
                                        else {
                                            var R = ee.exec(A);
                                            null !== R && K(R[2], "$lit$") && (A = A.slice(0, R.index) + R[1] + R[2].slice(0, -5) + R[3]), E = document.createTextNode(A)
                                        }
                                        w.insertBefore(E, h), this.parts.push({
                                            type: "node",
                                            index: ++s
                                        })
                                    }
                                    "" === M[S] ? (w.insertBefore($(), h), r.push(h)) : h.data = M[S], l += S
                                }
                            } else if (8 === h.nodeType) {
                                if (h.data === X) {
                                    var C = h.parentNode;
                                    null !== h.previousSibling && s !== o || (s++, C.insertBefore($(), h)), o = s, this.parts.push({
                                        type: "node",
                                        index: s
                                    }), null === h.nextSibling ? h.data = "" : (r.push(h), s--), l++
                                } else
                                    for (var L = -1; - 1 !== (L = h.data.indexOf(X, L + 1));) this.parts.push({
                                        type: "node",
                                        index: -1
                                    }), l++
                            }
                        } else a.currentNode = i.pop()
                    }
                    var P = !0,
                        I = !1,
                        D = void 0;
                    try {
                        for (var O, N = r[Symbol.iterator](); !(P = (O = N.next()).done); P = !0) {
                            var F = O.value;
                            F.parentNode.removeChild(F)
                        }
                    } catch (e) {
                        I = !0, D = e
                    } finally {
                        try {
                            P || null == N.return || N.return()
                        } finally {
                            if (I) throw D
                        }
                    }
                },
                K = function(e, t) {
                    var n = e.length - t.length;
                    return n >= 0 && e.slice(n) === t
                },
                Q = function(e) {
                    return -1 !== e.index
                },
                $ = function() {
                    return document.createComment("")
                },
                ee = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

            function et(e, t) {
                for (var n = e.element.content, r = e.parts, i = document.createTreeWalker(n, 133, null, !1), a = er(r), o = r[a], s = -1, l = 0, u = [], c = null; i.nextNode();) {
                    s++;
                    var h = i.currentNode;
                    for (h.previousSibling === c && (c = null), t.has(h) && (u.push(h), null === c && (c = h)), null !== c && l++; void 0 !== o && o.index === s;) o.index = null !== c ? -1 : o.index - l, a = er(r, a), o = r[a]
                }
                u.forEach(function(e) {
                    return e.parentNode.removeChild(e)
                })
            }
            var en = function(e) {
                    for (var t = 11 === e.nodeType ? 0 : 1, n = document.createTreeWalker(e, 133, null, !1); n.nextNode();) t++;
                    return t
                },
                er = function(e) {
                    for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1, n = t + 1; n < e.length; n++)
                        if (Q(e[n])) return n;
                    return -1
                },
                ei = new WeakMap,
                ea = function(e) {
                    return "function" == typeof e && ei.has(e)
                },
                eo = {},
                es = {},
                el = function() {
                    function e(t, n, r) {
                        (0, k._)(this, e), this.__parts = [], this.template = t, this.processor = n, this.options = r
                    }
                    return (0, A._)(e, [{
                        key: "update",
                        value: function(e) {
                            var t = 0,
                                n = !0,
                                r = !1,
                                i = void 0;
                            try {
                                for (var a, o = this.__parts[Symbol.iterator](); !(n = (a = o.next()).done); n = !0) {
                                    var s = a.value;
                                    void 0 !== s && s.setValue(e[t]), t++
                                }
                            } catch (e) {
                                r = !0, i = e
                            } finally {
                                try {
                                    n || null == o.return || o.return()
                                } finally {
                                    if (r) throw i
                                }
                            }
                            var l = !0,
                                u = !1,
                                c = void 0;
                            try {
                                for (var h, d = this.__parts[Symbol.iterator](); !(l = (h = d.next()).done); l = !0) {
                                    var f = h.value;
                                    void 0 !== f && f.commit()
                                }
                            } catch (e) {
                                u = !0, c = e
                            } finally {
                                try {
                                    l || null == d.return || d.return()
                                } finally {
                                    if (u) throw c
                                }
                            }
                        }
                    }, {
                        key: "_clone",
                        value: function() {
                            for (var e, t, n = j ? this.template.element.content.cloneNode(!0) : document.importNode(this.template.element.content, !0), r = [], i = this.template.parts, a = document.createTreeWalker(n, 133, null, !1), o = 0, s = 0, l = a.nextNode(); o < i.length;)
                                if (Q(t = i[o])) {
                                    for (; s < t.index;) s++, "TEMPLATE" === l.nodeName && (r.push(l), a.currentNode = l.content), null === (l = a.nextNode()) && (a.currentNode = r.pop(), l = a.nextNode());
                                    if ("node" === t.type) {
                                        var u = this.processor.handleTextExpression(this.options);
                                        u.insertAfterNode(l.previousSibling), this.__parts.push(u)
                                    } else(e = this.__parts).push.apply(e, (0, F._)(this.processor.handleAttributeExpressions(l, t.name, t.strings, this.options)));
                                    o++
                                } else this.__parts.push(void 0), o++;
                            return j && (document.adoptNode(n), customElements.upgrade(n)), n
                        }
                    }]), e
                }(),
                eu = window.trustedTypes && trustedTypes.createPolicy("lit-html", {
                    createHTML: function(e) {
                        return e
                    }
                }),
                ec = " ".concat(X, " "),
                eh = function() {
                    function e(t, n, r, i) {
                        (0, k._)(this, e), this.strings = t, this.values = n, this.type = r, this.processor = i
                    }
                    return (0, A._)(e, [{
                        key: "getHTML",
                        value: function() {
                            for (var e = this.strings.length - 1, t = "", n = !1, r = 0; r < e; r++) {
                                var i = this.strings[r],
                                    a = i.lastIndexOf("\x3c!--");
                                n = (a > -1 || n) && -1 === i.indexOf("--\x3e", a + 1);
                                var o = ee.exec(i);
                                t += null === o ? i + (n ? ec : Y) : i.substr(0, o.index) + o[1] + o[2] + "$lit$" + o[3] + X
                            }
                            return t + this.strings[e]
                        }
                    }, {
                        key: "getTemplateElement",
                        value: function() {
                            var e = document.createElement("template"),
                                t = this.getHTML();
                            return void 0 !== eu && (t = eu.createHTML(t)), e.innerHTML = t, e
                        }
                    }]), e
                }(),
                ed = function(e) {
                    return null === e || !("object" == (void 0 === e ? "undefined" : (0, U._)(e)) || "function" == typeof e)
                },
                ef = function(e) {
                    return Array.isArray(e) || !(!e || !e[Symbol.iterator])
                },
                ep = function() {
                    function e(t, n, r) {
                        (0, k._)(this, e), this.dirty = !0, this.element = t, this.name = n, this.strings = r, this.parts = [];
                        for (var i = 0; i < r.length - 1; i++) this.parts[i] = this._createPart()
                    }
                    return (0, A._)(e, [{
                        key: "_createPart",
                        value: function() {
                            return new em(this)
                        }
                    }, {
                        key: "_getValue",
                        value: function() {
                            var e = this.strings,
                                t = e.length - 1,
                                n = this.parts;
                            if (1 === t && "" === e[0] && "" === e[1]) {
                                var r = n[0].value;
                                if ("symbol" == (void 0 === r ? "undefined" : (0, U._)(r))) return String(r);
                                if ("string" == typeof r || !ef(r)) return r
                            }
                            for (var i = "", a = 0; a < t; a++) {
                                i += e[a];
                                var o = n[a];
                                if (void 0 !== o) {
                                    var s = o.value,
                                        l = !0,
                                        u = !1,
                                        c = void 0;
                                    if (ed(s) || !ef(s)) i += "string" == typeof s ? s : String(s);
                                    else try {
                                        for (var h, d = s[Symbol.iterator](); !(l = (h = d.next()).done); l = !0) {
                                            var f = h.value;
                                            i += "string" == typeof f ? f : String(f)
                                        }
                                    } catch (e) {
                                        u = !0, c = e
                                    } finally {
                                        try {
                                            l || null == d.return || d.return()
                                        } finally {
                                            if (u) throw c
                                        }
                                    }
                                }
                            }
                            return i + e[t]
                        }
                    }, {
                        key: "commit",
                        value: function() {
                            this.dirty && (this.dirty = !1, this.element.setAttribute(this.name, this._getValue()))
                        }
                    }]), e
                }(),
                em = function() {
                    function e(t) {
                        (0, k._)(this, e), this.value = void 0, this.committer = t
                    }
                    return (0, A._)(e, [{
                        key: "setValue",
                        value: function(e) {
                            e === eo || ed(e) && e === this.value || (this.value = e, ea(e) || (this.committer.dirty = !0))
                        }
                    }, {
                        key: "commit",
                        value: function() {
                            for (; ea(this.value);) {
                                var e = this.value;
                                this.value = eo, e(this)
                            }
                            this.value !== eo && this.committer.commit()
                        }
                    }]), e
                }(),
                ev = function() {
                    function e(t) {
                        (0, k._)(this, e), this.value = void 0, this.__pendingValue = void 0, this.options = t
                    }
                    return (0, A._)(e, [{
                        key: "appendInto",
                        value: function(e) {
                            this.startNode = e.appendChild($()), this.endNode = e.appendChild($())
                        }
                    }, {
                        key: "insertAfterNode",
                        value: function(e) {
                            this.startNode = e, this.endNode = e.nextSibling
                        }
                    }, {
                        key: "appendIntoPart",
                        value: function(e) {
                            e.__insert(this.startNode = $()), e.__insert(this.endNode = $())
                        }
                    }, {
                        key: "insertAfterPart",
                        value: function(e) {
                            e.__insert(this.startNode = $()), this.endNode = e.endNode, e.endNode = this.startNode
                        }
                    }, {
                        key: "setValue",
                        value: function(e) {
                            this.__pendingValue = e
                        }
                    }, {
                        key: "commit",
                        value: function() {
                            if (null !== this.startNode.parentNode) {
                                for (; ea(this.__pendingValue);) {
                                    var e = this.__pendingValue;
                                    this.__pendingValue = eo, e(this)
                                }
                                var t = this.__pendingValue;
                                t !== eo && (ed(t) ? t !== this.value && this.__commitText(t) : t instanceof eh ? this.__commitTemplateResult(t) : t instanceof Node ? this.__commitNode(t) : ef(t) ? this.__commitIterable(t) : t === es ? (this.value = es, this.clear()) : this.__commitText(t))
                            }
                        }
                    }, {
                        key: "__insert",
                        value: function(e) {
                            this.endNode.parentNode.insertBefore(e, this.endNode)
                        }
                    }, {
                        key: "__commitNode",
                        value: function(e) {
                            this.value !== e && (this.clear(), this.__insert(e), this.value = e)
                        }
                    }, {
                        key: "__commitText",
                        value: function(e) {
                            var t = this.startNode.nextSibling,
                                n = "string" == typeof(e = null == e ? "" : e) ? e : String(e);
                            t === this.endNode.previousSibling && 3 === t.nodeType ? t.data = n : this.__commitNode(document.createTextNode(n)), this.value = e
                        }
                    }, {
                        key: "__commitTemplateResult",
                        value: function(e) {
                            var t = this.options.templateFactory(e);
                            if (this.value instanceof el && this.value.template === t) this.value.update(e.values);
                            else {
                                var n = new el(t, e.processor, this.options),
                                    r = n._clone();
                                n.update(e.values), this.__commitNode(r), this.value = n
                            }
                        }
                    }, {
                        key: "__commitIterable",
                        value: function(t) {
                            Array.isArray(this.value) || (this.value = [], this.clear());
                            var n, r = this.value,
                                i = 0,
                                a = !0,
                                o = !1,
                                s = void 0;
                            try {
                                for (var l, u = t[Symbol.iterator](); !(a = (l = u.next()).done); a = !0) {
                                    var c = l.value;
                                    n = r[i], void 0 === n && (n = new e(this.options), r.push(n), 0 === i ? n.appendIntoPart(this) : n.insertAfterPart(r[i - 1])), n.setValue(c), n.commit(), i++
                                }
                            } catch (e) {
                                o = !0, s = e
                            } finally {
                                try {
                                    a || null == u.return || u.return()
                                } finally {
                                    if (o) throw s
                                }
                            }
                            i < r.length && (r.length = i, this.clear(n && n.endNode))
                        }
                    }, {
                        key: "clear",
                        value: function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.startNode;
                            q(this.startNode.parentNode, e.nextSibling, this.endNode)
                        }
                    }]), e
                }(),
                eg = function() {
                    function e(t, n, r) {
                        if ((0, k._)(this, e), this.value = void 0, this.__pendingValue = void 0, 2 !== r.length || "" !== r[0] || "" !== r[1]) throw Error("Boolean attributes can only contain a single expression");
                        this.element = t, this.name = n, this.strings = r
                    }
                    return (0, A._)(e, [{
                        key: "setValue",
                        value: function(e) {
                            this.__pendingValue = e
                        }
                    }, {
                        key: "commit",
                        value: function() {
                            for (; ea(this.__pendingValue);) {
                                var e = this.__pendingValue;
                                this.__pendingValue = eo, e(this)
                            }
                            if (this.__pendingValue !== eo) {
                                var t = !!this.__pendingValue;
                                this.value !== t && (t ? this.element.setAttribute(this.name, "") : this.element.removeAttribute(this.name), this.value = t), this.__pendingValue = eo
                            }
                        }
                    }]), e
                }(),
                ey = function(e) {
                    function t(e, n, r) {
                        var i;
                        return (0, k._)(this, t), (i = (0, E._)(this, t, [e, n, r])).single = 2 === r.length && "" === r[0] && "" === r[1], i
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "_createPart",
                        value: function() {
                            return new e_(this)
                        }
                    }, {
                        key: "_getValue",
                        value: function() {
                            return this.single ? this.parts[0].value : L((0, C._)(t.prototype), "_getValue", this).call(this)
                        }
                    }, {
                        key: "commit",
                        value: function() {
                            this.dirty && (this.dirty = !1, this.element[this.name] = this._getValue())
                        }
                    }]), t
                }(ep),
                e_ = function(e) {
                    function t() {
                        return (0, k._)(this, t), (0, E._)(this, t, arguments)
                    }
                    return (0, P._)(t, e), t
                }(em),
                ex = !1;
            ! function() {
                try {
                    var e = {
                        get capture() {
                            return ex = !0, !1
                        }
                    };
                    window.addEventListener("test", e, e), window.removeEventListener("test", e, e)
                } catch (e) {}
            }();
            var eb = function() {
                    function e(t, n, r) {
                        var i = this;
                        (0, k._)(this, e), this.value = void 0, this.__pendingValue = void 0, this.element = t, this.eventName = n, this.eventContext = r, this.__boundHandleEvent = function(e) {
                            return i.handleEvent(e)
                        }
                    }
                    return (0, A._)(e, [{
                        key: "setValue",
                        value: function(e) {
                            this.__pendingValue = e
                        }
                    }, {
                        key: "commit",
                        value: function() {
                            for (; ea(this.__pendingValue);) {
                                var e = this.__pendingValue;
                                this.__pendingValue = eo, e(this)
                            }
                            if (this.__pendingValue !== eo) {
                                var t = this.__pendingValue,
                                    n = this.value,
                                    r = null == t || null != n && (t.capture !== n.capture || t.once !== n.once || t.passive !== n.passive),
                                    i = null != t && (null == n || r);
                                r && this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options), i && (this.__options = ew(t), this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options)), this.value = t, this.__pendingValue = eo
                            }
                        }
                    }, {
                        key: "handleEvent",
                        value: function(e) {
                            "function" == typeof this.value ? this.value.call(this.eventContext || this.element, e) : this.value.handleEvent(e)
                        }
                    }]), e
                }(),
                ew = function(e) {
                    return e && (ex ? {
                        capture: e.capture,
                        passive: e.passive,
                        once: e.once
                    } : e.capture)
                };

            function eM(e) {
                var t = eS.get(e.type);
                void 0 === t && (t = {
                    stringsArray: new WeakMap,
                    keyString: new Map
                }, eS.set(e.type, t));
                var n = t.stringsArray.get(e.strings);
                if (void 0 !== n) return n;
                var r = e.strings.join(X);
                return void 0 === (n = t.keyString.get(r)) && (n = new Z(e, e.getTemplateElement()), t.keyString.set(r, n)), t.stringsArray.set(e.strings, n), n
            }
            var eS = new Map,
                eT = new WeakMap,
                eE = function(e, t, n) {
                    var r = eT.get(t);
                    void 0 === r && (q(t, t.firstChild), eT.set(t, r = new ev(Object.assign({
                        templateFactory: eM
                    }, n))), r.appendInto(t)), r.setValue(e), r.commit()
                },
                ek = new(function() {
                    function e() {
                        (0, k._)(this, e)
                    }
                    return (0, A._)(e, [{
                        key: "handleAttributeExpressions",
                        value: function(e, t, n, r) {
                            var i = t[0];
                            return "." === i ? new ey(e, t.slice(1), n).parts : "@" === i ? [new eb(e, t.slice(1), r.eventContext)] : "?" === i ? [new eg(e, t.slice(1), n)] : new ep(e, t, n).parts
                        }
                    }, {
                        key: "handleTextExpression",
                        value: function(e) {
                            return new ev(e)
                        }
                    }]), e
                }());
            (window.litHtmlVersions || (window.litHtmlVersions = [])).push("1.4.1");
            var eA = function(e) {
                    for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
                    return new eh(e, n, "html", ek)
                },
                eR = function(e, t) {
                    return "".concat(e, "--").concat(t)
                },
                eC = !0;
            void 0 === window.ShadyCSS ? eC = !1 : void 0 === window.ShadyCSS.prepareTemplateDom && (console.warn("Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1."), eC = !1);
            var eL = ["html", "svg"],
                eP = new Set,
                eI = function(e, t, n) {
                    eP.add(e);
                    var r = n ? n.element : document.createElement("template"),
                        i = t.querySelectorAll("style"),
                        a = i.length;
                    if (0 === a) return void window.ShadyCSS.prepareTemplateStyles(r, e);
                    for (var o = document.createElement("style"), s = 0; s < a; s++) {
                        var l = i[s];
                        l.parentNode.removeChild(l), o.textContent += l.textContent
                    }
                    eL.forEach(function(t) {
                        var n = eS.get(eR(t, e));
                        void 0 !== n && n.keyString.forEach(function(e) {
                            var t = e.element.content,
                                n = new Set;
                            Array.from(t.querySelectorAll("style")).forEach(function(e) {
                                n.add(e)
                            }), et(e, n)
                        })
                    });
                    var u = r.content;
                    n ? function(e, t) {
                        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                            r = e.element.content,
                            i = e.parts;
                        if (null == n) return void r.appendChild(t);
                        for (var a = document.createTreeWalker(r, 133, null, !1), o = er(i), s = 0, l = -1; a.nextNode();)
                            for (l++, a.currentNode === n && (s = en(t), n.parentNode.insertBefore(t, n)); - 1 !== o && i[o].index === l;) {
                                if (s > 0) {
                                    for (; - 1 !== o;) i[o].index += s, o = er(i, o);
                                    return
                                }
                                o = er(i, o)
                            }
                    }(n, o, u.firstChild) : u.insertBefore(o, u.firstChild), window.ShadyCSS.prepareTemplateStyles(r, e);
                    var c = u.querySelector("style");
                    if (window.ShadyCSS.nativeShadow && null !== c) t.insertBefore(c.cloneNode(!0), t.firstChild);
                    else if (n) {
                        u.insertBefore(o, u.firstChild);
                        var h = new Set;
                        h.add(o), et(n, h)
                    }
                };
            window.JSCompiler_renameProperty = function(e, t) {
                return e
            };
            var eD = {
                    toAttribute: function(e, t) {
                        switch (t) {
                            case Boolean:
                                return e ? "" : null;
                            case Object:
                            case Array:
                                return null == e ? e : JSON.stringify(e)
                        }
                        return e
                    },
                    fromAttribute: function(e, t) {
                        switch (t) {
                            case Boolean:
                                return null !== e;
                            case Number:
                                return null === e ? null : Number(e);
                            case Object:
                            case Array:
                                return JSON.parse(e)
                        }
                        return e
                    }
                },
                eO = function(e, t) {
                    return t !== e && (t == t || e == e)
                },
                eN = {
                    attribute: !0,
                    type: String,
                    converter: eD,
                    reflect: !1,
                    hasChanged: eO
                },
                eF = function(e) {
                    function t() {
                        var e;
                        return (0, k._)(this, t), (e = (0, E._)(this, t)).initialize(), e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "initialize",
                        value: function() {
                            var e = this;
                            this._updateState = 0, this._updatePromise = new Promise(function(t) {
                                return e._enableUpdatingResolver = t
                            }), this._changedProperties = new Map, this._saveInstanceProperties(), this.requestUpdateInternal()
                        }
                    }, {
                        key: "_saveInstanceProperties",
                        value: function() {
                            var e = this;
                            this.constructor._classProperties.forEach(function(t, n) {
                                if (e.hasOwnProperty(n)) {
                                    var r = e[n];
                                    delete e[n], e._instanceProperties || (e._instanceProperties = new Map), e._instanceProperties.set(n, r)
                                }
                            })
                        }
                    }, {
                        key: "_applyInstanceProperties",
                        value: function() {
                            var e = this;
                            this._instanceProperties.forEach(function(t, n) {
                                return e[n] = t
                            }), this._instanceProperties = void 0
                        }
                    }, {
                        key: "connectedCallback",
                        value: function() {
                            this.enableUpdating()
                        }
                    }, {
                        key: "enableUpdating",
                        value: function() {
                            void 0 !== this._enableUpdatingResolver && (this._enableUpdatingResolver(), this._enableUpdatingResolver = void 0)
                        }
                    }, {
                        key: "disconnectedCallback",
                        value: function() {}
                    }, {
                        key: "attributeChangedCallback",
                        value: function(e, t, n) {
                            t !== n && this._attributeToProperty(e, n)
                        }
                    }, {
                        key: "_propertyToAttribute",
                        value: function(e, t) {
                            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : eN,
                                r = this.constructor,
                                i = r._attributeNameForProperty(e, n);
                            if (void 0 !== i) {
                                var a = r._propertyValueToAttribute(t, n);
                                if (void 0 === a) return;
                                this._updateState = 8 | this._updateState, null == a ? this.removeAttribute(i) : this.setAttribute(i, a), this._updateState = -9 & this._updateState
                            }
                        }
                    }, {
                        key: "_attributeToProperty",
                        value: function(e, t) {
                            if (!(8 & this._updateState)) {
                                var n = this.constructor,
                                    r = n._attributeToPropertyMap.get(e);
                                if (void 0 !== r) {
                                    var i = n.getPropertyOptions(r);
                                    this._updateState = 16 | this._updateState, this[r] = n._propertyValueFromAttribute(t, i), this._updateState = -17 & this._updateState
                                }
                            }
                        }
                    }, {
                        key: "requestUpdateInternal",
                        value: function(e, t, n) {
                            var r = !0;
                            if (void 0 !== e) {
                                var i = this.constructor;
                                n = n || i.getPropertyOptions(e), i._valueHasChanged(this[e], t, n.hasChanged) ? (this._changedProperties.has(e) || this._changedProperties.set(e, t), !0 !== n.reflect || 16 & this._updateState || (void 0 === this._reflectingProperties && (this._reflectingProperties = new Map), this._reflectingProperties.set(e, n))) : r = !1
                            }!this._hasRequestedUpdate && r && (this._updatePromise = this._enqueueUpdate())
                        }
                    }, {
                        key: "requestUpdate",
                        value: function(e, t) {
                            return this.requestUpdateInternal(e, t), this.updateComplete
                        }
                    }, {
                        key: "_enqueueUpdate",
                        value: function() {
                            var e = this;
                            return (0, T._)(function() {
                                var t;
                                return (0, z.YH)(this, function(n) {
                                    switch (n.label) {
                                        case 0:
                                            e._updateState = 4 | e._updateState, n.label = 1;
                                        case 1:
                                            return n.trys.push([1, 3, , 4]), [4, e._updatePromise];
                                        case 2:
                                        case 3:
                                            return n.sent(), [3, 4];
                                        case 4:
                                            if (!(null != (t = e.performUpdate()))) return [3, 6];
                                            return [4, t];
                                        case 5:
                                            n.sent(), n.label = 6;
                                        case 6:
                                            return [2, !e._hasRequestedUpdate]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "_hasRequestedUpdate",
                        get: function() {
                            return 4 & this._updateState
                        }
                    }, {
                        key: "hasUpdated",
                        get: function() {
                            return 1 & this._updateState
                        }
                    }, {
                        key: "performUpdate",
                        value: function() {
                            if (this._hasRequestedUpdate) {
                                this._instanceProperties && this._applyInstanceProperties();
                                var e = !1,
                                    t = this._changedProperties;
                                try {
                                    (e = this.shouldUpdate(t)) ? this.update(t): this._markUpdated()
                                } catch (t) {
                                    throw e = !1, this._markUpdated(), t
                                }
                                e && (1 & this._updateState || (this._updateState = 1 | this._updateState, this.firstUpdated(t)), this.updated(t))
                            }
                        }
                    }, {
                        key: "_markUpdated",
                        value: function() {
                            this._changedProperties = new Map, this._updateState = -5 & this._updateState
                        }
                    }, {
                        key: "updateComplete",
                        get: function() {
                            return this._getUpdateComplete()
                        }
                    }, {
                        key: "_getUpdateComplete",
                        value: function() {
                            return this.getUpdateComplete()
                        }
                    }, {
                        key: "getUpdateComplete",
                        value: function() {
                            return this._updatePromise
                        }
                    }, {
                        key: "shouldUpdate",
                        value: function(e) {
                            return !0
                        }
                    }, {
                        key: "update",
                        value: function(e) {
                            var t = this;
                            void 0 !== this._reflectingProperties && this._reflectingProperties.size > 0 && (this._reflectingProperties.forEach(function(e, n) {
                                return t._propertyToAttribute(n, t[n], e)
                            }), this._reflectingProperties = void 0), this._markUpdated()
                        }
                    }, {
                        key: "updated",
                        value: function(e) {}
                    }, {
                        key: "firstUpdated",
                        value: function(e) {}
                    }], [{
                        key: "observedAttributes",
                        get: function() {
                            var e = this;
                            this.finalize();
                            var t = [];
                            return this._classProperties.forEach(function(n, r) {
                                var i = e._attributeNameForProperty(r, n);
                                void 0 !== i && (e._attributeToPropertyMap.set(i, r), t.push(i))
                            }), t
                        }
                    }, {
                        key: "_ensureClassProperties",
                        value: function() {
                            var e = this;
                            if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) {
                                this._classProperties = new Map;
                                var t = Object.getPrototypeOf(this)._classProperties;
                                void 0 !== t && t.forEach(function(t, n) {
                                    return e._classProperties.set(n, t)
                                })
                            }
                        }
                    }, {
                        key: "createProperty",
                        value: function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : eN;
                            if (this._ensureClassProperties(), this._classProperties.set(e, t), !(t.noAccessor || this.prototype.hasOwnProperty(e))) {
                                var n = "symbol" == (void 0 === e ? "undefined" : (0, U._)(e)) ? Symbol() : "__".concat(e),
                                    r = this.getPropertyDescriptor(e, n, t);
                                void 0 !== r && Object.defineProperty(this.prototype, e, r)
                            }
                        }
                    }, {
                        key: "getPropertyDescriptor",
                        value: function(e, t, n) {
                            return {
                                get: function() {
                                    return this[t]
                                },
                                set: function(r) {
                                    var i = this[e];
                                    this[t] = r, this.requestUpdateInternal(e, i, n)
                                },
                                configurable: !0,
                                enumerable: !0
                            }
                        }
                    }, {
                        key: "getPropertyOptions",
                        value: function(e) {
                            return this._classProperties && this._classProperties.get(e) || eN
                        }
                    }, {
                        key: "finalize",
                        value: function() {
                            var e = Object.getPrototypeOf(this);
                            if (e.hasOwnProperty("finalized") || e.finalize(), this.finalized = !0, this._ensureClassProperties(), this._attributeToPropertyMap = new Map, this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
                                var t = this.properties,
                                    n = (0, F._)(Object.getOwnPropertyNames(t)).concat((0, F._)("function" == typeof Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(t) : [])),
                                    r = !0,
                                    i = !1,
                                    a = void 0;
                                try {
                                    for (var o, s = n[Symbol.iterator](); !(r = (o = s.next()).done); r = !0) {
                                        var l = o.value;
                                        this.createProperty(l, t[l])
                                    }
                                } catch (e) {
                                    i = !0, a = e
                                } finally {
                                    try {
                                        r || null == s.return || s.return()
                                    } finally {
                                        if (i) throw a
                                    }
                                }
                            }
                        }
                    }, {
                        key: "_attributeNameForProperty",
                        value: function(e, t) {
                            var n = t.attribute;
                            return !1 === n ? void 0 : "string" == typeof n ? n : "string" == typeof e ? e.toLowerCase() : void 0
                        }
                    }, {
                        key: "_valueHasChanged",
                        value: function(e, t) {
                            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : eO;
                            return n(e, t)
                        }
                    }, {
                        key: "_propertyValueFromAttribute",
                        value: function(e, t) {
                            var n = t.type,
                                r = t.converter || eD,
                                i = "function" == typeof r ? r : r.fromAttribute;
                            return i ? i(e, n) : e
                        }
                    }, {
                        key: "_propertyValueToAttribute",
                        value: function(e, t) {
                            if (void 0 !== t.reflect) {
                                var n = t.type,
                                    r = t.converter;
                                return (r && r.toAttribute || eD.toAttribute)(e, n)
                            }
                        }
                    }]), t
                }((0, B._)(HTMLElement));

            function eU(e) {
                return function(t, n) {
                    return void 0 !== n ? function(e, t, n) {
                        t.constructor.createProperty(n, e)
                    }(e, t, n) : "method" !== t.kind || !t.descriptor || "value" in t.descriptor ? {
                        kind: "field",
                        key: Symbol(),
                        placement: "own",
                        descriptor: {},
                        initializer: function() {
                            "function" == typeof t.initializer && (this[t.key] = t.initializer.call(this))
                        },
                        finisher: function(n) {
                            n.createProperty(t.key, e)
                        }
                    } : Object.assign(Object.assign({}, t), {
                        finisher: function(n) {
                            n.createProperty(t.key, e)
                        }
                    })
                }
            }
            eF.finalized = !0;
            var eB = window.ShadowRoot && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype,
                ez = Symbol(),
                eH = function() {
                    function e(t, n) {
                        if ((0, k._)(this, e), n !== ez) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
                        this.cssText = t
                    }
                    return (0, A._)(e, [{
                        key: "styleSheet",
                        get: function() {
                            return void 0 === this._styleSheet && (eB ? (this._styleSheet = new CSSStyleSheet, this._styleSheet.replaceSync(this.cssText)) : this._styleSheet = null), this._styleSheet
                        }
                    }, {
                        key: "toString",
                        value: function() {
                            return this.cssText
                        }
                    }]), e
                }();
            (window.litElementVersions || (window.litElementVersions = [])).push("2.5.1");
            var eV = {},
                eG = function(e) {
                    function t() {
                        return (0, k._)(this, t), (0, E._)(this, t, arguments)
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "initialize",
                        value: function() {
                            L((0, C._)(t.prototype), "initialize", this).call(this), this.constructor._getUniqueStyles(), this.renderRoot = this.createRenderRoot(), window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot && this.adoptStyles()
                        }
                    }, {
                        key: "createRenderRoot",
                        value: function() {
                            return this.attachShadow(this.constructor.shadowRootOptions)
                        }
                    }, {
                        key: "adoptStyles",
                        value: function() {
                            var e = this.constructor._styles;
                            0 !== e.length && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow ? eB ? this.renderRoot.adoptedStyleSheets = e.map(function(e) {
                                return e instanceof CSSStyleSheet ? e : e.styleSheet
                            }) : this._needsShimAdoptedStyleSheets = !0 : window.ShadyCSS.ScopingShim.prepareAdoptedCssText(e.map(function(e) {
                                return e.cssText
                            }), this.localName))
                        }
                    }, {
                        key: "connectedCallback",
                        value: function() {
                            L((0, C._)(t.prototype), "connectedCallback", this).call(this), this.hasUpdated && void 0 !== window.ShadyCSS && window.ShadyCSS.styleElement(this)
                        }
                    }, {
                        key: "update",
                        value: function(e) {
                            var n = this,
                                r = this.render();
                            L((0, C._)(t.prototype), "update", this).call(this, e), r !== eV && this.constructor.render(r, this.renderRoot, {
                                scopeName: this.localName,
                                eventContext: this
                            }), this._needsShimAdoptedStyleSheets && (this._needsShimAdoptedStyleSheets = !1, this.constructor._styles.forEach(function(e) {
                                var t = document.createElement("style");
                                t.textContent = e.cssText, n.renderRoot.appendChild(t)
                            }))
                        }
                    }, {
                        key: "render",
                        value: function() {
                            return eV
                        }
                    }], [{
                        key: "getStyles",
                        value: function() {
                            return this.styles
                        }
                    }, {
                        key: "_getUniqueStyles",
                        value: function() {
                            if (!this.hasOwnProperty(JSCompiler_renameProperty("_styles", this))) {
                                var e = this.getStyles();
                                if (Array.isArray(e)) {
                                    var t = function(e, n) {
                                            return e.reduceRight(function(e, n) {
                                                return Array.isArray(n) ? t(n, e) : (e.add(n), e)
                                            }, n)
                                        },
                                        n = t(e, new Set),
                                        r = [];
                                    n.forEach(function(e) {
                                        return r.unshift(e)
                                    }), this._styles = r
                                } else this._styles = void 0 === e ? [] : [e];
                                this._styles = this._styles.map(function(e) {
                                    return e instanceof CSSStyleSheet && !eB ? new eH(String(Array.prototype.slice.call(e.cssRules).reduce(function(e, t) {
                                        return e + t.cssText
                                    }, "")), ez) : e
                                })
                            }
                        }
                    }]), t
                }(eF);
            eG.finalized = !0, eG.render = function(e, t, n) {
                if (!n || "object" != (void 0 === n ? "undefined" : (0, U._)(n)) || !n.scopeName) throw Error("The `scopeName` option is required.");
                var r = n.scopeName,
                    i = eT.has(t),
                    a = eC && 11 === t.nodeType && !!t.host,
                    o = a && !eP.has(r),
                    s = o ? document.createDocumentFragment() : t;
                if (eE(e, s, Object.assign({
                        templateFactory: function(e) {
                            var t = eR(e.type, r),
                                n = eS.get(t);
                            void 0 === n && (n = {
                                stringsArray: new WeakMap,
                                keyString: new Map
                            }, eS.set(t, n));
                            var i = n.stringsArray.get(e.strings);
                            if (void 0 !== i) return i;
                            var a = e.strings.join(X);
                            if (void 0 === (i = n.keyString.get(a))) {
                                var o = e.getTemplateElement();
                                eC && window.ShadyCSS.prepareTemplateDom(o, r), i = new Z(e, o), n.keyString.set(a, i)
                            }
                            return n.stringsArray.set(e.strings, i), i
                        }
                    }, n)), o) {
                    var l = eT.get(s);
                    eT.delete(s), eI(r, s, l.value instanceof el ? l.value.template : void 0), q(t, t.firstChild), t.appendChild(s), eT.set(t, l)
                }!i && a && window.ShadyCSS.styleElement(t.host)
            }, eG.shadowRootOptions = {
                mode: "open"
            };
            for (var eW = function() {
                    function e() {
                        (0, k._)(this, e)
                    }
                    return (0, A._)(e, [{
                        key: "addEventListener",
                        value: function(e, t) {
                            void 0 === this._listeners && (this._listeners = {});
                            var n = this._listeners;
                            void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
                        }
                    }, {
                        key: "hasEventListener",
                        value: function(e, t) {
                            if (void 0 === this._listeners) return !1;
                            var n = this._listeners;
                            return void 0 !== n[e] && -1 !== n[e].indexOf(t)
                        }
                    }, {
                        key: "removeEventListener",
                        value: function(e, t) {
                            if (void 0 !== this._listeners) {
                                var n = this._listeners[e];
                                if (void 0 !== n) {
                                    var r = n.indexOf(t); - 1 !== r && n.splice(r, 1)
                                }
                            }
                        }
                    }, {
                        key: "dispatchEvent",
                        value: function(e) {
                            if (void 0 !== this._listeners) {
                                var t = this._listeners[e.type];
                                if (void 0 !== t) {
                                    e.target = this;
                                    for (var n = t.slice(0), r = 0, i = n.length; r < i; r++) n[r].call(this, e);
                                    e.target = null
                                }
                            }
                        }
                    }]), e
                }(), ej = [], eq = 0; eq < 256; eq++) ej[eq] = (eq < 16 ? "0" : "") + eq.toString(16);
            var eX = 1234567,
                eY = Math.PI / 180,
                eJ = 180 / Math.PI;

            function eZ() {
                var e = 0xffffffff * Math.random() | 0,
                    t = 0xffffffff * Math.random() | 0,
                    n = 0xffffffff * Math.random() | 0,
                    r = 0xffffffff * Math.random() | 0;
                return (ej[255 & e] + ej[e >> 8 & 255] + ej[e >> 16 & 255] + ej[e >> 24 & 255] + "-" + ej[255 & t] + ej[t >> 8 & 255] + "-" + ej[t >> 16 & 15 | 64] + ej[t >> 24 & 255] + "-" + ej[63 & n | 128] + ej[n >> 8 & 255] + "-" + ej[n >> 16 & 255] + ej[n >> 24 & 255] + ej[255 & r] + ej[r >> 8 & 255] + ej[r >> 16 & 255] + ej[r >> 24 & 255]).toUpperCase()
            }

            function eK(e, t, n) {
                return Math.max(t, Math.min(n, e))
            }

            function eQ(e, t) {
                return (e % t + t) % t
            }

            function e$(e, t, n) {
                return (1 - n) * e + n * t
            }

            function e0(e) {
                return 0 == (e & e - 1) && 0 !== e
            }

            function e1(e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            }

            function e2(e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            }
            var e3 = Object.freeze({
                    __proto__: null,
                    DEG2RAD: eY,
                    RAD2DEG: eJ,
                    generateUUID: eZ,
                    clamp: eK,
                    euclideanModulo: eQ,
                    mapLinear: function(e, t, n, r, i) {
                        return r + (e - t) * (i - r) / (n - t)
                    },
                    inverseLerp: function(e, t, n) {
                        return e !== t ? (n - e) / (t - e) : 0
                    },
                    lerp: e$,
                    damp: function(e, t, n, r) {
                        return e$(e, t, 1 - Math.exp(-n * r))
                    },
                    pingpong: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                        return t - Math.abs(eQ(e, 2 * t) - t)
                    },
                    smoothstep: function(e, t, n) {
                        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
                    },
                    smootherstep: function(e, t, n) {
                        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
                    },
                    randInt: function(e, t) {
                        return e + Math.floor(Math.random() * (t - e + 1))
                    },
                    randFloat: function(e, t) {
                        return e + Math.random() * (t - e)
                    },
                    randFloatSpread: function(e) {
                        return e * (.5 - Math.random())
                    },
                    seededRandom: function(e) {
                        return void 0 !== e && (eX = e % 0x7fffffff), ((eX = 16807 * eX % 0x7fffffff) - 1) / 0x7ffffffe
                    },
                    degToRad: function(e) {
                        return e * eY
                    },
                    radToDeg: function(e) {
                        return e * eJ
                    },
                    isPowerOfTwo: e0,
                    ceilPowerOfTwo: e1,
                    floorPowerOfTwo: e2,
                    setQuaternionFromProperEuler: function(e, t, n, r, i) {
                        var a = Math.cos,
                            o = Math.sin,
                            s = a(n / 2),
                            l = o(n / 2),
                            u = a((t + r) / 2),
                            c = o((t + r) / 2),
                            h = a((t - r) / 2),
                            d = o((t - r) / 2),
                            f = a((r - t) / 2),
                            p = o((r - t) / 2);
                        switch (i) {
                            case "XYX":
                                e.set(s * c, l * h, l * d, s * u);
                                break;
                            case "YZY":
                                e.set(l * d, s * c, l * h, s * u);
                                break;
                            case "ZXZ":
                                e.set(l * h, l * d, s * c, s * u);
                                break;
                            case "XZX":
                                e.set(s * c, l * p, l * f, s * u);
                                break;
                            case "YXY":
                                e.set(l * f, s * c, l * p, s * u);
                                break;
                            case "ZYZ":
                                e.set(l * p, l * f, s * c, s * u);
                                break;
                            default:
                                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                        }
                    }
                }),
                e4 = function() {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        (0, k._)(this, e), this.x = t, this.y = n
                    }
                    return (0, A._)(e, [{
                        key: "width",
                        get: function() {
                            return this.x
                        },
                        set: function(e) {
                            this.x = e
                        }
                    }, {
                        key: "height",
                        get: function() {
                            return this.y
                        },
                        set: function(e) {
                            this.y = e
                        }
                    }, {
                        key: "set",
                        value: function(e, t) {
                            return this.x = e, this.y = t, this
                        }
                    }, {
                        key: "setScalar",
                        value: function(e) {
                            return this.x = e, this.y = e, this
                        }
                    }, {
                        key: "setX",
                        value: function(e) {
                            return this.x = e, this
                        }
                    }, {
                        key: "setY",
                        value: function(e) {
                            return this.y = e, this
                        }
                    }, {
                        key: "setComponent",
                        value: function(e, t) {
                            switch (e) {
                                case 0:
                                    this.x = t;
                                    break;
                                case 1:
                                    this.y = t;
                                    break;
                                default:
                                    throw Error("index is out of range: " + e)
                            }
                            return this
                        }
                    }, {
                        key: "getComponent",
                        value: function(e) {
                            switch (e) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                default:
                                    throw Error("index is out of range: " + e)
                            }
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return new this.constructor(this.x, this.y)
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return this.x = e.x, this.y = e.y, this
                        }
                    }, {
                        key: "add",
                        value: function(e, t) {
                            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
                        }
                    }, {
                        key: "addScalar",
                        value: function(e) {
                            return this.x += e, this.y += e, this
                        }
                    }, {
                        key: "addVectors",
                        value: function(e, t) {
                            return this.x = e.x + t.x, this.y = e.y + t.y, this
                        }
                    }, {
                        key: "addScaledVector",
                        value: function(e, t) {
                            return this.x += e.x * t, this.y += e.y * t, this
                        }
                    }, {
                        key: "sub",
                        value: function(e, t) {
                            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
                        }
                    }, {
                        key: "subScalar",
                        value: function(e) {
                            return this.x -= e, this.y -= e, this
                        }
                    }, {
                        key: "subVectors",
                        value: function(e, t) {
                            return this.x = e.x - t.x, this.y = e.y - t.y, this
                        }
                    }, {
                        key: "multiply",
                        value: function(e) {
                            return this.x *= e.x, this.y *= e.y, this
                        }
                    }, {
                        key: "multiplyScalar",
                        value: function(e) {
                            return this.x *= e, this.y *= e, this
                        }
                    }, {
                        key: "divide",
                        value: function(e) {
                            return this.x /= e.x, this.y /= e.y, this
                        }
                    }, {
                        key: "divideScalar",
                        value: function(e) {
                            return this.multiplyScalar(1 / e)
                        }
                    }, {
                        key: "applyMatrix3",
                        value: function(e) {
                            var t = this.x,
                                n = this.y,
                                r = e.elements;
                            return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this
                        }
                    }, {
                        key: "min",
                        value: function(e) {
                            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                        }
                    }, {
                        key: "max",
                        value: function(e) {
                            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                        }
                    }, {
                        key: "clamp",
                        value: function(e, t) {
                            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                        }
                    }, {
                        key: "clampScalar",
                        value: function(e, t) {
                            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
                        }
                    }, {
                        key: "clampLength",
                        value: function(e, t) {
                            var n = this.length();
                            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                        }
                    }, {
                        key: "floor",
                        value: function() {
                            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                        }
                    }, {
                        key: "ceil",
                        value: function() {
                            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                        }
                    }, {
                        key: "round",
                        value: function() {
                            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                        }
                    }, {
                        key: "roundToZero",
                        value: function() {
                            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                        }
                    }, {
                        key: "negate",
                        value: function() {
                            return this.x = -this.x, this.y = -this.y, this
                        }
                    }, {
                        key: "dot",
                        value: function(e) {
                            return this.x * e.x + this.y * e.y
                        }
                    }, {
                        key: "cross",
                        value: function(e) {
                            return this.x * e.y - this.y * e.x
                        }
                    }, {
                        key: "lengthSq",
                        value: function() {
                            return this.x * this.x + this.y * this.y
                        }
                    }, {
                        key: "length",
                        value: function() {
                            return Math.sqrt(this.x * this.x + this.y * this.y)
                        }
                    }, {
                        key: "manhattanLength",
                        value: function() {
                            return Math.abs(this.x) + Math.abs(this.y)
                        }
                    }, {
                        key: "normalize",
                        value: function() {
                            return this.divideScalar(this.length() || 1)
                        }
                    }, {
                        key: "angle",
                        value: function() {
                            return Math.atan2(-this.y, -this.x) + Math.PI
                        }
                    }, {
                        key: "distanceTo",
                        value: function(e) {
                            return Math.sqrt(this.distanceToSquared(e))
                        }
                    }, {
                        key: "distanceToSquared",
                        value: function(e) {
                            var t = this.x - e.x,
                                n = this.y - e.y;
                            return t * t + n * n
                        }
                    }, {
                        key: "manhattanDistanceTo",
                        value: function(e) {
                            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                        }
                    }, {
                        key: "setLength",
                        value: function(e) {
                            return this.normalize().multiplyScalar(e)
                        }
                    }, {
                        key: "lerp",
                        value: function(e, t) {
                            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                        }
                    }, {
                        key: "lerpVectors",
                        value: function(e, t, n) {
                            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
                        }
                    }, {
                        key: "equals",
                        value: function(e) {
                            return e.x === this.x && e.y === this.y
                        }
                    }, {
                        key: "fromArray",
                        value: function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return this.x = e[t], this.y = e[t + 1], this
                        }
                    }, {
                        key: "toArray",
                        value: function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return e[t] = this.x, e[t + 1] = this.y, e
                        }
                    }, {
                        key: "fromBufferAttribute",
                        value: function(e, t, n) {
                            return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
                        }
                    }, {
                        key: "rotateAround",
                        value: function(e, t) {
                            var n = Math.cos(t),
                                r = Math.sin(t),
                                i = this.x - e.x,
                                a = this.y - e.y;
                            return this.x = i * n - a * r + e.x, this.y = i * r + a * n + e.y, this
                        }
                    }, {
                        key: "random",
                        value: function() {
                            return this.x = Math.random(), this.y = Math.random(), this
                        }
                    }, {
                        key: Symbol.iterator,
                        value: function() {
                            return (0, z.YH)(this, function(e) {
                                switch (e.label) {
                                    case 0:
                                        return [4, this.x];
                                    case 1:
                                        return e.sent(), [4, this.y];
                                    case 2:
                                        return e.sent(), [2]
                                }
                            })
                        }
                    }]), e
                }();
            e4.prototype.isVector2 = !0;
            var e5 = function() {
                function e() {
                    (0, k._)(this, e), this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                }
                return (0, A._)(e, [{
                    key: "set",
                    value: function(e, t, n, r, i, a, o, s, l) {
                        var u = this.elements;
                        return u[0] = e, u[1] = r, u[2] = o, u[3] = t, u[4] = i, u[5] = s, u[6] = n, u[7] = a, u[8] = l, this
                    }
                }, {
                    key: "identity",
                    value: function() {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        var t = this.elements,
                            n = e.elements;
                        return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
                    }
                }, {
                    key: "extractBasis",
                    value: function(e, t, n) {
                        return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
                    }
                }, {
                    key: "setFromMatrix4",
                    value: function(e) {
                        var t = e.elements;
                        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
                    }
                }, {
                    key: "multiply",
                    value: function(e) {
                        return this.multiplyMatrices(this, e)
                    }
                }, {
                    key: "premultiply",
                    value: function(e) {
                        return this.multiplyMatrices(e, this)
                    }
                }, {
                    key: "multiplyMatrices",
                    value: function(e, t) {
                        var n = e.elements,
                            r = t.elements,
                            i = this.elements,
                            a = n[0],
                            o = n[3],
                            s = n[6],
                            l = n[1],
                            u = n[4],
                            c = n[7],
                            h = n[2],
                            d = n[5],
                            f = n[8],
                            p = r[0],
                            m = r[3],
                            v = r[6],
                            g = r[1],
                            y = r[4],
                            _ = r[7],
                            x = r[2],
                            b = r[5],
                            w = r[8];
                        return i[0] = a * p + o * g + s * x, i[3] = a * m + o * y + s * b, i[6] = a * v + o * _ + s * w, i[1] = l * p + u * g + c * x, i[4] = l * m + u * y + c * b, i[7] = l * v + u * _ + c * w, i[2] = h * p + d * g + f * x, i[5] = h * m + d * y + f * b, i[8] = h * v + d * _ + f * w, this
                    }
                }, {
                    key: "multiplyScalar",
                    value: function(e) {
                        var t = this.elements;
                        return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                    }
                }, {
                    key: "determinant",
                    value: function() {
                        var e = this.elements,
                            t = e[0],
                            n = e[1],
                            r = e[2],
                            i = e[3],
                            a = e[4],
                            o = e[5],
                            s = e[6],
                            l = e[7],
                            u = e[8];
                        return t * a * u - t * o * l - n * i * u + n * o * s + r * i * l - r * a * s
                    }
                }, {
                    key: "invert",
                    value: function() {
                        var e = this.elements,
                            t = e[0],
                            n = e[1],
                            r = e[2],
                            i = e[3],
                            a = e[4],
                            o = e[5],
                            s = e[6],
                            l = e[7],
                            u = e[8],
                            c = u * a - o * l,
                            h = o * s - u * i,
                            d = l * i - a * s,
                            f = t * c + n * h + r * d;
                        if (0 === f) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        var p = 1 / f;
                        return e[0] = c * p, e[1] = (r * l - u * n) * p, e[2] = (o * n - r * a) * p, e[3] = h * p, e[4] = (u * t - r * s) * p, e[5] = (r * i - o * t) * p, e[6] = d * p, e[7] = (n * s - l * t) * p, e[8] = (a * t - n * i) * p, this
                    }
                }, {
                    key: "transpose",
                    value: function() {
                        var e, t = this.elements;
                        return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                    }
                }, {
                    key: "getNormalMatrix",
                    value: function(e) {
                        return this.setFromMatrix4(e).invert().transpose()
                    }
                }, {
                    key: "transposeIntoArray",
                    value: function(e) {
                        var t = this.elements;
                        return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                    }
                }, {
                    key: "setUvTransform",
                    value: function(e, t, n, r, i, a, o) {
                        var s = Math.cos(i),
                            l = Math.sin(i);
                        return this.set(n * s, n * l, -n * (s * a + l * o) + a + e, -r * l, r * s, -r * (-l * a + s * o) + o + t, 0, 0, 1), this
                    }
                }, {
                    key: "scale",
                    value: function(e, t) {
                        var n = this.elements;
                        return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
                    }
                }, {
                    key: "rotate",
                    value: function(e) {
                        var t = Math.cos(e),
                            n = Math.sin(e),
                            r = this.elements,
                            i = r[0],
                            a = r[3],
                            o = r[6],
                            s = r[1],
                            l = r[4],
                            u = r[7];
                        return r[0] = t * i + n * s, r[3] = t * a + n * l, r[6] = t * o + n * u, r[1] = -n * i + t * s, r[4] = -n * a + t * l, r[7] = -n * o + t * u, this
                    }
                }, {
                    key: "translate",
                    value: function(e, t) {
                        var n = this.elements;
                        return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
                    }
                }, {
                    key: "equals",
                    value: function(e) {
                        for (var t = this.elements, n = e.elements, r = 0; r < 9; r++)
                            if (t[r] !== n[r]) return !1;
                        return !0
                    }
                }, {
                    key: "fromArray",
                    value: function(e) {
                        for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = 0; n < 9; n++) this.elements[n] = e[n + t];
                        return this
                    }
                }, {
                    key: "toArray",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = this.elements;
                        return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return (new this.constructor).fromArray(this.elements)
                    }
                }]), e
            }();

            function e6(e) {
                if (0 === e.length) return -1 / 0;
                for (var t = e[0], n = 1, r = e.length; n < r; ++n) e[n] > t && (t = e[n]);
                return t
            }

            function e8(e) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", e)
            }
            e5.prototype.isMatrix3 = !0;
            var e7 = function() {
                    function e() {
                        (0, k._)(this, e)
                    }
                    return (0, A._)(e, null, [{
                        key: "getDataURL",
                        value: function(e) {
                            if (/^data:/i.test(e.src) || "undefined" == typeof HTMLCanvasElement) return e.src;
                            if (e instanceof HTMLCanvasElement) t = e;
                            else {
                                void 0 === cS && (cS = e8("canvas")), cS.width = e.width, cS.height = e.height;
                                var t, n = cS.getContext("2d");
                                e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = cS
                            }
                            return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
                        }
                    }]), e
                }(),
                e9 = 0,
                te = function(e) {
                    function t() {
                        var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : t.DEFAULT_IMAGE,
                            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t.DEFAULT_MAPPING,
                            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1001,
                            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1001,
                            o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1006,
                            s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1008,
                            l = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1023,
                            u = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 1009,
                            c = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1,
                            h = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 3e3;
                        return (0, k._)(this, t), Object.defineProperty(e = (0, E._)(this, t), "id", {
                            value: e9++
                        }), e.uuid = eZ(), e.name = "", e.image = n, e.mipmaps = [], e.mapping = r, e.wrapS = i, e.wrapT = a, e.magFilter = o, e.minFilter = s, e.anisotropy = c, e.format = l, e.internalFormat = null, e.type = u, e.offset = new e4(0, 0), e.repeat = new e4(1, 1), e.center = new e4(0, 0), e.rotation = 0, e.matrixAutoUpdate = !0, e.matrix = new e5, e.generateMipmaps = !0, e.premultiplyAlpha = !1, e.flipY = !0, e.unpackAlignment = 4, e.encoding = h, e.userData = {}, e.version = 0, e.onUpdate = null, e.isRenderTargetTexture = !1, e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "updateMatrix",
                        value: function() {
                            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return (new this.constructor).copy(this)
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this
                        }
                    }, {
                        key: "toJSON",
                        value: function(e) {
                            var t = void 0 === e || "string" == typeof e;
                            if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                            var n = {
                                metadata: {
                                    version: 4.5,
                                    type: "Texture",
                                    generator: "Texture.toJSON"
                                },
                                uuid: this.uuid,
                                name: this.name,
                                mapping: this.mapping,
                                repeat: [this.repeat.x, this.repeat.y],
                                offset: [this.offset.x, this.offset.y],
                                center: [this.center.x, this.center.y],
                                rotation: this.rotation,
                                wrap: [this.wrapS, this.wrapT],
                                format: this.format,
                                type: this.type,
                                encoding: this.encoding,
                                minFilter: this.minFilter,
                                magFilter: this.magFilter,
                                anisotropy: this.anisotropy,
                                flipY: this.flipY,
                                premultiplyAlpha: this.premultiplyAlpha,
                                unpackAlignment: this.unpackAlignment
                            };
                            if (void 0 !== this.image) {
                                var r, i = this.image;
                                if (void 0 === i.uuid && (i.uuid = eZ()), !t && void 0 === e.images[i.uuid]) {
                                    if (Array.isArray(i)) {
                                        r = [];
                                        for (var a = 0, o = i.length; a < o; a++) i[a].isDataTexture ? r.push(tt(i[a].image)) : r.push(tt(i[a]))
                                    } else r = tt(i);
                                    e.images[i.uuid] = {
                                        uuid: i.uuid,
                                        url: r
                                    }
                                }
                                n.image = i.uuid
                            }
                            return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                    }, {
                        key: "transformUv",
                        value: function(e) {
                            if (300 !== this.mapping) return e;
                            if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                                case 1e3:
                                    e.x = e.x - Math.floor(e.x);
                                    break;
                                case 1001:
                                    e.x = e.x < 0 ? 0 : 1;
                                    break;
                                case 1002:
                                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                            }
                            if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                                case 1e3:
                                    e.y = e.y - Math.floor(e.y);
                                    break;
                                case 1001:
                                    e.y = e.y < 0 ? 0 : 1;
                                    break;
                                case 1002:
                                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                            }
                            return this.flipY && (e.y = 1 - e.y), e
                        }
                    }, {
                        key: "needsUpdate",
                        set: function(e) {
                            !0 === e && this.version++
                        }
                    }]), t
                }(eW);

            function tt(e) {
                return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? e7.getDataURL(e) : e.data ? {
                    data: Array.prototype.slice.call(e.data),
                    width: e.width,
                    height: e.height,
                    type: e.data.constructor.name
                } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
            }
            te.DEFAULT_IMAGE = void 0, te.DEFAULT_MAPPING = 300, te.prototype.isTexture = !0;
            var tn = function() {
                function e() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                        n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                        i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                    (0, k._)(this, e), this.x = t, this.y = n, this.z = r, this.w = i
                }
                return (0, A._)(e, [{
                    key: "width",
                    get: function() {
                        return this.z
                    },
                    set: function(e) {
                        this.z = e
                    }
                }, {
                    key: "height",
                    get: function() {
                        return this.w
                    },
                    set: function(e) {
                        this.w = e
                    }
                }, {
                    key: "set",
                    value: function(e, t, n, r) {
                        return this.x = e, this.y = t, this.z = n, this.w = r, this
                    }
                }, {
                    key: "setScalar",
                    value: function(e) {
                        return this.x = e, this.y = e, this.z = e, this.w = e, this
                    }
                }, {
                    key: "setX",
                    value: function(e) {
                        return this.x = e, this
                    }
                }, {
                    key: "setY",
                    value: function(e) {
                        return this.y = e, this
                    }
                }, {
                    key: "setZ",
                    value: function(e) {
                        return this.z = e, this
                    }
                }, {
                    key: "setW",
                    value: function(e) {
                        return this.w = e, this
                    }
                }, {
                    key: "setComponent",
                    value: function(e, t) {
                        switch (e) {
                            case 0:
                                this.x = t;
                                break;
                            case 1:
                                this.y = t;
                                break;
                            case 2:
                                this.z = t;
                                break;
                            case 3:
                                this.w = t;
                                break;
                            default:
                                throw Error("index is out of range: " + e)
                        }
                        return this
                    }
                }, {
                    key: "getComponent",
                    value: function(e) {
                        switch (e) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                throw Error("index is out of range: " + e)
                        }
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return new this.constructor(this.x, this.y, this.z, this.w)
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                    }
                }, {
                    key: "add",
                    value: function(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
                    }
                }, {
                    key: "addScalar",
                    value: function(e) {
                        return this.x += e, this.y += e, this.z += e, this.w += e, this
                    }
                }, {
                    key: "addVectors",
                    value: function(e, t) {
                        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                    }
                }, {
                    key: "addScaledVector",
                    value: function(e, t) {
                        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
                    }
                }, {
                    key: "sub",
                    value: function(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
                    }
                }, {
                    key: "subScalar",
                    value: function(e) {
                        return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                    }
                }, {
                    key: "subVectors",
                    value: function(e, t) {
                        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                    }
                }, {
                    key: "multiply",
                    value: function(e) {
                        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
                    }
                }, {
                    key: "multiplyScalar",
                    value: function(e) {
                        return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                    }
                }, {
                    key: "applyMatrix4",
                    value: function(e) {
                        var t = this.x,
                            n = this.y,
                            r = this.z,
                            i = this.w,
                            a = e.elements;
                        return this.x = a[0] * t + a[4] * n + a[8] * r + a[12] * i, this.y = a[1] * t + a[5] * n + a[9] * r + a[13] * i, this.z = a[2] * t + a[6] * n + a[10] * r + a[14] * i, this.w = a[3] * t + a[7] * n + a[11] * r + a[15] * i, this
                    }
                }, {
                    key: "divideScalar",
                    value: function(e) {
                        return this.multiplyScalar(1 / e)
                    }
                }, {
                    key: "setAxisAngleFromQuaternion",
                    value: function(e) {
                        this.w = 2 * Math.acos(e.w);
                        var t = Math.sqrt(1 - e.w * e.w);
                        return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                    }
                }, {
                    key: "setAxisAngleFromRotationMatrix",
                    value: function(e) {
                        var t, n, r, i, a = e.elements,
                            o = a[0],
                            s = a[4],
                            l = a[8],
                            u = a[1],
                            c = a[5],
                            h = a[9],
                            d = a[2],
                            f = a[6],
                            p = a[10];
                        if (.01 > Math.abs(s - u) && .01 > Math.abs(l - d) && .01 > Math.abs(h - f)) {
                            if (.1 > Math.abs(s + u) && .1 > Math.abs(l + d) && .1 > Math.abs(h + f) && .1 > Math.abs(o + c + p - 3)) return this.set(1, 0, 0, 0), this;
                            t = Math.PI;
                            var m = (o + 1) / 2,
                                v = (c + 1) / 2,
                                g = (p + 1) / 2,
                                y = (s + u) / 4,
                                _ = (l + d) / 4,
                                x = (h + f) / 4;
                            return m > v && m > g ? m < .01 ? (n = 0, r = .707106781, i = .707106781) : (r = y / (n = Math.sqrt(m)), i = _ / n) : v > g ? v < .01 ? (n = .707106781, r = 0, i = .707106781) : (n = y / (r = Math.sqrt(v)), i = x / r) : g < .01 ? (n = .707106781, r = .707106781, i = 0) : (n = _ / (i = Math.sqrt(g)), r = x / i), this.set(n, r, i, t), this
                        }
                        var b = Math.sqrt((f - h) * (f - h) + (l - d) * (l - d) + (u - s) * (u - s));
                        return .001 > Math.abs(b) && (b = 1), this.x = (f - h) / b, this.y = (l - d) / b, this.z = (u - s) / b, this.w = Math.acos((o + c + p - 1) / 2), this
                    }
                }, {
                    key: "min",
                    value: function(e) {
                        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                    }
                }, {
                    key: "max",
                    value: function(e) {
                        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                    }
                }, {
                    key: "clamp",
                    value: function(e, t) {
                        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
                    }
                }, {
                    key: "clampScalar",
                    value: function(e, t) {
                        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
                    }
                }, {
                    key: "clampLength",
                    value: function(e, t) {
                        var n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                    }
                }, {
                    key: "floor",
                    value: function() {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                    }
                }, {
                    key: "ceil",
                    value: function() {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                    }
                }, {
                    key: "round",
                    value: function() {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                    }
                }, {
                    key: "roundToZero",
                    value: function() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                    }
                }, {
                    key: "negate",
                    value: function() {
                        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                    }
                }, {
                    key: "dot",
                    value: function(e) {
                        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                    }
                }, {
                    key: "lengthSq",
                    value: function() {
                        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                    }
                }, {
                    key: "length",
                    value: function() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                    }
                }, {
                    key: "manhattanLength",
                    value: function() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                    }
                }, {
                    key: "normalize",
                    value: function() {
                        return this.divideScalar(this.length() || 1)
                    }
                }, {
                    key: "setLength",
                    value: function(e) {
                        return this.normalize().multiplyScalar(e)
                    }
                }, {
                    key: "lerp",
                    value: function(e, t) {
                        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                    }
                }, {
                    key: "lerpVectors",
                    value: function(e, t, n) {
                        return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
                    }
                }, {
                    key: "equals",
                    value: function(e) {
                        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                    }
                }, {
                    key: "fromArray",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                    }
                }, {
                    key: "toArray",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                    }
                }, {
                    key: "fromBufferAttribute",
                    value: function(e, t, n) {
                        return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
                    }
                }, {
                    key: "random",
                    value: function() {
                        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                    }
                }, {
                    key: Symbol.iterator,
                    value: function() {
                        return (0, z.YH)(this, function(e) {
                            switch (e.label) {
                                case 0:
                                    return [4, this.x];
                                case 1:
                                    return e.sent(), [4, this.y];
                                case 2:
                                    return e.sent(), [4, this.z];
                                case 3:
                                    return e.sent(), [4, this.w];
                                case 4:
                                    return e.sent(), [2]
                            }
                        })
                    }
                }]), e
            }();
            tn.prototype.isVector4 = !0;
            var tr = function(e) {
                function t(e, n) {
                    var r, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    return (0, k._)(this, t), (r = (0, E._)(this, t)).width = e, r.height = n, r.depth = 1, r.scissor = new tn(0, 0, e, n), r.scissorTest = !1, r.viewport = new tn(0, 0, e, n), r.texture = new te(void 0, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), r.texture.isRenderTargetTexture = !0, r.texture.image = {
                        width: e,
                        height: n,
                        depth: 1
                    }, r.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, r.texture.internalFormat = void 0 !== i.internalFormat ? i.internalFormat : null, r.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006, r.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, r.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer, r.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null, r
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "setTexture",
                    value: function(e) {
                        e.image = {
                            width: this.width,
                            height: this.height,
                            depth: this.depth
                        }, this.texture = e
                    }
                }, {
                    key: "setSize",
                    value: function(e, t) {
                        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                        this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return (new this.constructor).copy(this)
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.image = (0, I._)({}, this.texture.image), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
                    }
                }, {
                    key: "dispose",
                    value: function() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }]), t
            }(eW);
            tr.prototype.isWebGLRenderTarget = !0,
                function(e) {
                    function t(e, n, r) {
                        (0, k._)(this, t);
                        var i, a = (i = (0, E._)(this, t, [e, n])).texture;
                        i.texture = [];
                        for (var o = 0; o < r; o++) i.texture[o] = a.clone();
                        return i
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "setSize",
                        value: function(e, t) {
                            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                            if (this.width !== e || this.height !== t || this.depth !== n) {
                                this.width = e, this.height = t, this.depth = n;
                                for (var r = 0, i = this.texture.length; r < i; r++) this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = n;
                                this.dispose()
                            }
                            return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this.texture.length = 0;
                            for (var t = 0, n = e.texture.length; t < n; t++) this.texture[t] = e.texture[t].clone();
                            return this
                        }
                    }]), t
                }(tr).prototype.isWebGLMultipleRenderTargets = !0;
            var ti = function(e) {
                function t(e, n) {
                    var r, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    return (0, k._)(this, t), (r = (0, E._)(this, t, [e, n, i])).samples = 4, r.ignoreDepthForMultisampleCopy = void 0 === i.ignoreDepth || i.ignoreDepth, r.useRenderToTexture = void 0 !== i.useRenderToTexture && i.useRenderToTexture, r.useRenderbuffer = !1 === r.useRenderToTexture, r
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.samples = e.samples, this.useRenderToTexture = e.useRenderToTexture, this.useRenderbuffer = e.useRenderbuffer, this
                    }
                }]), t
            }(tr);
            ti.prototype.isWebGLMultisampleRenderTarget = !0;
            var ta = function() {
                function e() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                        n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                        i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                    (0, k._)(this, e), this._x = t, this._y = n, this._z = r, this._w = i
                }
                return (0, A._)(e, [{
                    key: "x",
                    get: function() {
                        return this._x
                    },
                    set: function(e) {
                        this._x = e, this._onChangeCallback()
                    }
                }, {
                    key: "y",
                    get: function() {
                        return this._y
                    },
                    set: function(e) {
                        this._y = e, this._onChangeCallback()
                    }
                }, {
                    key: "z",
                    get: function() {
                        return this._z
                    },
                    set: function(e) {
                        this._z = e, this._onChangeCallback()
                    }
                }, {
                    key: "w",
                    get: function() {
                        return this._w
                    },
                    set: function(e) {
                        this._w = e, this._onChangeCallback()
                    }
                }, {
                    key: "set",
                    value: function(e, t, n, r) {
                        return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return new this.constructor(this._x, this._y, this._z, this._w)
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
                    }
                }, {
                    key: "setFromEuler",
                    value: function(e, t) {
                        if (!e || !e.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                        var n = e._x,
                            r = e._y,
                            i = e._z,
                            a = e._order,
                            o = Math.cos,
                            s = Math.sin,
                            l = o(n / 2),
                            u = o(r / 2),
                            c = o(i / 2),
                            h = s(n / 2),
                            d = s(r / 2),
                            f = s(i / 2);
                        switch (a) {
                            case "XYZ":
                                this._x = h * u * c + l * d * f, this._y = l * d * c - h * u * f, this._z = l * u * f + h * d * c, this._w = l * u * c - h * d * f;
                                break;
                            case "YXZ":
                                this._x = h * u * c + l * d * f, this._y = l * d * c - h * u * f, this._z = l * u * f - h * d * c, this._w = l * u * c + h * d * f;
                                break;
                            case "ZXY":
                                this._x = h * u * c - l * d * f, this._y = l * d * c + h * u * f, this._z = l * u * f + h * d * c, this._w = l * u * c - h * d * f;
                                break;
                            case "ZYX":
                                this._x = h * u * c - l * d * f, this._y = l * d * c + h * u * f, this._z = l * u * f - h * d * c, this._w = l * u * c + h * d * f;
                                break;
                            case "YZX":
                                this._x = h * u * c + l * d * f, this._y = l * d * c + h * u * f, this._z = l * u * f - h * d * c, this._w = l * u * c - h * d * f;
                                break;
                            case "XZY":
                                this._x = h * u * c - l * d * f, this._y = l * d * c - h * u * f, this._z = l * u * f + h * d * c, this._w = l * u * c + h * d * f;
                                break;
                            default:
                                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                        }
                        return !1 !== t && this._onChangeCallback(), this
                    }
                }, {
                    key: "setFromAxisAngle",
                    value: function(e, t) {
                        var n = t / 2,
                            r = Math.sin(n);
                        return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
                    }
                }, {
                    key: "setFromRotationMatrix",
                    value: function(e) {
                        var t = e.elements,
                            n = t[0],
                            r = t[4],
                            i = t[8],
                            a = t[1],
                            o = t[5],
                            s = t[9],
                            l = t[2],
                            u = t[6],
                            c = t[10],
                            h = n + o + c;
                        if (h > 0) {
                            var d = .5 / Math.sqrt(h + 1);
                            this._w = .25 / d, this._x = (u - s) * d, this._y = (i - l) * d, this._z = (a - r) * d
                        } else if (n > o && n > c) {
                            var f = 2 * Math.sqrt(1 + n - o - c);
                            this._w = (u - s) / f, this._x = .25 * f, this._y = (r + a) / f, this._z = (i + l) / f
                        } else if (o > c) {
                            var p = 2 * Math.sqrt(1 + o - n - c);
                            this._w = (i - l) / p, this._x = (r + a) / p, this._y = .25 * p, this._z = (s + u) / p
                        } else {
                            var m = 2 * Math.sqrt(1 + c - n - o);
                            this._w = (a - r) / m, this._x = (i + l) / m, this._y = (s + u) / m, this._z = .25 * m
                        }
                        return this._onChangeCallback(), this
                    }
                }, {
                    key: "setFromUnitVectors",
                    value: function(e, t) {
                        var n = e.dot(t) + 1;
                        return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0) : (this._x = 0, this._y = -e.z, this._z = e.y)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x), this._w = n, this.normalize()
                    }
                }, {
                    key: "angleTo",
                    value: function(e) {
                        return 2 * Math.acos(Math.abs(eK(this.dot(e), -1, 1)))
                    }
                }, {
                    key: "rotateTowards",
                    value: function(e, t) {
                        var n = this.angleTo(e);
                        if (0 === n) return this;
                        var r = Math.min(1, t / n);
                        return this.slerp(e, r), this
                    }
                }, {
                    key: "identity",
                    value: function() {
                        return this.set(0, 0, 0, 1)
                    }
                }, {
                    key: "invert",
                    value: function() {
                        return this.conjugate()
                    }
                }, {
                    key: "conjugate",
                    value: function() {
                        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                    }
                }, {
                    key: "dot",
                    value: function(e) {
                        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                    }
                }, {
                    key: "lengthSq",
                    value: function() {
                        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                    }
                }, {
                    key: "length",
                    value: function() {
                        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                    }
                }, {
                    key: "normalize",
                    value: function() {
                        var e = this.length();
                        return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
                    }
                }, {
                    key: "multiply",
                    value: function(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
                    }
                }, {
                    key: "premultiply",
                    value: function(e) {
                        return this.multiplyQuaternions(e, this)
                    }
                }, {
                    key: "multiplyQuaternions",
                    value: function(e, t) {
                        var n = e._x,
                            r = e._y,
                            i = e._z,
                            a = e._w,
                            o = t._x,
                            s = t._y,
                            l = t._z,
                            u = t._w;
                        return this._x = n * u + a * o + r * l - i * s, this._y = r * u + a * s + i * o - n * l, this._z = i * u + a * l + n * s - r * o, this._w = a * u - n * o - r * s - i * l, this._onChangeCallback(), this
                    }
                }, {
                    key: "slerp",
                    value: function(e, t) {
                        if (0 === t) return this;
                        if (1 === t) return this.copy(e);
                        var n = this._x,
                            r = this._y,
                            i = this._z,
                            a = this._w,
                            o = a * e._w + n * e._x + r * e._y + i * e._z;
                        if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = n, this._y = r, this._z = i, this;
                        var s = 1 - o * o;
                        if (s <= Number.EPSILON) {
                            var l = 1 - t;
                            return this._w = l * a + t * this._w, this._x = l * n + t * this._x, this._y = l * r + t * this._y, this._z = l * i + t * this._z, this.normalize(), this._onChangeCallback(), this
                        }
                        var u = Math.sqrt(s),
                            c = Math.atan2(u, o),
                            h = Math.sin((1 - t) * c) / u,
                            d = Math.sin(t * c) / u;
                        return this._w = a * h + this._w * d, this._x = n * h + this._x * d, this._y = r * h + this._y * d, this._z = i * h + this._z * d, this._onChangeCallback(), this
                    }
                }, {
                    key: "slerpQuaternions",
                    value: function(e, t, n) {
                        this.copy(e).slerp(t, n)
                    }
                }, {
                    key: "random",
                    value: function() {
                        var e = Math.random(),
                            t = Math.sqrt(1 - e),
                            n = Math.sqrt(e),
                            r = 2 * Math.PI * Math.random(),
                            i = 2 * Math.PI * Math.random();
                        return this.set(t * Math.cos(r), n * Math.sin(i), n * Math.cos(i), t * Math.sin(r))
                    }
                }, {
                    key: "equals",
                    value: function(e) {
                        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                    }
                }, {
                    key: "fromArray",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
                    }
                }, {
                    key: "toArray",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                    }
                }, {
                    key: "fromBufferAttribute",
                    value: function(e, t) {
                        return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
                    }
                }, {
                    key: "_onChange",
                    value: function(e) {
                        return this._onChangeCallback = e, this
                    }
                }, {
                    key: "_onChangeCallback",
                    value: function() {}
                }], [{
                    key: "slerp",
                    value: function(e, t, n, r) {
                        return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(e, t, r)
                    }
                }, {
                    key: "slerpFlat",
                    value: function(e, t, n, r, i, a, o) {
                        var s = n[r + 0],
                            l = n[r + 1],
                            u = n[r + 2],
                            c = n[r + 3],
                            h = i[a + 0],
                            d = i[a + 1],
                            f = i[a + 2],
                            p = i[a + 3];
                        if (0 === o) return e[t + 0] = s, e[t + 1] = l, e[t + 2] = u, void(e[t + 3] = c);
                        if (1 === o) return e[t + 0] = h, e[t + 1] = d, e[t + 2] = f, void(e[t + 3] = p);
                        if (c !== p || s !== h || l !== d || u !== f) {
                            var m = 1 - o,
                                v = s * h + l * d + u * f + c * p,
                                g = v >= 0 ? 1 : -1,
                                y = 1 - v * v;
                            if (y > Number.EPSILON) {
                                var _ = Math.sqrt(y),
                                    x = Math.atan2(_, v * g);
                                m = Math.sin(m * x) / _, o = Math.sin(o * x) / _
                            }
                            var b = o * g;
                            if (s = s * m + h * b, l = l * m + d * b, u = u * m + f * b, c = c * m + p * b, m === 1 - o) {
                                var w = 1 / Math.sqrt(s * s + l * l + u * u + c * c);
                                s *= w, l *= w, u *= w, c *= w
                            }
                        }
                        e[t] = s, e[t + 1] = l, e[t + 2] = u, e[t + 3] = c
                    }
                }, {
                    key: "multiplyQuaternionsFlat",
                    value: function(e, t, n, r, i, a) {
                        var o = n[r],
                            s = n[r + 1],
                            l = n[r + 2],
                            u = n[r + 3],
                            c = i[a],
                            h = i[a + 1],
                            d = i[a + 2],
                            f = i[a + 3];
                        return e[t] = o * f + u * c + s * d - l * h, e[t + 1] = s * f + u * h + l * c - o * d, e[t + 2] = l * f + u * d + o * h - s * c, e[t + 3] = u * f - o * c - s * h - l * d, e
                    }
                }]), e
            }();
            ta.prototype.isQuaternion = !0;
            var to = function() {
                function e() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                        n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                    (0, k._)(this, e), this.x = t, this.y = n, this.z = r
                }
                return (0, A._)(e, [{
                    key: "set",
                    value: function(e, t, n) {
                        return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
                    }
                }, {
                    key: "setScalar",
                    value: function(e) {
                        return this.x = e, this.y = e, this.z = e, this
                    }
                }, {
                    key: "setX",
                    value: function(e) {
                        return this.x = e, this
                    }
                }, {
                    key: "setY",
                    value: function(e) {
                        return this.y = e, this
                    }
                }, {
                    key: "setZ",
                    value: function(e) {
                        return this.z = e, this
                    }
                }, {
                    key: "setComponent",
                    value: function(e, t) {
                        switch (e) {
                            case 0:
                                this.x = t;
                                break;
                            case 1:
                                this.y = t;
                                break;
                            case 2:
                                this.z = t;
                                break;
                            default:
                                throw Error("index is out of range: " + e)
                        }
                        return this
                    }
                }, {
                    key: "getComponent",
                    value: function(e) {
                        switch (e) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                throw Error("index is out of range: " + e)
                        }
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return new this.constructor(this.x, this.y, this.z)
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return this.x = e.x, this.y = e.y, this.z = e.z, this
                    }
                }, {
                    key: "add",
                    value: function(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
                    }
                }, {
                    key: "addScalar",
                    value: function(e) {
                        return this.x += e, this.y += e, this.z += e, this
                    }
                }, {
                    key: "addVectors",
                    value: function(e, t) {
                        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                    }
                }, {
                    key: "addScaledVector",
                    value: function(e, t) {
                        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                    }
                }, {
                    key: "sub",
                    value: function(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
                    }
                }, {
                    key: "subScalar",
                    value: function(e) {
                        return this.x -= e, this.y -= e, this.z -= e, this
                    }
                }, {
                    key: "subVectors",
                    value: function(e, t) {
                        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                    }
                }, {
                    key: "multiply",
                    value: function(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
                    }
                }, {
                    key: "multiplyScalar",
                    value: function(e) {
                        return this.x *= e, this.y *= e, this.z *= e, this
                    }
                }, {
                    key: "multiplyVectors",
                    value: function(e, t) {
                        return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                    }
                }, {
                    key: "applyEuler",
                    value: function(e) {
                        return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(tl.setFromEuler(e))
                    }
                }, {
                    key: "applyAxisAngle",
                    value: function(e, t) {
                        return this.applyQuaternion(tl.setFromAxisAngle(e, t))
                    }
                }, {
                    key: "applyMatrix3",
                    value: function(e) {
                        var t = this.x,
                            n = this.y,
                            r = this.z,
                            i = e.elements;
                        return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this
                    }
                }, {
                    key: "applyNormalMatrix",
                    value: function(e) {
                        return this.applyMatrix3(e).normalize()
                    }
                }, {
                    key: "applyMatrix4",
                    value: function(e) {
                        var t = this.x,
                            n = this.y,
                            r = this.z,
                            i = e.elements,
                            a = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                        return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * a, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * a, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * a, this
                    }
                }, {
                    key: "applyQuaternion",
                    value: function(e) {
                        var t = this.x,
                            n = this.y,
                            r = this.z,
                            i = e.x,
                            a = e.y,
                            o = e.z,
                            s = e.w,
                            l = s * t + a * r - o * n,
                            u = s * n + o * t - i * r,
                            c = s * r + i * n - a * t,
                            h = -i * t - a * n - o * r;
                        return this.x = l * s + -(h * i) + -(u * o) - -(c * a), this.y = u * s + -(h * a) + -(c * i) - -(l * o), this.z = c * s + -(h * o) + -(l * a) - -(u * i), this
                    }
                }, {
                    key: "project",
                    value: function(e) {
                        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                    }
                }, {
                    key: "unproject",
                    value: function(e) {
                        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                    }
                }, {
                    key: "transformDirection",
                    value: function(e) {
                        var t = this.x,
                            n = this.y,
                            r = this.z,
                            i = e.elements;
                        return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize()
                    }
                }, {
                    key: "divide",
                    value: function(e) {
                        return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                    }
                }, {
                    key: "divideScalar",
                    value: function(e) {
                        return this.multiplyScalar(1 / e)
                    }
                }, {
                    key: "min",
                    value: function(e) {
                        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                    }
                }, {
                    key: "max",
                    value: function(e) {
                        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                    }
                }, {
                    key: "clamp",
                    value: function(e, t) {
                        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                    }
                }, {
                    key: "clampScalar",
                    value: function(e, t) {
                        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
                    }
                }, {
                    key: "clampLength",
                    value: function(e, t) {
                        var n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                    }
                }, {
                    key: "floor",
                    value: function() {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                    }
                }, {
                    key: "ceil",
                    value: function() {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                    }
                }, {
                    key: "round",
                    value: function() {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                    }
                }, {
                    key: "roundToZero",
                    value: function() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                    }
                }, {
                    key: "negate",
                    value: function() {
                        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                    }
                }, {
                    key: "dot",
                    value: function(e) {
                        return this.x * e.x + this.y * e.y + this.z * e.z
                    }
                }, {
                    key: "lengthSq",
                    value: function() {
                        return this.x * this.x + this.y * this.y + this.z * this.z
                    }
                }, {
                    key: "length",
                    value: function() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                    }
                }, {
                    key: "manhattanLength",
                    value: function() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                    }
                }, {
                    key: "normalize",
                    value: function() {
                        return this.divideScalar(this.length() || 1)
                    }
                }, {
                    key: "setLength",
                    value: function(e) {
                        return this.normalize().multiplyScalar(e)
                    }
                }, {
                    key: "lerp",
                    value: function(e, t) {
                        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                    }
                }, {
                    key: "lerpVectors",
                    value: function(e, t, n) {
                        return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
                    }
                }, {
                    key: "cross",
                    value: function(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
                    }
                }, {
                    key: "crossVectors",
                    value: function(e, t) {
                        var n = e.x,
                            r = e.y,
                            i = e.z,
                            a = t.x,
                            o = t.y,
                            s = t.z;
                        return this.x = r * s - i * o, this.y = i * a - n * s, this.z = n * o - r * a, this
                    }
                }, {
                    key: "projectOnVector",
                    value: function(e) {
                        var t = e.lengthSq();
                        if (0 === t) return this.set(0, 0, 0);
                        var n = e.dot(this) / t;
                        return this.copy(e).multiplyScalar(n)
                    }
                }, {
                    key: "projectOnPlane",
                    value: function(e) {
                        return ts.copy(this).projectOnVector(e), this.sub(ts)
                    }
                }, {
                    key: "reflect",
                    value: function(e) {
                        return this.sub(ts.copy(e).multiplyScalar(2 * this.dot(e)))
                    }
                }, {
                    key: "angleTo",
                    value: function(e) {
                        var t = Math.sqrt(this.lengthSq() * e.lengthSq());
                        return 0 === t ? Math.PI / 2 : Math.acos(eK(this.dot(e) / t, -1, 1))
                    }
                }, {
                    key: "distanceTo",
                    value: function(e) {
                        return Math.sqrt(this.distanceToSquared(e))
                    }
                }, {
                    key: "distanceToSquared",
                    value: function(e) {
                        var t = this.x - e.x,
                            n = this.y - e.y,
                            r = this.z - e.z;
                        return t * t + n * n + r * r
                    }
                }, {
                    key: "manhattanDistanceTo",
                    value: function(e) {
                        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                    }
                }, {
                    key: "setFromSpherical",
                    value: function(e) {
                        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                    }
                }, {
                    key: "setFromSphericalCoords",
                    value: function(e, t, n) {
                        var r = Math.sin(t) * e;
                        return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this
                    }
                }, {
                    key: "setFromCylindrical",
                    value: function(e) {
                        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                    }
                }, {
                    key: "setFromCylindricalCoords",
                    value: function(e, t, n) {
                        return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
                    }
                }, {
                    key: "setFromMatrixPosition",
                    value: function(e) {
                        var t = e.elements;
                        return this.x = t[12], this.y = t[13], this.z = t[14], this
                    }
                }, {
                    key: "setFromMatrixScale",
                    value: function(e) {
                        var t = this.setFromMatrixColumn(e, 0).length(),
                            n = this.setFromMatrixColumn(e, 1).length(),
                            r = this.setFromMatrixColumn(e, 2).length();
                        return this.x = t, this.y = n, this.z = r, this
                    }
                }, {
                    key: "setFromMatrixColumn",
                    value: function(e, t) {
                        return this.fromArray(e.elements, 4 * t)
                    }
                }, {
                    key: "setFromMatrix3Column",
                    value: function(e, t) {
                        return this.fromArray(e.elements, 3 * t)
                    }
                }, {
                    key: "equals",
                    value: function(e) {
                        return e.x === this.x && e.y === this.y && e.z === this.z
                    }
                }, {
                    key: "fromArray",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                    }
                }, {
                    key: "toArray",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                    }
                }, {
                    key: "fromBufferAttribute",
                    value: function(e, t, n) {
                        return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
                    }
                }, {
                    key: "random",
                    value: function() {
                        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                    }
                }, {
                    key: "randomDirection",
                    value: function() {
                        var e = 2 * (Math.random() - .5),
                            t = Math.random() * Math.PI * 2,
                            n = Math.sqrt(1 - Math.pow(e, 2));
                        return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this
                    }
                }, {
                    key: Symbol.iterator,
                    value: function() {
                        return (0, z.YH)(this, function(e) {
                            switch (e.label) {
                                case 0:
                                    return [4, this.x];
                                case 1:
                                    return e.sent(), [4, this.y];
                                case 2:
                                    return e.sent(), [4, this.z];
                                case 3:
                                    return e.sent(), [2]
                            }
                        })
                    }
                }]), e
            }();
            to.prototype.isVector3 = !0;
            var ts = new to,
                tl = new ta,
                tu = function() {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new to(1 / 0, 1 / 0, 1 / 0),
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new to(-1 / 0, -1 / 0, -1 / 0);
                        (0, k._)(this, e), this.min = t, this.max = n
                    }
                    return (0, A._)(e, [{
                        key: "set",
                        value: function(e, t) {
                            return this.min.copy(e), this.max.copy(t), this
                        }
                    }, {
                        key: "setFromArray",
                        value: function(e) {
                            for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = e.length; s < l; s += 3) {
                                var u = e[s],
                                    c = e[s + 1],
                                    h = e[s + 2];
                                u < t && (t = u), c < n && (n = c), h < r && (r = h), u > i && (i = u), c > a && (a = c), h > o && (o = h)
                            }
                            return this.min.set(t, n, r), this.max.set(i, a, o), this
                        }
                    }, {
                        key: "setFromBufferAttribute",
                        value: function(e) {
                            for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = e.count; s < l; s++) {
                                var u = e.getX(s),
                                    c = e.getY(s),
                                    h = e.getZ(s);
                                u < t && (t = u), c < n && (n = c), h < r && (r = h), u > i && (i = u), c > a && (a = c), h > o && (o = h)
                            }
                            return this.min.set(t, n, r), this.max.set(i, a, o), this
                        }
                    }, {
                        key: "setFromPoints",
                        value: function(e) {
                            this.makeEmpty();
                            for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                            return this
                        }
                    }, {
                        key: "setFromCenterAndSize",
                        value: function(e, t) {
                            var n = th.copy(t).multiplyScalar(.5);
                            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                        }
                    }, {
                        key: "setFromObject",
                        value: function(e) {
                            return this.makeEmpty(), this.expandByObject(e)
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return (new this.constructor).copy(this)
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return this.min.copy(e.min), this.max.copy(e.max), this
                        }
                    }, {
                        key: "makeEmpty",
                        value: function() {
                            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                        }
                    }, {
                        key: "isEmpty",
                        value: function() {
                            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                        }
                    }, {
                        key: "getCenter",
                        value: function(e) {
                            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                        }
                    }, {
                        key: "getSize",
                        value: function(e) {
                            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                        }
                    }, {
                        key: "expandByPoint",
                        value: function(e) {
                            return this.min.min(e), this.max.max(e), this
                        }
                    }, {
                        key: "expandByVector",
                        value: function(e) {
                            return this.min.sub(e), this.max.add(e), this
                        }
                    }, {
                        key: "expandByScalar",
                        value: function(e) {
                            return this.min.addScalar(-e), this.max.addScalar(e), this
                        }
                    }, {
                        key: "expandByObject",
                        value: function(e) {
                            e.updateWorldMatrix(!1, !1);
                            var t = e.geometry;
                            void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), td.copy(t.boundingBox), td.applyMatrix4(e.matrixWorld), this.union(td));
                            for (var n = e.children, r = 0, i = n.length; r < i; r++) this.expandByObject(n[r]);
                            return this
                        }
                    }, {
                        key: "containsPoint",
                        value: function(e) {
                            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                        }
                    }, {
                        key: "containsBox",
                        value: function(e) {
                            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                        }
                    }, {
                        key: "getParameter",
                        value: function(e, t) {
                            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                        }
                    }, {
                        key: "intersectsBox",
                        value: function(e) {
                            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                        }
                    }, {
                        key: "intersectsSphere",
                        value: function(e) {
                            return this.clampPoint(e.center, th), th.distanceToSquared(e.center) <= e.radius * e.radius
                        }
                    }, {
                        key: "intersectsPlane",
                        value: function(e) {
                            var t, n;
                            return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
                        }
                    }, {
                        key: "intersectsTriangle",
                        value: function(e) {
                            if (this.isEmpty()) return !1;
                            this.getCenter(t_), tx.subVectors(this.max, t_), tf.subVectors(e.a, t_), tp.subVectors(e.b, t_), tm.subVectors(e.c, t_), tv.subVectors(tp, tf), tg.subVectors(tm, tp), ty.subVectors(tf, tm);
                            var t = [0, -tv.z, tv.y, 0, -tg.z, tg.y, 0, -ty.z, ty.y, tv.z, 0, -tv.x, tg.z, 0, -tg.x, ty.z, 0, -ty.x, -tv.y, tv.x, 0, -tg.y, tg.x, 0, -ty.y, ty.x, 0];
                            return !!tM(t, tf, tp, tm, tx) && !!tM(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], tf, tp, tm, tx) && (tb.crossVectors(tv, tg), tM(t = [tb.x, tb.y, tb.z], tf, tp, tm, tx))
                        }
                    }, {
                        key: "clampPoint",
                        value: function(e, t) {
                            return t.copy(e).clamp(this.min, this.max)
                        }
                    }, {
                        key: "distanceToPoint",
                        value: function(e) {
                            return th.copy(e).clamp(this.min, this.max).sub(e).length()
                        }
                    }, {
                        key: "getBoundingSphere",
                        value: function(e) {
                            return this.getCenter(e.center), e.radius = .5 * this.getSize(th).length(), e
                        }
                    }, {
                        key: "intersect",
                        value: function(e) {
                            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                        }
                    }, {
                        key: "union",
                        value: function(e) {
                            return this.min.min(e.min), this.max.max(e.max), this
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function(e) {
                            return this.isEmpty() || (tc[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), tc[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), tc[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), tc[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), tc[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), tc[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), tc[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), tc[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(tc)), this
                        }
                    }, {
                        key: "translate",
                        value: function(e) {
                            return this.min.add(e), this.max.add(e), this
                        }
                    }, {
                        key: "equals",
                        value: function(e) {
                            return e.min.equals(this.min) && e.max.equals(this.max)
                        }
                    }]), e
                }();
            tu.prototype.isBox3 = !0;
            var tc = [new to, new to, new to, new to, new to, new to, new to, new to],
                th = new to,
                td = new tu,
                tf = new to,
                tp = new to,
                tm = new to,
                tv = new to,
                tg = new to,
                ty = new to,
                t_ = new to,
                tx = new to,
                tb = new to,
                tw = new to;

            function tM(e, t, n, r, i) {
                for (var a = 0, o = e.length - 3; a <= o; a += 3) {
                    tw.fromArray(e, a);
                    var s = i.x * Math.abs(tw.x) + i.y * Math.abs(tw.y) + i.z * Math.abs(tw.z),
                        l = t.dot(tw),
                        u = n.dot(tw),
                        c = r.dot(tw);
                    if (Math.max(-Math.max(l, u, c), Math.min(l, u, c)) > s) return !1
                }
                return !0
            }
            var tS = new tu,
                tT = new to,
                tE = new to,
                tk = new to,
                tA = function() {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new to,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
                        (0, k._)(this, e), this.center = t, this.radius = n
                    }
                    return (0, A._)(e, [{
                        key: "set",
                        value: function(e, t) {
                            return this.center.copy(e), this.radius = t, this
                        }
                    }, {
                        key: "setFromPoints",
                        value: function(e, t) {
                            var n = this.center;
                            void 0 !== t ? n.copy(t) : tS.setFromPoints(e).getCenter(n);
                            for (var r = 0, i = 0, a = e.length; i < a; i++) r = Math.max(r, n.distanceToSquared(e[i]));
                            return this.radius = Math.sqrt(r), this
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return this.center.copy(e.center), this.radius = e.radius, this
                        }
                    }, {
                        key: "isEmpty",
                        value: function() {
                            return this.radius < 0
                        }
                    }, {
                        key: "makeEmpty",
                        value: function() {
                            return this.center.set(0, 0, 0), this.radius = -1, this
                        }
                    }, {
                        key: "containsPoint",
                        value: function(e) {
                            return e.distanceToSquared(this.center) <= this.radius * this.radius
                        }
                    }, {
                        key: "distanceToPoint",
                        value: function(e) {
                            return e.distanceTo(this.center) - this.radius
                        }
                    }, {
                        key: "intersectsSphere",
                        value: function(e) {
                            var t = this.radius + e.radius;
                            return e.center.distanceToSquared(this.center) <= t * t
                        }
                    }, {
                        key: "intersectsBox",
                        value: function(e) {
                            return e.intersectsSphere(this)
                        }
                    }, {
                        key: "intersectsPlane",
                        value: function(e) {
                            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                        }
                    }, {
                        key: "clampPoint",
                        value: function(e, t) {
                            var n = this.center.distanceToSquared(e);
                            return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
                        }
                    }, {
                        key: "getBoundingBox",
                        value: function(e) {
                            return this.isEmpty() ? e.makeEmpty() : (e.set(this.center, this.center), e.expandByScalar(this.radius)), e
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function(e) {
                            return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                        }
                    }, {
                        key: "translate",
                        value: function(e) {
                            return this.center.add(e), this
                        }
                    }, {
                        key: "expandByPoint",
                        value: function(e) {
                            tk.subVectors(e, this.center);
                            var t = tk.lengthSq();
                            if (t > this.radius * this.radius) {
                                var n = Math.sqrt(t),
                                    r = .5 * (n - this.radius);
                                this.center.add(tk.multiplyScalar(r / n)), this.radius += r
                            }
                            return this
                        }
                    }, {
                        key: "union",
                        value: function(e) {
                            return !0 === this.center.equals(e.center) ? tE.set(0, 0, 1).multiplyScalar(e.radius) : tE.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(tT.copy(e.center).add(tE)), this.expandByPoint(tT.copy(e.center).sub(tE)), this
                        }
                    }, {
                        key: "equals",
                        value: function(e) {
                            return e.center.equals(this.center) && e.radius === this.radius
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return (new this.constructor).copy(this)
                        }
                    }]), e
                }(),
                tR = new to,
                tC = new to,
                tL = new to,
                tP = new to,
                tI = new to,
                tD = new to,
                tO = new to,
                tN = function() {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new to,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new to(0, 0, -1);
                        (0, k._)(this, e), this.origin = t, this.direction = n
                    }
                    return (0, A._)(e, [{
                        key: "set",
                        value: function(e, t) {
                            return this.origin.copy(e), this.direction.copy(t), this
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                        }
                    }, {
                        key: "at",
                        value: function(e, t) {
                            return t.copy(this.direction).multiplyScalar(e).add(this.origin)
                        }
                    }, {
                        key: "lookAt",
                        value: function(e) {
                            return this.direction.copy(e).sub(this.origin).normalize(), this
                        }
                    }, {
                        key: "recast",
                        value: function(e) {
                            return this.origin.copy(this.at(e, tR)), this
                        }
                    }, {
                        key: "closestPointToPoint",
                        value: function(e, t) {
                            t.subVectors(e, this.origin);
                            var n = t.dot(this.direction);
                            return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
                        }
                    }, {
                        key: "distanceToPoint",
                        value: function(e) {
                            return Math.sqrt(this.distanceSqToPoint(e))
                        }
                    }, {
                        key: "distanceSqToPoint",
                        value: function(e) {
                            var t = tR.subVectors(e, this.origin).dot(this.direction);
                            return t < 0 ? this.origin.distanceToSquared(e) : (tR.copy(this.direction).multiplyScalar(t).add(this.origin), tR.distanceToSquared(e))
                        }
                    }, {
                        key: "distanceSqToSegment",
                        value: function(e, t, n, r) {
                            tC.copy(e).add(t).multiplyScalar(.5), tL.copy(t).sub(e).normalize(), tP.copy(this.origin).sub(tC);
                            var i, a, o, s, l = .5 * e.distanceTo(t),
                                u = -this.direction.dot(tL),
                                c = tP.dot(this.direction),
                                h = -tP.dot(tL),
                                d = tP.lengthSq(),
                                f = Math.abs(1 - u * u);
                            if (f > 0) {
                                if (i = u * h - c, a = u * c - h, s = l * f, i >= 0) {
                                    if (a >= -s) {
                                        if (a <= s) {
                                            var p = 1 / f;
                                            i *= p, a *= p, o = i * (i + u * a + 2 * c) + a * (u * i + a + 2 * h) + d
                                        } else o = -(i = Math.max(0, -(u * (a = l) + c))) * i + a * (a + 2 * h) + d
                                    } else o = -(i = Math.max(0, -(u * (a = -l) + c))) * i + a * (a + 2 * h) + d
                                } else a <= -s ? (a = (i = Math.max(0, -(-u * l + c))) > 0 ? -l : Math.min(Math.max(-l, -h), l), o = -i * i + a * (a + 2 * h) + d) : a <= s ? (i = 0, o = (a = Math.min(Math.max(-l, -h), l)) * (a + 2 * h) + d) : (a = (i = Math.max(0, -(u * l + c))) > 0 ? l : Math.min(Math.max(-l, -h), l), o = -i * i + a * (a + 2 * h) + d)
                            } else a = u > 0 ? -l : l, o = -(i = Math.max(0, -(u * a + c))) * i + a * (a + 2 * h) + d;
                            return n && n.copy(this.direction).multiplyScalar(i).add(this.origin), r && r.copy(tL).multiplyScalar(a).add(tC), o
                        }
                    }, {
                        key: "intersectSphere",
                        value: function(e, t) {
                            tR.subVectors(e.center, this.origin);
                            var n = tR.dot(this.direction),
                                r = tR.dot(tR) - n * n,
                                i = e.radius * e.radius;
                            if (r > i) return null;
                            var a = Math.sqrt(i - r),
                                o = n - a,
                                s = n + a;
                            return o < 0 && s < 0 ? null : o < 0 ? this.at(s, t) : this.at(o, t)
                        }
                    }, {
                        key: "intersectsSphere",
                        value: function(e) {
                            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                        }
                    }, {
                        key: "distanceToPlane",
                        value: function(e) {
                            var t = e.normal.dot(this.direction);
                            if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                            var n = -(this.origin.dot(e.normal) + e.constant) / t;
                            return n >= 0 ? n : null
                        }
                    }, {
                        key: "intersectPlane",
                        value: function(e, t) {
                            var n = this.distanceToPlane(e);
                            return null === n ? null : this.at(n, t)
                        }
                    }, {
                        key: "intersectsPlane",
                        value: function(e) {
                            var t = e.distanceToPoint(this.origin);
                            return 0 === t || e.normal.dot(this.direction) * t < 0
                        }
                    }, {
                        key: "intersectBox",
                        value: function(e, t) {
                            var n, r, i, a, o, s, l = 1 / this.direction.x,
                                u = 1 / this.direction.y,
                                c = 1 / this.direction.z,
                                h = this.origin;
                            return l >= 0 ? (n = (e.min.x - h.x) * l, r = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, r = (e.min.x - h.x) * l), u >= 0 ? (i = (e.min.y - h.y) * u, a = (e.max.y - h.y) * u) : (i = (e.max.y - h.y) * u, a = (e.min.y - h.y) * u), n > a || i > r ? null : ((i > n || n != n) && (n = i), (a < r || r != r) && (r = a), c >= 0 ? (o = (e.min.z - h.z) * c, s = (e.max.z - h.z) * c) : (o = (e.max.z - h.z) * c, s = (e.min.z - h.z) * c), n > s || o > r ? null : ((o > n || n != n) && (n = o), (s < r || r != r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, t)))
                        }
                    }, {
                        key: "intersectsBox",
                        value: function(e) {
                            return null !== this.intersectBox(e, tR)
                        }
                    }, {
                        key: "intersectTriangle",
                        value: function(e, t, n, r, i) {
                            tI.subVectors(t, e), tD.subVectors(n, e), tO.crossVectors(tI, tD);
                            var a, o = this.direction.dot(tO);
                            if (o > 0) {
                                if (r) return null;
                                a = 1
                            } else {
                                if (!(o < 0)) return null;
                                a = -1, o = -o
                            }
                            tP.subVectors(this.origin, e);
                            var s = a * this.direction.dot(tD.crossVectors(tP, tD));
                            if (s < 0) return null;
                            var l = a * this.direction.dot(tI.cross(tP));
                            if (l < 0 || s + l > o) return null;
                            var u = -a * tP.dot(tO);
                            return u < 0 ? null : this.at(u / o, i)
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function(e) {
                            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                        }
                    }, {
                        key: "equals",
                        value: function(e) {
                            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return (new this.constructor).copy(this)
                        }
                    }]), e
                }(),
                tF = function() {
                    function e() {
                        (0, k._)(this, e), this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                    }
                    return (0, A._)(e, [{
                        key: "set",
                        value: function(e, t, n, r, i, a, o, s, l, u, c, h, d, f, p, m) {
                            var v = this.elements;
                            return v[0] = e, v[4] = t, v[8] = n, v[12] = r, v[1] = i, v[5] = a, v[9] = o, v[13] = s, v[2] = l, v[6] = u, v[10] = c, v[14] = h, v[3] = d, v[7] = f, v[11] = p, v[15] = m, this
                        }
                    }, {
                        key: "identity",
                        value: function() {
                            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return (new e).fromArray(this.elements)
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            var t = this.elements,
                                n = e.elements;
                            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
                        }
                    }, {
                        key: "copyPosition",
                        value: function(e) {
                            var t = this.elements,
                                n = e.elements;
                            return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
                        }
                    }, {
                        key: "setFromMatrix3",
                        value: function(e) {
                            var t = e.elements;
                            return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "extractBasis",
                        value: function(e, t, n) {
                            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                        }
                    }, {
                        key: "makeBasis",
                        value: function(e, t, n) {
                            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "extractRotation",
                        value: function(e) {
                            var t = this.elements,
                                n = e.elements,
                                r = 1 / tU.setFromMatrixColumn(e, 0).length(),
                                i = 1 / tU.setFromMatrixColumn(e, 1).length(),
                                a = 1 / tU.setFromMatrixColumn(e, 2).length();
                            return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                        }
                    }, {
                        key: "makeRotationFromEuler",
                        value: function(e) {
                            e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                            var t = this.elements,
                                n = e.x,
                                r = e.y,
                                i = e.z,
                                a = Math.cos(n),
                                o = Math.sin(n),
                                s = Math.cos(r),
                                l = Math.sin(r),
                                u = Math.cos(i),
                                c = Math.sin(i);
                            if ("XYZ" === e.order) {
                                var h = a * u,
                                    d = a * c,
                                    f = o * u,
                                    p = o * c;
                                t[0] = s * u, t[4] = -s * c, t[8] = l, t[1] = d + f * l, t[5] = h - p * l, t[9] = -o * s, t[2] = p - h * l, t[6] = f + d * l, t[10] = a * s
                            } else if ("YXZ" === e.order) {
                                var m = s * u,
                                    v = s * c,
                                    g = l * u,
                                    y = l * c;
                                t[0] = m + y * o, t[4] = g * o - v, t[8] = a * l, t[1] = a * c, t[5] = a * u, t[9] = -o, t[2] = v * o - g, t[6] = y + m * o, t[10] = a * s
                            } else if ("ZXY" === e.order) {
                                var _ = s * u,
                                    x = s * c,
                                    b = l * u,
                                    w = l * c;
                                t[0] = _ - w * o, t[4] = -a * c, t[8] = b + x * o, t[1] = x + b * o, t[5] = a * u, t[9] = w - _ * o, t[2] = -a * l, t[6] = o, t[10] = a * s
                            } else if ("ZYX" === e.order) {
                                var M = a * u,
                                    S = a * c,
                                    T = o * u,
                                    E = o * c;
                                t[0] = s * u, t[4] = T * l - S, t[8] = M * l + E, t[1] = s * c, t[5] = E * l + M, t[9] = S * l - T, t[2] = -l, t[6] = o * s, t[10] = a * s
                            } else if ("YZX" === e.order) {
                                var k = a * s,
                                    A = a * l,
                                    R = o * s,
                                    C = o * l;
                                t[0] = s * u, t[4] = C - k * c, t[8] = R * c + A, t[1] = c, t[5] = a * u, t[9] = -o * u, t[2] = -l * u, t[6] = A * c + R, t[10] = k - C * c
                            } else if ("XZY" === e.order) {
                                var L = a * s,
                                    P = a * l,
                                    I = o * s,
                                    D = o * l;
                                t[0] = s * u, t[4] = -c, t[8] = l * u, t[1] = L * c + D, t[5] = a * u, t[9] = P * c - I, t[2] = I * c - P, t[6] = o * u, t[10] = D * c + L
                            }
                            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                        }
                    }, {
                        key: "makeRotationFromQuaternion",
                        value: function(e) {
                            return this.compose(tz, e, tH)
                        }
                    }, {
                        key: "lookAt",
                        value: function(e, t, n) {
                            var r = this.elements;
                            return tW.subVectors(e, t), 0 === tW.lengthSq() && (tW.z = 1), tW.normalize(), tV.crossVectors(n, tW), 0 === tV.lengthSq() && (1 === Math.abs(n.z) ? tW.x += 1e-4 : tW.z += 1e-4, tW.normalize(), tV.crossVectors(n, tW)), tV.normalize(), tG.crossVectors(tW, tV), r[0] = tV.x, r[4] = tG.x, r[8] = tW.x, r[1] = tV.y, r[5] = tG.y, r[9] = tW.y, r[2] = tV.z, r[6] = tG.z, r[10] = tW.z, this
                        }
                    }, {
                        key: "multiply",
                        value: function(e, t) {
                            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
                        }
                    }, {
                        key: "premultiply",
                        value: function(e) {
                            return this.multiplyMatrices(e, this)
                        }
                    }, {
                        key: "multiplyMatrices",
                        value: function(e, t) {
                            var n = e.elements,
                                r = t.elements,
                                i = this.elements,
                                a = n[0],
                                o = n[4],
                                s = n[8],
                                l = n[12],
                                u = n[1],
                                c = n[5],
                                h = n[9],
                                d = n[13],
                                f = n[2],
                                p = n[6],
                                m = n[10],
                                v = n[14],
                                g = n[3],
                                y = n[7],
                                _ = n[11],
                                x = n[15],
                                b = r[0],
                                w = r[4],
                                M = r[8],
                                S = r[12],
                                T = r[1],
                                E = r[5],
                                k = r[9],
                                A = r[13],
                                R = r[2],
                                C = r[6],
                                L = r[10],
                                P = r[14],
                                I = r[3],
                                D = r[7],
                                O = r[11],
                                N = r[15];
                            return i[0] = a * b + o * T + s * R + l * I, i[4] = a * w + o * E + s * C + l * D, i[8] = a * M + o * k + s * L + l * O, i[12] = a * S + o * A + s * P + l * N, i[1] = u * b + c * T + h * R + d * I, i[5] = u * w + c * E + h * C + d * D, i[9] = u * M + c * k + h * L + d * O, i[13] = u * S + c * A + h * P + d * N, i[2] = f * b + p * T + m * R + v * I, i[6] = f * w + p * E + m * C + v * D, i[10] = f * M + p * k + m * L + v * O, i[14] = f * S + p * A + m * P + v * N, i[3] = g * b + y * T + _ * R + x * I, i[7] = g * w + y * E + _ * C + x * D, i[11] = g * M + y * k + _ * L + x * O, i[15] = g * S + y * A + _ * P + x * N, this
                        }
                    }, {
                        key: "multiplyScalar",
                        value: function(e) {
                            var t = this.elements;
                            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                        }
                    }, {
                        key: "determinant",
                        value: function() {
                            var e = this.elements,
                                t = e[0],
                                n = e[4],
                                r = e[8],
                                i = e[12],
                                a = e[1],
                                o = e[5],
                                s = e[9],
                                l = e[13],
                                u = e[2],
                                c = e[6],
                                h = e[10],
                                d = e[14];
                            return e[3] * (+i * s * c - r * l * c - i * o * h + n * l * h + r * o * d - n * s * d) + e[7] * (+t * s * d - t * l * h + i * a * h - r * a * d + r * l * u - i * s * u) + e[11] * (+t * l * c - t * o * d - i * a * c + n * a * d + i * o * u - n * l * u) + e[15] * (-r * o * u - t * s * c + t * o * h + r * a * c - n * a * h + n * s * u)
                        }
                    }, {
                        key: "transpose",
                        value: function() {
                            var e, t = this.elements;
                            return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                        }
                    }, {
                        key: "setPosition",
                        value: function(e, t, n) {
                            var r = this.elements;
                            return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this
                        }
                    }, {
                        key: "invert",
                        value: function() {
                            var e = this.elements,
                                t = e[0],
                                n = e[1],
                                r = e[2],
                                i = e[3],
                                a = e[4],
                                o = e[5],
                                s = e[6],
                                l = e[7],
                                u = e[8],
                                c = e[9],
                                h = e[10],
                                d = e[11],
                                f = e[12],
                                p = e[13],
                                m = e[14],
                                v = e[15],
                                g = c * m * l - p * h * l + p * s * d - o * m * d - c * s * v + o * h * v,
                                y = f * h * l - u * m * l - f * s * d + a * m * d + u * s * v - a * h * v,
                                _ = u * p * l - f * c * l + f * o * d - a * p * d - u * o * v + a * c * v,
                                x = f * c * s - u * p * s - f * o * h + a * p * h + u * o * m - a * c * m,
                                b = t * g + n * y + r * _ + i * x;
                            if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                            var w = 1 / b;
                            return e[0] = g * w, e[1] = (p * h * i - c * m * i - p * r * d + n * m * d + c * r * v - n * h * v) * w, e[2] = (o * m * i - p * s * i + p * r * l - n * m * l - o * r * v + n * s * v) * w, e[3] = (c * s * i - o * h * i - c * r * l + n * h * l + o * r * d - n * s * d) * w, e[4] = y * w, e[5] = (u * m * i - f * h * i + f * r * d - t * m * d - u * r * v + t * h * v) * w, e[6] = (f * s * i - a * m * i - f * r * l + t * m * l + a * r * v - t * s * v) * w, e[7] = (a * h * i - u * s * i + u * r * l - t * h * l - a * r * d + t * s * d) * w, e[8] = _ * w, e[9] = (f * c * i - u * p * i - f * n * d + t * p * d + u * n * v - t * c * v) * w, e[10] = (a * p * i - f * o * i + f * n * l - t * p * l - a * n * v + t * o * v) * w, e[11] = (u * o * i - a * c * i - u * n * l + t * c * l + a * n * d - t * o * d) * w, e[12] = x * w, e[13] = (u * p * r - f * c * r + f * n * h - t * p * h - u * n * m + t * c * m) * w, e[14] = (f * o * r - a * p * r - f * n * s + t * p * s + a * n * m - t * o * m) * w, e[15] = (a * c * r - u * o * r + u * n * s - t * c * s - a * n * h + t * o * h) * w, this
                        }
                    }, {
                        key: "scale",
                        value: function(e) {
                            var t = this.elements,
                                n = e.x,
                                r = e.y,
                                i = e.z;
                            return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this
                        }
                    }, {
                        key: "getMaxScaleOnAxis",
                        value: function() {
                            var e = this.elements;
                            return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10]))
                        }
                    }, {
                        key: "makeTranslation",
                        value: function(e, t, n) {
                            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "makeRotationX",
                        value: function(e) {
                            var t = Math.cos(e),
                                n = Math.sin(e);
                            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "makeRotationY",
                        value: function(e) {
                            var t = Math.cos(e),
                                n = Math.sin(e);
                            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "makeRotationZ",
                        value: function(e) {
                            var t = Math.cos(e),
                                n = Math.sin(e);
                            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "makeRotationAxis",
                        value: function(e, t) {
                            var n = Math.cos(t),
                                r = Math.sin(t),
                                i = 1 - n,
                                a = e.x,
                                o = e.y,
                                s = e.z,
                                l = i * a,
                                u = i * o;
                            return this.set(l * a + n, l * o - r * s, l * s + r * o, 0, l * o + r * s, u * o + n, u * s - r * a, 0, l * s - r * o, u * s + r * a, i * s * s + n, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "makeScale",
                        value: function(e, t, n) {
                            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "makeShear",
                        value: function(e, t, n, r, i, a) {
                            return this.set(1, n, i, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "compose",
                        value: function(e, t, n) {
                            var r = this.elements,
                                i = t._x,
                                a = t._y,
                                o = t._z,
                                s = t._w,
                                l = i + i,
                                u = a + a,
                                c = o + o,
                                h = i * l,
                                d = i * u,
                                f = i * c,
                                p = a * u,
                                m = a * c,
                                v = o * c,
                                g = s * l,
                                y = s * u,
                                _ = s * c,
                                x = n.x,
                                b = n.y,
                                w = n.z;
                            return r[0] = (1 - (p + v)) * x, r[1] = (d + _) * x, r[2] = (f - y) * x, r[3] = 0, r[4] = (d - _) * b, r[5] = (1 - (h + v)) * b, r[6] = (m + g) * b, r[7] = 0, r[8] = (f + y) * w, r[9] = (m - g) * w, r[10] = (1 - (h + p)) * w, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
                        }
                    }, {
                        key: "decompose",
                        value: function(e, t, n) {
                            var r = this.elements,
                                i = tU.set(r[0], r[1], r[2]).length(),
                                a = tU.set(r[4], r[5], r[6]).length(),
                                o = tU.set(r[8], r[9], r[10]).length();
                            0 > this.determinant() && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], tB.copy(this);
                            var s = 1 / i,
                                l = 1 / a,
                                u = 1 / o;
                            return tB.elements[0] *= s, tB.elements[1] *= s, tB.elements[2] *= s, tB.elements[4] *= l, tB.elements[5] *= l, tB.elements[6] *= l, tB.elements[8] *= u, tB.elements[9] *= u, tB.elements[10] *= u, t.setFromRotationMatrix(tB), n.x = i, n.y = a, n.z = o, this
                        }
                    }, {
                        key: "makePerspective",
                        value: function(e, t, n, r, i, a) {
                            void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                            var o = this.elements;
                            return o[0] = 2 * i / (t - e), o[4] = 0, o[8] = (t + e) / (t - e), o[12] = 0, o[1] = 0, o[5] = 2 * i / (n - r), o[9] = (n + r) / (n - r), o[13] = 0, o[2] = 0, o[6] = 0, o[10] = -(a + i) / (a - i), o[14] = -2 * a * i / (a - i), o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                        }
                    }, {
                        key: "makeOrthographic",
                        value: function(e, t, n, r, i, a) {
                            var o = this.elements,
                                s = 1 / (t - e),
                                l = 1 / (n - r),
                                u = 1 / (a - i);
                            return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -((t + e) * s), o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -((n + r) * l), o[2] = 0, o[6] = 0, o[10] = -2 * u, o[14] = -((a + i) * u), o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                        }
                    }, {
                        key: "equals",
                        value: function(e) {
                            for (var t = this.elements, n = e.elements, r = 0; r < 16; r++)
                                if (t[r] !== n[r]) return !1;
                            return !0
                        }
                    }, {
                        key: "fromArray",
                        value: function(e) {
                            for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = 0; n < 16; n++) this.elements[n] = e[n + t];
                            return this
                        }
                    }, {
                        key: "toArray",
                        value: function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                                n = this.elements;
                            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
                        }
                    }]), e
                }();
            tF.prototype.isMatrix4 = !0;
            var tU = new to,
                tB = new tF,
                tz = new to(0, 0, 0),
                tH = new to(1, 1, 1),
                tV = new to,
                tG = new to,
                tW = new to,
                tj = new tF,
                tq = new ta,
                tX = function() {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.DefaultOrder;
                        (0, k._)(this, e), this._x = t, this._y = n, this._z = r, this._order = i
                    }
                    return (0, A._)(e, [{
                        key: "x",
                        get: function() {
                            return this._x
                        },
                        set: function(e) {
                            this._x = e, this._onChangeCallback()
                        }
                    }, {
                        key: "y",
                        get: function() {
                            return this._y
                        },
                        set: function(e) {
                            this._y = e, this._onChangeCallback()
                        }
                    }, {
                        key: "z",
                        get: function() {
                            return this._z
                        },
                        set: function(e) {
                            this._z = e, this._onChangeCallback()
                        }
                    }, {
                        key: "order",
                        get: function() {
                            return this._order
                        },
                        set: function(e) {
                            this._order = e, this._onChangeCallback()
                        }
                    }, {
                        key: "set",
                        value: function(e, t, n) {
                            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this._order;
                            return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return new this.constructor(this._x, this._y, this._z, this._order)
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
                        }
                    }, {
                        key: "setFromRotationMatrix",
                        value: function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._order,
                                n = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2],
                                r = e.elements,
                                i = r[0],
                                a = r[4],
                                o = r[8],
                                s = r[1],
                                l = r[5],
                                u = r[9],
                                c = r[2],
                                h = r[6],
                                d = r[10];
                            switch (t) {
                                case "XYZ":
                                    this._y = Math.asin(eK(o, -1, 1)), .9999999 > Math.abs(o) ? (this._x = Math.atan2(-u, d), this._z = Math.atan2(-a, i)) : (this._x = Math.atan2(h, l), this._z = 0);
                                    break;
                                case "YXZ":
                                    this._x = Math.asin(-eK(u, -1, 1)), .9999999 > Math.abs(u) ? (this._y = Math.atan2(o, d), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-c, i), this._z = 0);
                                    break;
                                case "ZXY":
                                    this._x = Math.asin(eK(h, -1, 1)), .9999999 > Math.abs(h) ? (this._y = Math.atan2(-c, d), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(s, i));
                                    break;
                                case "ZYX":
                                    this._y = Math.asin(-eK(c, -1, 1)), .9999999 > Math.abs(c) ? (this._x = Math.atan2(h, d), this._z = Math.atan2(s, i)) : (this._x = 0, this._z = Math.atan2(-a, l));
                                    break;
                                case "YZX":
                                    this._z = Math.asin(eK(s, -1, 1)), .9999999 > Math.abs(s) ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-c, i)) : (this._x = 0, this._y = Math.atan2(o, d));
                                    break;
                                case "XZY":
                                    this._z = Math.asin(-eK(a, -1, 1)), .9999999 > Math.abs(a) ? (this._x = Math.atan2(h, l), this._y = Math.atan2(o, i)) : (this._x = Math.atan2(-u, d), this._y = 0);
                                    break;
                                default:
                                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                            }
                            return this._order = t, !0 === n && this._onChangeCallback(), this
                        }
                    }, {
                        key: "setFromQuaternion",
                        value: function(e, t, n) {
                            return tj.makeRotationFromQuaternion(e), this.setFromRotationMatrix(tj, t, n)
                        }
                    }, {
                        key: "setFromVector3",
                        value: function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._order;
                            return this.set(e.x, e.y, e.z, t)
                        }
                    }, {
                        key: "reorder",
                        value: function(e) {
                            return tq.setFromEuler(this), this.setFromQuaternion(tq, e)
                        }
                    }, {
                        key: "equals",
                        value: function(e) {
                            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                        }
                    }, {
                        key: "fromArray",
                        value: function(e) {
                            return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
                        }
                    }, {
                        key: "toArray",
                        value: function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                        }
                    }, {
                        key: "toVector3",
                        value: function(e) {
                            return e ? e.set(this._x, this._y, this._z) : new to(this._x, this._y, this._z)
                        }
                    }, {
                        key: "_onChange",
                        value: function(e) {
                            return this._onChangeCallback = e, this
                        }
                    }, {
                        key: "_onChangeCallback",
                        value: function() {}
                    }]), e
                }();
            tX.prototype.isEuler = !0, tX.DefaultOrder = "XYZ", tX.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
            var tY = function() {
                    function e() {
                        (0, k._)(this, e), this.mask = 1
                    }
                    return (0, A._)(e, [{
                        key: "set",
                        value: function(e) {
                            this.mask = (1 << e | 0) >>> 0
                        }
                    }, {
                        key: "enable",
                        value: function(e) {
                            this.mask |= 1 << e | 0
                        }
                    }, {
                        key: "enableAll",
                        value: function() {
                            this.mask = -1
                        }
                    }, {
                        key: "toggle",
                        value: function(e) {
                            this.mask ^= 1 << e | 0
                        }
                    }, {
                        key: "disable",
                        value: function(e) {
                            this.mask &= ~(1 << e | 0)
                        }
                    }, {
                        key: "disableAll",
                        value: function() {
                            this.mask = 0
                        }
                    }, {
                        key: "test",
                        value: function(e) {
                            return 0 != (this.mask & e.mask)
                        }
                    }, {
                        key: "isEnabled",
                        value: function(e) {
                            return 0 != (this.mask & (1 << e | 0))
                        }
                    }]), e
                }(),
                tJ = 0,
                tZ = new to,
                tK = new ta,
                tQ = new tF,
                t$ = new to,
                t0 = new to,
                t1 = new to,
                t2 = new ta,
                t3 = new to(1, 0, 0),
                t4 = new to(0, 1, 0),
                t5 = new to(0, 0, 1),
                t6 = {
                    type: "added"
                },
                t8 = {
                    type: "removed"
                },
                t7 = function(e) {
                    function t() {
                        (0, k._)(this, t), Object.defineProperty(e = (0, E._)(this, t), "id", {
                            value: tJ++
                        }), e.uuid = eZ(), e.name = "", e.type = "Object3D", e.parent = null, e.children = [], e.up = t.DefaultUp.clone();
                        var e, n = new to,
                            r = new tX,
                            i = new ta,
                            a = new to(1, 1, 1);
                        return r._onChange(function() {
                            i.setFromEuler(r, !1)
                        }), i._onChange(function() {
                            r.setFromQuaternion(i, void 0, !1)
                        }), Object.defineProperties(e, {
                            position: {
                                configurable: !0,
                                enumerable: !0,
                                value: n
                            },
                            rotation: {
                                configurable: !0,
                                enumerable: !0,
                                value: r
                            },
                            quaternion: {
                                configurable: !0,
                                enumerable: !0,
                                value: i
                            },
                            scale: {
                                configurable: !0,
                                enumerable: !0,
                                value: a
                            },
                            modelViewMatrix: {
                                value: new tF
                            },
                            normalMatrix: {
                                value: new e5
                            }
                        }), e.matrix = new tF, e.matrixWorld = new tF, e.matrixAutoUpdate = t.DefaultMatrixAutoUpdate, e.matrixWorldNeedsUpdate = !1, e.layers = new tY, e.visible = !0, e.castShadow = !1, e.receiveShadow = !1, e.frustumCulled = !0, e.renderOrder = 0, e.animations = [], e.userData = {}, e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "onBeforeRender",
                        value: function() {}
                    }, {
                        key: "onAfterRender",
                        value: function() {}
                    }, {
                        key: "applyMatrix4",
                        value: function(e) {
                            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
                        }
                    }, {
                        key: "applyQuaternion",
                        value: function(e) {
                            return this.quaternion.premultiply(e), this
                        }
                    }, {
                        key: "setRotationFromAxisAngle",
                        value: function(e, t) {
                            this.quaternion.setFromAxisAngle(e, t)
                        }
                    }, {
                        key: "setRotationFromEuler",
                        value: function(e) {
                            this.quaternion.setFromEuler(e, !0)
                        }
                    }, {
                        key: "setRotationFromMatrix",
                        value: function(e) {
                            this.quaternion.setFromRotationMatrix(e)
                        }
                    }, {
                        key: "setRotationFromQuaternion",
                        value: function(e) {
                            this.quaternion.copy(e)
                        }
                    }, {
                        key: "rotateOnAxis",
                        value: function(e, t) {
                            return tK.setFromAxisAngle(e, t), this.quaternion.multiply(tK), this
                        }
                    }, {
                        key: "rotateOnWorldAxis",
                        value: function(e, t) {
                            return tK.setFromAxisAngle(e, t), this.quaternion.premultiply(tK), this
                        }
                    }, {
                        key: "rotateX",
                        value: function(e) {
                            return this.rotateOnAxis(t3, e)
                        }
                    }, {
                        key: "rotateY",
                        value: function(e) {
                            return this.rotateOnAxis(t4, e)
                        }
                    }, {
                        key: "rotateZ",
                        value: function(e) {
                            return this.rotateOnAxis(t5, e)
                        }
                    }, {
                        key: "translateOnAxis",
                        value: function(e, t) {
                            return tZ.copy(e).applyQuaternion(this.quaternion), this.position.add(tZ.multiplyScalar(t)), this
                        }
                    }, {
                        key: "translateX",
                        value: function(e) {
                            return this.translateOnAxis(t3, e)
                        }
                    }, {
                        key: "translateY",
                        value: function(e) {
                            return this.translateOnAxis(t4, e)
                        }
                    }, {
                        key: "translateZ",
                        value: function(e) {
                            return this.translateOnAxis(t5, e)
                        }
                    }, {
                        key: "localToWorld",
                        value: function(e) {
                            return e.applyMatrix4(this.matrixWorld)
                        }
                    }, {
                        key: "worldToLocal",
                        value: function(e) {
                            return e.applyMatrix4(tQ.copy(this.matrixWorld).invert())
                        }
                    }, {
                        key: "lookAt",
                        value: function(e, t, n) {
                            e.isVector3 ? t$.copy(e) : t$.set(e, t, n);
                            var r = this.parent;
                            this.updateWorldMatrix(!0, !1), t0.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? tQ.lookAt(t0, t$, this.up) : tQ.lookAt(t$, t0, this.up), this.quaternion.setFromRotationMatrix(tQ), r && (tQ.extractRotation(r.matrixWorld), tK.setFromRotationMatrix(tQ), this.quaternion.premultiply(tK.invert()))
                        }
                    }, {
                        key: "add",
                        value: function(e) {
                            if (arguments.length > 1) {
                                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                                return this
                            }
                            return e === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", e) : e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(t6)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this
                        }
                    }, {
                        key: "remove",
                        value: function(e) {
                            if (arguments.length > 1) {
                                for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                                return this
                            }
                            var n = this.children.indexOf(e);
                            return -1 !== n && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(t8)), this
                        }
                    }, {
                        key: "removeFromParent",
                        value: function() {
                            var e = this.parent;
                            return null !== e && e.remove(this), this
                        }
                    }, {
                        key: "clear",
                        value: function() {
                            for (var e = 0; e < this.children.length; e++) {
                                var t = this.children[e];
                                t.parent = null, t.dispatchEvent(t8)
                            }
                            return this.children.length = 0, this
                        }
                    }, {
                        key: "attach",
                        value: function(e) {
                            return this.updateWorldMatrix(!0, !1), tQ.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), tQ.multiply(e.parent.matrixWorld)), e.applyMatrix4(tQ), this.add(e), e.updateWorldMatrix(!1, !0), this
                        }
                    }, {
                        key: "getObjectById",
                        value: function(e) {
                            return this.getObjectByProperty("id", e)
                        }
                    }, {
                        key: "getObjectByName",
                        value: function(e) {
                            return this.getObjectByProperty("name", e)
                        }
                    }, {
                        key: "getObjectByProperty",
                        value: function(e, t) {
                            if (this[e] === t) return this;
                            for (var n = 0, r = this.children.length; n < r; n++) {
                                var i = this.children[n].getObjectByProperty(e, t);
                                if (void 0 !== i) return i
                            }
                        }
                    }, {
                        key: "getWorldPosition",
                        value: function(e) {
                            return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
                        }
                    }, {
                        key: "getWorldQuaternion",
                        value: function(e) {
                            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(t0, e, t1), e
                        }
                    }, {
                        key: "getWorldScale",
                        value: function(e) {
                            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(t0, t2, e), e
                        }
                    }, {
                        key: "getWorldDirection",
                        value: function(e) {
                            this.updateWorldMatrix(!0, !1);
                            var t = this.matrixWorld.elements;
                            return e.set(t[8], t[9], t[10]).normalize()
                        }
                    }, {
                        key: "raycast",
                        value: function() {}
                    }, {
                        key: "traverse",
                        value: function(e) {
                            e(this);
                            for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverse(e)
                        }
                    }, {
                        key: "traverseVisible",
                        value: function(e) {
                            if (!1 !== this.visible) {
                                e(this);
                                for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e)
                            }
                        }
                    }, {
                        key: "traverseAncestors",
                        value: function(e) {
                            var t = this.parent;
                            null !== t && (e(t), t.traverseAncestors(e))
                        }
                    }, {
                        key: "updateMatrix",
                        value: function() {
                            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                        }
                    }, {
                        key: "updateMatrixWorld",
                        value: function(e) {
                            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                            for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e)
                        }
                    }, {
                        key: "updateWorldMatrix",
                        value: function(e, t) {
                            var n = this.parent;
                            if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t)
                                for (var r = this.children, i = 0, a = r.length; i < a; i++) r[i].updateWorldMatrix(!1, !0)
                        }
                    }, {
                        key: "toJSON",
                        value: function(e) {
                            var t = void 0 === e || "string" == typeof e,
                                n = {};
                            t && (e = {
                                geometries: {},
                                materials: {},
                                textures: {},
                                images: {},
                                shapes: {},
                                skeletons: {},
                                animations: {}
                            }, n.metadata = {
                                version: 4.5,
                                type: "Object",
                                generator: "Object3D.toJSON"
                            });
                            var r = {};

                            function i(t, n) {
                                return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
                            }
                            if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (r.environment = this.environment.toJSON(e).uuid);
                            else if (this.isMesh || this.isLine || this.isPoints) {
                                r.geometry = i(e.geometries, this.geometry);
                                var a = this.geometry.parameters;
                                if (void 0 !== a && void 0 !== a.shapes) {
                                    var o = a.shapes;
                                    if (Array.isArray(o))
                                        for (var s = 0, l = o.length; s < l; s++) {
                                            var u = o[s];
                                            i(e.shapes, u)
                                        } else i(e.shapes, o)
                                }
                            }
                            if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material) {
                                if (Array.isArray(this.material)) {
                                    for (var c = [], h = 0, d = this.material.length; h < d; h++) c.push(i(e.materials, this.material[h]));
                                    r.material = c
                                } else r.material = i(e.materials, this.material)
                            }
                            if (this.children.length > 0) {
                                r.children = [];
                                for (var f = 0; f < this.children.length; f++) r.children.push(this.children[f].toJSON(e).object)
                            }
                            if (this.animations.length > 0) {
                                r.animations = [];
                                for (var p = 0; p < this.animations.length; p++) {
                                    var m = this.animations[p];
                                    r.animations.push(i(e.animations, m))
                                }
                            }
                            if (t) {
                                var v = M(e.geometries),
                                    g = M(e.materials),
                                    y = M(e.textures),
                                    _ = M(e.images),
                                    x = M(e.shapes),
                                    b = M(e.skeletons),
                                    w = M(e.animations);
                                v.length > 0 && (n.geometries = v), g.length > 0 && (n.materials = g), y.length > 0 && (n.textures = y), _.length > 0 && (n.images = _), x.length > 0 && (n.shapes = x), b.length > 0 && (n.skeletons = b), w.length > 0 && (n.animations = w)
                            }
                            return n.object = r, n;

                            function M(e) {
                                var t = [];
                                for (var n in e) {
                                    var r = e[n];
                                    delete r.metadata, t.push(r)
                                }
                                return t
                            }
                        }
                    }, {
                        key: "clone",
                        value: function(e) {
                            return (new this.constructor).copy(this, e)
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            var t = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
                            if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                                for (var n = 0; n < e.children.length; n++) {
                                    var r = e.children[n];
                                    this.add(r.clone())
                                }
                            return this
                        }
                    }]), t
                }(eW);
            t7.DefaultUp = new to(0, 1, 0), t7.DefaultMatrixAutoUpdate = !0, t7.prototype.isObject3D = !0;
            var t9 = new to,
                ne = new to,
                nt = new to,
                nn = new to,
                nr = new to,
                ni = new to,
                na = new to,
                no = new to,
                ns = new to,
                nl = new to,
                nu = function() {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new to,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new to,
                            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new to;
                        (0, k._)(this, e), this.a = t, this.b = n, this.c = r
                    }
                    return (0, A._)(e, [{
                        key: "set",
                        value: function(e, t, n) {
                            return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
                        }
                    }, {
                        key: "setFromPointsAndIndices",
                        value: function(e, t, n, r) {
                            return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
                        }
                    }, {
                        key: "setFromAttributeAndIndices",
                        value: function(e, t, n, r) {
                            return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return (new this.constructor).copy(this)
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                        }
                    }, {
                        key: "getArea",
                        value: function() {
                            return t9.subVectors(this.c, this.b), ne.subVectors(this.a, this.b), .5 * t9.cross(ne).length()
                        }
                    }, {
                        key: "getMidpoint",
                        value: function(e) {
                            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                        }
                    }, {
                        key: "getNormal",
                        value: function(t) {
                            return e.getNormal(this.a, this.b, this.c, t)
                        }
                    }, {
                        key: "getPlane",
                        value: function(e) {
                            return e.setFromCoplanarPoints(this.a, this.b, this.c)
                        }
                    }, {
                        key: "getBarycoord",
                        value: function(t, n) {
                            return e.getBarycoord(t, this.a, this.b, this.c, n)
                        }
                    }, {
                        key: "getUV",
                        value: function(t, n, r, i, a) {
                            return e.getUV(t, this.a, this.b, this.c, n, r, i, a)
                        }
                    }, {
                        key: "containsPoint",
                        value: function(t) {
                            return e.containsPoint(t, this.a, this.b, this.c)
                        }
                    }, {
                        key: "isFrontFacing",
                        value: function(t) {
                            return e.isFrontFacing(this.a, this.b, this.c, t)
                        }
                    }, {
                        key: "intersectsBox",
                        value: function(e) {
                            return e.intersectsTriangle(this)
                        }
                    }, {
                        key: "closestPointToPoint",
                        value: function(e, t) {
                            var n, r, i = this.a,
                                a = this.b,
                                o = this.c;
                            nr.subVectors(a, i), ni.subVectors(o, i), no.subVectors(e, i);
                            var s = nr.dot(no),
                                l = ni.dot(no);
                            if (s <= 0 && l <= 0) return t.copy(i);
                            ns.subVectors(e, a);
                            var u = nr.dot(ns),
                                c = ni.dot(ns);
                            if (u >= 0 && c <= u) return t.copy(a);
                            var h = s * c - u * l;
                            if (h <= 0 && s >= 0 && u <= 0) return n = s / (s - u), t.copy(i).addScaledVector(nr, n);
                            nl.subVectors(e, o);
                            var d = nr.dot(nl),
                                f = ni.dot(nl);
                            if (f >= 0 && d <= f) return t.copy(o);
                            var p = d * l - s * f;
                            if (p <= 0 && l >= 0 && f <= 0) return r = l / (l - f), t.copy(i).addScaledVector(ni, r);
                            var m = u * f - d * c;
                            if (m <= 0 && c - u >= 0 && d - f >= 0) return na.subVectors(o, a), r = (c - u) / (c - u + (d - f)), t.copy(a).addScaledVector(na, r);
                            var v = 1 / (m + p + h);
                            return n = p * v, r = h * v, t.copy(i).addScaledVector(nr, n).addScaledVector(ni, r)
                        }
                    }, {
                        key: "equals",
                        value: function(e) {
                            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                        }
                    }], [{
                        key: "getNormal",
                        value: function(e, t, n, r) {
                            r.subVectors(n, t), t9.subVectors(e, t), r.cross(t9);
                            var i = r.lengthSq();
                            return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
                        }
                    }, {
                        key: "getBarycoord",
                        value: function(e, t, n, r, i) {
                            t9.subVectors(r, t), ne.subVectors(n, t), nt.subVectors(e, t);
                            var a = t9.dot(t9),
                                o = t9.dot(ne),
                                s = t9.dot(nt),
                                l = ne.dot(ne),
                                u = ne.dot(nt),
                                c = a * l - o * o;
                            if (0 === c) return i.set(-2, -1, -1);
                            var h = 1 / c,
                                d = (l * s - o * u) * h,
                                f = (a * u - o * s) * h;
                            return i.set(1 - d - f, f, d)
                        }
                    }, {
                        key: "containsPoint",
                        value: function(e, t, n, r) {
                            return this.getBarycoord(e, t, n, r, nn), nn.x >= 0 && nn.y >= 0 && nn.x + nn.y <= 1
                        }
                    }, {
                        key: "getUV",
                        value: function(e, t, n, r, i, a, o, s) {
                            return this.getBarycoord(e, t, n, r, nn), s.set(0, 0), s.addScaledVector(i, nn.x), s.addScaledVector(a, nn.y), s.addScaledVector(o, nn.z), s
                        }
                    }, {
                        key: "isFrontFacing",
                        value: function(e, t, n, r) {
                            return t9.subVectors(n, t), ne.subVectors(e, t), 0 > t9.cross(ne).dot(r)
                        }
                    }]), e
                }(),
                nc = 0,
                nh = function(e) {
                    function t() {
                        var e;
                        return (0, k._)(this, t), Object.defineProperty(e = (0, E._)(this, t), "id", {
                            value: nc++
                        }), e.uuid = eZ(), e.name = "", e.type = "Material", e.fog = !0, e.blending = 1, e.side = 0, e.vertexColors = !1, e.opacity = 1, e.format = 1023, e.transparent = !1, e.blendSrc = 204, e.blendDst = 205, e.blendEquation = 100, e.blendSrcAlpha = null, e.blendDstAlpha = null, e.blendEquationAlpha = null, e.depthFunc = 3, e.depthTest = !0, e.depthWrite = !0, e.stencilWriteMask = 255, e.stencilFunc = 519, e.stencilRef = 0, e.stencilFuncMask = 255, e.stencilFail = 7680, e.stencilZFail = 7680, e.stencilZPass = 7680, e.stencilWrite = !1, e.clippingPlanes = null, e.clipIntersection = !1, e.clipShadows = !1, e.shadowSide = null, e.colorWrite = !0, e.precision = null, e.polygonOffset = !1, e.polygonOffsetFactor = 0, e.polygonOffsetUnits = 0, e.dithering = !1, e.alphaToCoverage = !1, e.premultipliedAlpha = !1, e.visible = !0, e.toneMapped = !0, e.userData = {}, e.version = 0, e._alphaTest = 0, e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "alphaTest",
                        get: function() {
                            return this._alphaTest
                        },
                        set: function(e) {
                            this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
                        }
                    }, {
                        key: "onBuild",
                        value: function() {}
                    }, {
                        key: "onBeforeRender",
                        value: function() {}
                    }, {
                        key: "onBeforeCompile",
                        value: function() {}
                    }, {
                        key: "customProgramCacheKey",
                        value: function() {
                            return this.onBeforeCompile.toString()
                        }
                    }, {
                        key: "setValues",
                        value: function(e) {
                            if (void 0 !== e)
                                for (var t in e) {
                                    var n = e[t];
                                    if (void 0 === n) {
                                        console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                                        continue
                                    }
                                    if ("shading" === t) {
                                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                                        continue
                                    }
                                    var r = this[t];
                                    void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                                }
                        }
                    }, {
                        key: "toJSON",
                        value: function(e) {
                            var t = void 0 === e || "string" == typeof e;
                            t && (e = {
                                textures: {},
                                images: {}
                            });
                            var n = {
                                metadata: {
                                    version: 4.5,
                                    type: "Material",
                                    generator: "Material.toJSON"
                                }
                            };

                            function r(e) {
                                var t = [];
                                for (var n in e) {
                                    var r = e[n];
                                    delete r.metadata, t.push(r)
                                }
                                return t
                            }
                            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), 1023 !== this.format && (n.format = this.format), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
                                var i = r(e.textures),
                                    a = r(e.images);
                                i.length > 0 && (n.textures = i), a.length > 0 && (n.images = a)
                            }
                            return n
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return (new this.constructor).copy(this)
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.format = e.format, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                            var t = e.clippingPlanes,
                                n = null;
                            if (null !== t) {
                                var r = t.length;
                                n = Array(r);
                                for (var i = 0; i !== r; ++i) n[i] = t[i].clone()
                            }
                            return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                    }, {
                        key: "needsUpdate",
                        set: function(e) {
                            !0 === e && this.version++
                        }
                    }]), t
                }(eW);
            nh.prototype.isMaterial = !0;
            var nd = {
                    aliceblue: 0xf0f8ff,
                    antiquewhite: 0xfaebd7,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 0xf0ffff,
                    beige: 0xf5f5dc,
                    bisque: 0xffe4c4,
                    black: 0,
                    blanchedalmond: 0xffebcd,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 0xa52a2a,
                    burlywood: 0xdeb887,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 0xd2691e,
                    coral: 0xff7f50,
                    cornflowerblue: 6591981,
                    cornsilk: 0xfff8dc,
                    crimson: 0xdc143c,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 0xb8860b,
                    darkgray: 0xa9a9a9,
                    darkgreen: 25600,
                    darkgrey: 0xa9a9a9,
                    darkkhaki: 0xbdb76b,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 0xff8c00,
                    darkorchid: 0x9932cc,
                    darkred: 9109504,
                    darksalmon: 0xe9967a,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 0xff1493,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 0xb22222,
                    floralwhite: 0xfffaf0,
                    forestgreen: 2263842,
                    fuchsia: 0xff00ff,
                    gainsboro: 0xdcdcdc,
                    ghostwhite: 0xf8f8ff,
                    gold: 0xffd700,
                    goldenrod: 0xdaa520,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 0xadff2f,
                    grey: 8421504,
                    honeydew: 0xf0fff0,
                    hotpink: 0xff69b4,
                    indianred: 0xcd5c5c,
                    indigo: 4915330,
                    ivory: 0xfffff0,
                    khaki: 0xf0e68c,
                    lavender: 0xe6e6fa,
                    lavenderblush: 0xfff0f5,
                    lawngreen: 8190976,
                    lemonchiffon: 0xfffacd,
                    lightblue: 0xadd8e6,
                    lightcoral: 0xf08080,
                    lightcyan: 0xe0ffff,
                    lightgoldenrodyellow: 0xfafad2,
                    lightgray: 0xd3d3d3,
                    lightgreen: 9498256,
                    lightgrey: 0xd3d3d3,
                    lightpink: 0xffb6c1,
                    lightsalmon: 0xffa07a,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 0xb0c4de,
                    lightyellow: 0xffffe0,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 0xfaf0e6,
                    magenta: 0xff00ff,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 0xba55d3,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 0xc71585,
                    midnightblue: 1644912,
                    mintcream: 0xf5fffa,
                    mistyrose: 0xffe4e1,
                    moccasin: 0xffe4b5,
                    navajowhite: 0xffdead,
                    navy: 128,
                    oldlace: 0xfdf5e6,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 0xffa500,
                    orangered: 0xff4500,
                    orchid: 0xda70d6,
                    palegoldenrod: 0xeee8aa,
                    palegreen: 0x98fb98,
                    paleturquoise: 0xafeeee,
                    palevioletred: 0xdb7093,
                    papayawhip: 0xffefd5,
                    peachpuff: 0xffdab9,
                    peru: 0xcd853f,
                    pink: 0xffc0cb,
                    plum: 0xdda0dd,
                    powderblue: 0xb0e0e6,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 0xff0000,
                    rosybrown: 0xbc8f8f,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 0xfa8072,
                    sandybrown: 0xf4a460,
                    seagreen: 3050327,
                    seashell: 0xfff5ee,
                    sienna: 0xa0522d,
                    silver: 0xc0c0c0,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 0xfffafa,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 0xd2b48c,
                    teal: 32896,
                    thistle: 0xd8bfd8,
                    tomato: 0xff6347,
                    turquoise: 4251856,
                    violet: 0xee82ee,
                    wheat: 0xf5deb3,
                    white: 0xffffff,
                    whitesmoke: 0xf5f5f5,
                    yellow: 0xffff00,
                    yellowgreen: 0x9acd32
                },
                nf = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                np = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function nm(e, t, n) {
                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
            }

            function nv(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }

            function ng(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            var ny = function() {
                function e(t, n, r) {
                    return (0, k._)(this, e), void 0 === n && void 0 === r ? this.set(t) : this.setRGB(t, n, r)
                }
                return (0, A._)(e, [{
                    key: "set",
                    value: function(e) {
                        return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
                    }
                }, {
                    key: "setScalar",
                    value: function(e) {
                        return this.r = e, this.g = e, this.b = e, this
                    }
                }, {
                    key: "setHex",
                    value: function(e) {
                        return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
                    }
                }, {
                    key: "setRGB",
                    value: function(e, t, n) {
                        return this.r = e, this.g = t, this.b = n, this
                    }
                }, {
                    key: "setHSL",
                    value: function(e, t, n) {
                        if (e = eQ(e, 1), t = eK(t, 0, 1), n = eK(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
                        else {
                            var r = n <= .5 ? n * (1 + t) : n + t - n * t,
                                i = 2 * n - r;
                            this.r = nm(i, r, e + 1 / 3), this.g = nm(i, r, e), this.b = nm(i, r, e - 1 / 3)
                        }
                        return this
                    }
                }, {
                    key: "setStyle",
                    value: function(e) {
                        function t(t) {
                            void 0 !== t && 1 > parseFloat(t) && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                        }
                        if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
                            var n, r, i = n[1],
                                a = n[2];
                            switch (i) {
                                case "rgb":
                                case "rgba":
                                    if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, t(r[4]), this;
                                    if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, t(r[4]), this;
                                    break;
                                case "hsl":
                                case "hsla":
                                    if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
                                        var o = parseFloat(r[1]) / 360,
                                            s = parseInt(r[2], 10) / 100,
                                            l = parseInt(r[3], 10) / 100;
                                        return t(r[4]), this.setHSL(o, s, l)
                                    }
                            }
                        } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                            var u = n[1],
                                c = u.length;
                            if (3 === c) return this.r = parseInt(u.charAt(0) + u.charAt(0), 16) / 255, this.g = parseInt(u.charAt(1) + u.charAt(1), 16) / 255, this.b = parseInt(u.charAt(2) + u.charAt(2), 16) / 255, this;
                            if (6 === c) return this.r = parseInt(u.charAt(0) + u.charAt(1), 16) / 255, this.g = parseInt(u.charAt(2) + u.charAt(3), 16) / 255, this.b = parseInt(u.charAt(4) + u.charAt(5), 16) / 255, this
                        }
                        return e && e.length > 0 ? this.setColorName(e) : this
                    }
                }, {
                    key: "setColorName",
                    value: function(e) {
                        var t = nd[e.toLowerCase()];
                        return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return new this.constructor(this.r, this.g, this.b)
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return this.r = e.r, this.g = e.g, this.b = e.b, this
                    }
                }, {
                    key: "copySRGBToLinear",
                    value: function(e) {
                        return this.r = nv(e.r), this.g = nv(e.g), this.b = nv(e.b), this
                    }
                }, {
                    key: "copyLinearToSRGB",
                    value: function(e) {
                        return this.r = ng(e.r), this.g = ng(e.g), this.b = ng(e.b), this
                    }
                }, {
                    key: "convertSRGBToLinear",
                    value: function() {
                        return this.copySRGBToLinear(this), this
                    }
                }, {
                    key: "convertLinearToSRGB",
                    value: function() {
                        return this.copyLinearToSRGB(this), this
                    }
                }, {
                    key: "getHex",
                    value: function() {
                        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                    }
                }, {
                    key: "getHexString",
                    value: function() {
                        return ("000000" + this.getHex().toString(16)).slice(-6)
                    }
                }, {
                    key: "getHSL",
                    value: function(e) {
                        var t, n, r = this.r,
                            i = this.g,
                            a = this.b,
                            o = Math.max(r, i, a),
                            s = Math.min(r, i, a),
                            l = (s + o) / 2;
                        if (s === o) t = 0, n = 0;
                        else {
                            var u = o - s;
                            switch (n = l <= .5 ? u / (o + s) : u / (2 - o - s), o) {
                                case r:
                                    t = (i - a) / u + (i < a ? 6 : 0);
                                    break;
                                case i:
                                    t = (a - r) / u + 2;
                                    break;
                                case a:
                                    t = (r - i) / u + 4
                            }
                            t /= 6
                        }
                        return e.h = t, e.s = n, e.l = l, e
                    }
                }, {
                    key: "getStyle",
                    value: function() {
                        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                    }
                }, {
                    key: "offsetHSL",
                    value: function(e, t, n) {
                        return this.getHSL(nf), nf.h += e, nf.s += t, nf.l += n, this.setHSL(nf.h, nf.s, nf.l), this
                    }
                }, {
                    key: "add",
                    value: function(e) {
                        return this.r += e.r, this.g += e.g, this.b += e.b, this
                    }
                }, {
                    key: "addColors",
                    value: function(e, t) {
                        return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                    }
                }, {
                    key: "addScalar",
                    value: function(e) {
                        return this.r += e, this.g += e, this.b += e, this
                    }
                }, {
                    key: "sub",
                    value: function(e) {
                        return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
                    }
                }, {
                    key: "multiply",
                    value: function(e) {
                        return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                    }
                }, {
                    key: "multiplyScalar",
                    value: function(e) {
                        return this.r *= e, this.g *= e, this.b *= e, this
                    }
                }, {
                    key: "lerp",
                    value: function(e, t) {
                        return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                    }
                }, {
                    key: "lerpColors",
                    value: function(e, t, n) {
                        return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
                    }
                }, {
                    key: "lerpHSL",
                    value: function(e, t) {
                        this.getHSL(nf), e.getHSL(np);
                        var n = e$(nf.h, np.h, t),
                            r = e$(nf.s, np.s, t),
                            i = e$(nf.l, np.l, t);
                        return this.setHSL(n, r, i), this
                    }
                }, {
                    key: "equals",
                    value: function(e) {
                        return e.r === this.r && e.g === this.g && e.b === this.b
                    }
                }, {
                    key: "fromArray",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
                    }
                }, {
                    key: "toArray",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                    }
                }, {
                    key: "fromBufferAttribute",
                    value: function(e, t) {
                        return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                    }
                }, {
                    key: "toJSON",
                    value: function() {
                        return this.getHex()
                    }
                }]), e
            }();
            ny.NAMES = nd, ny.prototype.isColor = !0, ny.prototype.r = 1, ny.prototype.g = 1, ny.prototype.b = 1;
            var n_ = function(e) {
                function t(e) {
                    var n;
                    return (0, k._)(this, t), (n = (0, E._)(this, t)).type = "MeshBasicMaterial", n.color = new ny(0xffffff), n.map = null, n.lightMap = null, n.lightMapIntensity = 1, n.aoMap = null, n.aoMapIntensity = 1, n.specularMap = null, n.alphaMap = null, n.envMap = null, n.combine = 0, n.reflectivity = 1, n.refractionRatio = .98, n.wireframe = !1, n.wireframeLinewidth = 1, n.wireframeLinecap = "round", n.wireframeLinejoin = "round", n.setValues(e), n
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
                    }
                }]), t
            }(nh);
            n_.prototype.isMeshBasicMaterial = !0;
            var nx = new to,
                nb = new e4,
                nw = function() {
                    function e(t, n, r) {
                        if ((0, k._)(this, e), Array.isArray(t)) throw TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                        this.name = "", this.array = t, this.itemSize = n, this.count = void 0 !== t ? t.length / n : 0, this.normalized = !0 === r, this.usage = 35044, this.updateRange = {
                            offset: 0,
                            count: -1
                        }, this.version = 0
                    }
                    return (0, A._)(e, [{
                        key: "onUploadCallback",
                        value: function() {}
                    }, {
                        key: "needsUpdate",
                        set: function(e) {
                            !0 === e && this.version++
                        }
                    }, {
                        key: "setUsage",
                        value: function(e) {
                            return this.usage = e, this
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
                        }
                    }, {
                        key: "copyAt",
                        value: function(e, t, n) {
                            e *= this.itemSize, n *= t.itemSize;
                            for (var r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
                            return this
                        }
                    }, {
                        key: "copyArray",
                        value: function(e) {
                            return this.array.set(e), this
                        }
                    }, {
                        key: "copyColorsArray",
                        value: function(e) {
                            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                                var a = e[r];
                                void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), a = new ny), t[n++] = a.r, t[n++] = a.g, t[n++] = a.b
                            }
                            return this
                        }
                    }, {
                        key: "copyVector2sArray",
                        value: function(e) {
                            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                                var a = e[r];
                                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), a = new e4), t[n++] = a.x, t[n++] = a.y
                            }
                            return this
                        }
                    }, {
                        key: "copyVector3sArray",
                        value: function(e) {
                            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                                var a = e[r];
                                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), a = new to), t[n++] = a.x, t[n++] = a.y, t[n++] = a.z
                            }
                            return this
                        }
                    }, {
                        key: "copyVector4sArray",
                        value: function(e) {
                            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                                var a = e[r];
                                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), a = new tn), t[n++] = a.x, t[n++] = a.y, t[n++] = a.z, t[n++] = a.w
                            }
                            return this
                        }
                    }, {
                        key: "applyMatrix3",
                        value: function(e) {
                            if (2 === this.itemSize)
                                for (var t = 0, n = this.count; t < n; t++) nb.fromBufferAttribute(this, t), nb.applyMatrix3(e), this.setXY(t, nb.x, nb.y);
                            else if (3 === this.itemSize)
                                for (var r = 0, i = this.count; r < i; r++) nx.fromBufferAttribute(this, r), nx.applyMatrix3(e), this.setXYZ(r, nx.x, nx.y, nx.z);
                            return this
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function(e) {
                            for (var t = 0, n = this.count; t < n; t++) nx.x = this.getX(t), nx.y = this.getY(t), nx.z = this.getZ(t), nx.applyMatrix4(e), this.setXYZ(t, nx.x, nx.y, nx.z);
                            return this
                        }
                    }, {
                        key: "applyNormalMatrix",
                        value: function(e) {
                            for (var t = 0, n = this.count; t < n; t++) nx.x = this.getX(t), nx.y = this.getY(t), nx.z = this.getZ(t), nx.applyNormalMatrix(e), this.setXYZ(t, nx.x, nx.y, nx.z);
                            return this
                        }
                    }, {
                        key: "transformDirection",
                        value: function(e) {
                            for (var t = 0, n = this.count; t < n; t++) nx.x = this.getX(t), nx.y = this.getY(t), nx.z = this.getZ(t), nx.transformDirection(e), this.setXYZ(t, nx.x, nx.y, nx.z);
                            return this
                        }
                    }, {
                        key: "set",
                        value: function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return this.array.set(e, t), this
                        }
                    }, {
                        key: "getX",
                        value: function(e) {
                            return this.array[e * this.itemSize]
                        }
                    }, {
                        key: "setX",
                        value: function(e, t) {
                            return this.array[e * this.itemSize] = t, this
                        }
                    }, {
                        key: "getY",
                        value: function(e) {
                            return this.array[e * this.itemSize + 1]
                        }
                    }, {
                        key: "setY",
                        value: function(e, t) {
                            return this.array[e * this.itemSize + 1] = t, this
                        }
                    }, {
                        key: "getZ",
                        value: function(e) {
                            return this.array[e * this.itemSize + 2]
                        }
                    }, {
                        key: "setZ",
                        value: function(e, t) {
                            return this.array[e * this.itemSize + 2] = t, this
                        }
                    }, {
                        key: "getW",
                        value: function(e) {
                            return this.array[e * this.itemSize + 3]
                        }
                    }, {
                        key: "setW",
                        value: function(e, t) {
                            return this.array[e * this.itemSize + 3] = t, this
                        }
                    }, {
                        key: "setXY",
                        value: function(e, t, n) {
                            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
                        }
                    }, {
                        key: "setXYZ",
                        value: function(e, t, n, r) {
                            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
                        }
                    }, {
                        key: "setXYZW",
                        value: function(e, t, n, r, i) {
                            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
                        }
                    }, {
                        key: "onUpload",
                        value: function(e) {
                            return this.onUploadCallback = e, this
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return new this.constructor(this.array, this.itemSize).copy(this)
                        }
                    }, {
                        key: "toJSON",
                        value: function() {
                            var e = {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: Array.prototype.slice.call(this.array),
                                normalized: this.normalized
                            };
                            return "" !== this.name && (e.name = this.name), 35044 !== this.usage && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e
                        }
                    }]), e
                }();
            nw.prototype.isBufferAttribute = !0;
            var nM = function(e) {
                    function t(e, n, r) {
                        return (0, k._)(this, t), (0, E._)(this, t, [new Uint16Array(e), n, r])
                    }
                    return (0, P._)(t, e), t
                }(nw),
                nS = function(e) {
                    function t(e, n, r) {
                        return (0, k._)(this, t), (0, E._)(this, t, [new Uint32Array(e), n, r])
                    }
                    return (0, P._)(t, e), t
                }(nw);
            (function(e) {
                function t(e, n, r) {
                    return (0, k._)(this, t), (0, E._)(this, t, [new Uint16Array(e), n, r])
                }
                return (0, P._)(t, e), t
            })(nw).prototype.isFloat16BufferAttribute = !0;
            var nT = function(e) {
                    function t(e, n, r) {
                        return (0, k._)(this, t), (0, E._)(this, t, [new Float32Array(e), n, r])
                    }
                    return (0, P._)(t, e), t
                }(nw),
                nE = 0,
                nk = new tF,
                nA = new t7,
                nR = new to,
                nC = new tu,
                nL = new tu,
                nP = new to,
                nI = function(e) {
                    function t() {
                        var e;
                        return (0, k._)(this, t), Object.defineProperty(e = (0, E._)(this, t), "id", {
                            value: nE++
                        }), e.uuid = eZ(), e.name = "", e.type = "BufferGeometry", e.index = null, e.attributes = {}, e.morphAttributes = {}, e.morphTargetsRelative = !1, e.groups = [], e.boundingBox = null, e.boundingSphere = null, e.drawRange = {
                            start: 0,
                            count: 1 / 0
                        }, e.userData = {}, e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "getIndex",
                        value: function() {
                            return this.index
                        }
                    }, {
                        key: "setIndex",
                        value: function(e) {
                            return Array.isArray(e) ? this.index = new(e6(e) > 65535 ? nS : nM)(e, 1) : this.index = e, this
                        }
                    }, {
                        key: "getAttribute",
                        value: function(e) {
                            return this.attributes[e]
                        }
                    }, {
                        key: "setAttribute",
                        value: function(e, t) {
                            return this.attributes[e] = t, this
                        }
                    }, {
                        key: "deleteAttribute",
                        value: function(e) {
                            return delete this.attributes[e], this
                        }
                    }, {
                        key: "hasAttribute",
                        value: function(e) {
                            return void 0 !== this.attributes[e]
                        }
                    }, {
                        key: "addGroup",
                        value: function(e, t) {
                            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                            this.groups.push({
                                start: e,
                                count: t,
                                materialIndex: n
                            })
                        }
                    }, {
                        key: "clearGroups",
                        value: function() {
                            this.groups = []
                        }
                    }, {
                        key: "setDrawRange",
                        value: function(e, t) {
                            this.drawRange.start = e, this.drawRange.count = t
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function(e) {
                            var t = this.attributes.position;
                            void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
                            var n = this.attributes.normal;
                            if (void 0 !== n) {
                                var r = (new e5).getNormalMatrix(e);
                                n.applyNormalMatrix(r), n.needsUpdate = !0
                            }
                            var i = this.attributes.tangent;
                            return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                        }
                    }, {
                        key: "applyQuaternion",
                        value: function(e) {
                            return nk.makeRotationFromQuaternion(e), this.applyMatrix4(nk), this
                        }
                    }, {
                        key: "rotateX",
                        value: function(e) {
                            return nk.makeRotationX(e), this.applyMatrix4(nk), this
                        }
                    }, {
                        key: "rotateY",
                        value: function(e) {
                            return nk.makeRotationY(e), this.applyMatrix4(nk), this
                        }
                    }, {
                        key: "rotateZ",
                        value: function(e) {
                            return nk.makeRotationZ(e), this.applyMatrix4(nk), this
                        }
                    }, {
                        key: "translate",
                        value: function(e, t, n) {
                            return nk.makeTranslation(e, t, n), this.applyMatrix4(nk), this
                        }
                    }, {
                        key: "scale",
                        value: function(e, t, n) {
                            return nk.makeScale(e, t, n), this.applyMatrix4(nk), this
                        }
                    }, {
                        key: "lookAt",
                        value: function(e) {
                            return nA.lookAt(e), nA.updateMatrix(), this.applyMatrix4(nA.matrix), this
                        }
                    }, {
                        key: "center",
                        value: function() {
                            return this.computeBoundingBox(), this.boundingBox.getCenter(nR).negate(), this.translate(nR.x, nR.y, nR.z), this
                        }
                    }, {
                        key: "setFromPoints",
                        value: function(e) {
                            for (var t = [], n = 0, r = e.length; n < r; n++) {
                                var i = e[n];
                                t.push(i.x, i.y, i.z || 0)
                            }
                            return this.setAttribute("position", new nT(t, 3)), this
                        }
                    }, {
                        key: "computeBoundingBox",
                        value: function() {
                            null === this.boundingBox && (this.boundingBox = new tu);
                            var e = this.attributes.position,
                                t = this.morphAttributes.position;
                            if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new to(-1 / 0, -1 / 0, -1 / 0), new to(1 / 0, 1 / 0, 1 / 0));
                            if (void 0 !== e) {
                                if (this.boundingBox.setFromBufferAttribute(e), t)
                                    for (var n = 0, r = t.length; n < r; n++) {
                                        var i = t[n];
                                        nC.setFromBufferAttribute(i), this.morphTargetsRelative ? (nP.addVectors(this.boundingBox.min, nC.min), this.boundingBox.expandByPoint(nP), nP.addVectors(this.boundingBox.max, nC.max), this.boundingBox.expandByPoint(nP)) : (this.boundingBox.expandByPoint(nC.min), this.boundingBox.expandByPoint(nC.max))
                                    }
                            } else this.boundingBox.makeEmpty();
                            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                        }
                    }, {
                        key: "computeBoundingSphere",
                        value: function() {
                            null === this.boundingSphere && (this.boundingSphere = new tA);
                            var e = this.attributes.position,
                                t = this.morphAttributes.position;
                            if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new to, 1 / 0);
                            if (e) {
                                var n = this.boundingSphere.center;
                                if (nC.setFromBufferAttribute(e), t)
                                    for (var r = 0, i = t.length; r < i; r++) {
                                        var a = t[r];
                                        nL.setFromBufferAttribute(a), this.morphTargetsRelative ? (nP.addVectors(nC.min, nL.min), nC.expandByPoint(nP), nP.addVectors(nC.max, nL.max), nC.expandByPoint(nP)) : (nC.expandByPoint(nL.min), nC.expandByPoint(nL.max))
                                    }
                                nC.getCenter(n);
                                for (var o = 0, s = 0, l = e.count; s < l; s++) nP.fromBufferAttribute(e, s), o = Math.max(o, n.distanceToSquared(nP));
                                if (t)
                                    for (var u = 0, c = t.length; u < c; u++)
                                        for (var h = t[u], d = this.morphTargetsRelative, f = 0, p = h.count; f < p; f++) nP.fromBufferAttribute(h, f), d && (nR.fromBufferAttribute(e, f), nP.add(nR)), o = Math.max(o, n.distanceToSquared(nP));
                                this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                            }
                        }
                    }, {
                        key: "computeTangents",
                        value: function() {
                            var e = this.index,
                                t = this.attributes;
                            if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                            var n = e.array,
                                r = t.position.array,
                                i = t.normal.array,
                                a = t.uv.array,
                                o = r.length / 3;
                            void 0 === t.tangent && this.setAttribute("tangent", new nw(new Float32Array(4 * o), 4));
                            for (var s = t.tangent.array, l = [], u = [], c = 0; c < o; c++) l[c] = new to, u[c] = new to;
                            var h = new to,
                                d = new to,
                                f = new to,
                                p = new e4,
                                m = new e4,
                                v = new e4,
                                g = new to,
                                y = new to,
                                _ = this.groups;
                            0 === _.length && (_ = [{
                                start: 0,
                                count: n.length
                            }]);
                            for (var x = 0, b = _.length; x < b; ++x)
                                for (var w = _[x], M = w.start, S = M, T = M + w.count; S < T; S += 3) ! function(e, t, n) {
                                    h.fromArray(r, 3 * e), d.fromArray(r, 3 * t), f.fromArray(r, 3 * n), p.fromArray(a, 2 * e), m.fromArray(a, 2 * t), v.fromArray(a, 2 * n), d.sub(h), f.sub(h), m.sub(p), v.sub(p);
                                    var i = 1 / (m.x * v.y - v.x * m.y);
                                    isFinite(i) && (g.copy(d).multiplyScalar(v.y).addScaledVector(f, -m.y).multiplyScalar(i), y.copy(f).multiplyScalar(m.x).addScaledVector(d, -v.x).multiplyScalar(i), l[e].add(g), l[t].add(g), l[n].add(g), u[e].add(y), u[t].add(y), u[n].add(y))
                                }(n[S + 0], n[S + 1], n[S + 2]);
                            var E = new to,
                                k = new to,
                                A = new to,
                                R = new to;

                            function C(e) {
                                A.fromArray(i, 3 * e), R.copy(A);
                                var t = l[e];
                                E.copy(t), E.sub(A.multiplyScalar(A.dot(t))).normalize(), k.crossVectors(R, t);
                                var n = 0 > k.dot(u[e]) ? -1 : 1;
                                s[4 * e] = E.x, s[4 * e + 1] = E.y, s[4 * e + 2] = E.z, s[4 * e + 3] = n
                            }
                            for (var L = 0, P = _.length; L < P; ++L)
                                for (var I = _[L], D = I.start, O = D, N = D + I.count; O < N; O += 3) C(n[O + 0]), C(n[O + 1]), C(n[O + 2])
                        }
                    }, {
                        key: "computeVertexNormals",
                        value: function() {
                            var e = this.index,
                                t = this.getAttribute("position");
                            if (void 0 !== t) {
                                var n = this.getAttribute("normal");
                                if (void 0 === n) n = new nw(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
                                else
                                    for (var r = 0, i = n.count; r < i; r++) n.setXYZ(r, 0, 0, 0);
                                var a = new to,
                                    o = new to,
                                    s = new to,
                                    l = new to,
                                    u = new to,
                                    c = new to,
                                    h = new to,
                                    d = new to;
                                if (e)
                                    for (var f = 0, p = e.count; f < p; f += 3) {
                                        var m = e.getX(f + 0),
                                            v = e.getX(f + 1),
                                            g = e.getX(f + 2);
                                        a.fromBufferAttribute(t, m), o.fromBufferAttribute(t, v), s.fromBufferAttribute(t, g), h.subVectors(s, o), d.subVectors(a, o), h.cross(d), l.fromBufferAttribute(n, m), u.fromBufferAttribute(n, v), c.fromBufferAttribute(n, g), l.add(h), u.add(h), c.add(h), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(v, u.x, u.y, u.z), n.setXYZ(g, c.x, c.y, c.z)
                                    } else
                                        for (var y = 0, _ = t.count; y < _; y += 3) a.fromBufferAttribute(t, y + 0), o.fromBufferAttribute(t, y + 1), s.fromBufferAttribute(t, y + 2), h.subVectors(s, o), d.subVectors(a, o), h.cross(d), n.setXYZ(y + 0, h.x, h.y, h.z), n.setXYZ(y + 1, h.x, h.y, h.z), n.setXYZ(y + 2, h.x, h.y, h.z);
                                this.normalizeNormals(), n.needsUpdate = !0
                            }
                        }
                    }, {
                        key: "merge",
                        value: function(e, t) {
                            if (!e || !e.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
                            void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                            var n = this.attributes;
                            for (var r in n)
                                if (void 0 !== e.attributes[r])
                                    for (var i = n[r].array, a = e.attributes[r], o = a.array, s = a.itemSize * t, l = Math.min(o.length, i.length - s), u = 0, c = s; u < l; u++, c++) i[c] = o[u];
                            return this
                        }
                    }, {
                        key: "normalizeNormals",
                        value: function() {
                            for (var e = this.attributes.normal, t = 0, n = e.count; t < n; t++) nP.fromBufferAttribute(e, t), nP.normalize(), e.setXYZ(t, nP.x, nP.y, nP.z)
                        }
                    }, {
                        key: "toNonIndexed",
                        value: function() {
                            function e(e, t) {
                                for (var n = e.array, r = e.itemSize, i = e.normalized, a = new n.constructor(t.length * r), o = 0, s = 0, l = 0, u = t.length; l < u; l++) {
                                    o = e.isInterleavedBufferAttribute ? t[l] * e.data.stride + e.offset : t[l] * r;
                                    for (var c = 0; c < r; c++) a[s++] = n[o++]
                                }
                                return new nw(a, r, i)
                            }
                            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                            var n = new t,
                                r = this.index.array,
                                i = this.attributes;
                            for (var a in i) {
                                var o = e(i[a], r);
                                n.setAttribute(a, o)
                            }
                            var s = this.morphAttributes;
                            for (var l in s) {
                                for (var u = [], c = s[l], h = 0, d = c.length; h < d; h++) {
                                    var f = e(c[h], r);
                                    u.push(f)
                                }
                                n.morphAttributes[l] = u
                            }
                            n.morphTargetsRelative = this.morphTargetsRelative;
                            for (var p = this.groups, m = 0, v = p.length; m < v; m++) {
                                var g = p[m];
                                n.addGroup(g.start, g.count, g.materialIndex)
                            }
                            return n
                        }
                    }, {
                        key: "toJSON",
                        value: function() {
                            var e = {
                                metadata: {
                                    version: 4.5,
                                    type: "BufferGeometry",
                                    generator: "BufferGeometry.toJSON"
                                }
                            };
                            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                                var t = this.parameters;
                                for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                                return e
                            }
                            e.data = {
                                attributes: {}
                            };
                            var r = this.index;
                            null !== r && (e.data.index = {
                                type: r.array.constructor.name,
                                array: Array.prototype.slice.call(r.array)
                            });
                            var i = this.attributes;
                            for (var a in i) {
                                var o = i[a];
                                e.data.attributes[a] = o.toJSON(e.data)
                            }
                            var s = {},
                                l = !1;
                            for (var u in this.morphAttributes) {
                                for (var c = this.morphAttributes[u], h = [], d = 0, f = c.length; d < f; d++) {
                                    var p = c[d];
                                    h.push(p.toJSON(e.data))
                                }
                                h.length > 0 && (s[u] = h, l = !0)
                            }
                            l && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
                            var m = this.groups;
                            m.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(m)));
                            var v = this.boundingSphere;
                            return null !== v && (e.data.boundingSphere = {
                                center: v.center.toArray(),
                                radius: v.radius
                            }), e
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return (new this.constructor).copy(this)
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                            var t = {};
                            this.name = e.name;
                            var n = e.index;
                            null !== n && this.setIndex(n.clone(t));
                            var r = e.attributes;
                            for (var i in r) {
                                var a = r[i];
                                this.setAttribute(i, a.clone(t))
                            }
                            var o = e.morphAttributes;
                            for (var s in o) {
                                for (var l = [], u = o[s], c = 0, h = u.length; c < h; c++) l.push(u[c].clone(t));
                                this.morphAttributes[s] = l
                            }
                            this.morphTargetsRelative = e.morphTargetsRelative;
                            for (var d = e.groups, f = 0, p = d.length; f < p; f++) {
                                var m = d[f];
                                this.addGroup(m.start, m.count, m.materialIndex)
                            }
                            var v = e.boundingBox;
                            null !== v && (this.boundingBox = v.clone());
                            var g = e.boundingSphere;
                            return null !== g && (this.boundingSphere = g.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)), this
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                    }]), t
                }(eW);
            nI.prototype.isBufferGeometry = !0;
            var nD = new tF,
                nO = new tN,
                nN = new tA,
                nF = new to,
                nU = new to,
                nB = new to,
                nz = new to,
                nH = new to,
                nV = new to,
                nG = new to,
                nW = new to,
                nj = new to,
                nq = new e4,
                nX = new e4,
                nY = new e4,
                nJ = new to,
                nZ = new to,
                nK = function(e) {
                    function t() {
                        var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new nI,
                            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new n_;
                        return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "Mesh", e.geometry = n, e.material = r, e.updateMorphTargets(), e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
                        }
                    }, {
                        key: "updateMorphTargets",
                        value: function() {
                            var e = this.geometry;
                            if (e.isBufferGeometry) {
                                var t = e.morphAttributes,
                                    n = Object.keys(t);
                                if (n.length > 0) {
                                    var r = t[n[0]];
                                    if (void 0 !== r) {
                                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                        for (var i = 0, a = r.length; i < a; i++) {
                                            var o = r[i].name || String(i);
                                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = i
                                        }
                                    }
                                }
                            } else {
                                var s = e.morphTargets;
                                void 0 !== s && s.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                            }
                        }
                    }, {
                        key: "raycast",
                        value: function(e, t) {
                            var n, r = this.geometry,
                                i = this.material,
                                a = this.matrixWorld;
                            if (void 0 !== i && (null === r.boundingSphere && r.computeBoundingSphere(), nN.copy(r.boundingSphere), nN.applyMatrix4(a), !1 !== e.ray.intersectsSphere(nN)) && (nD.copy(a).invert(), nO.copy(e.ray).applyMatrix4(nD), null === r.boundingBox || !1 !== nO.intersectsBox(r.boundingBox))) {
                                if (r.isBufferGeometry) {
                                    var o = r.index,
                                        s = r.attributes.position,
                                        l = r.morphAttributes.position,
                                        u = r.morphTargetsRelative,
                                        c = r.attributes.uv,
                                        h = r.attributes.uv2,
                                        d = r.groups,
                                        f = r.drawRange;
                                    if (null !== o) {
                                        if (Array.isArray(i))
                                            for (var p = 0, m = d.length; p < m; p++)
                                                for (var v = d[p], g = i[v.materialIndex], y = Math.max(v.start, f.start), _ = Math.min(o.count, Math.min(v.start + v.count, f.start + f.count)); y < _; y += 3)(n = nQ(this, g, e, nO, s, l, u, c, h, o.getX(y), o.getX(y + 1), o.getX(y + 2))) && (n.faceIndex = Math.floor(y / 3), n.face.materialIndex = v.materialIndex, t.push(n));
                                        else
                                            for (var x = Math.max(0, f.start), b = Math.min(o.count, f.start + f.count); x < b; x += 3)(n = nQ(this, i, e, nO, s, l, u, c, h, o.getX(x), o.getX(x + 1), o.getX(x + 2))) && (n.faceIndex = Math.floor(x / 3), t.push(n))
                                    } else if (void 0 !== s) {
                                        if (Array.isArray(i))
                                            for (var w = 0, M = d.length; w < M; w++)
                                                for (var S = d[w], T = i[S.materialIndex], E = Math.max(S.start, f.start), k = Math.min(s.count, Math.min(S.start + S.count, f.start + f.count)); E < k; E += 3)(n = nQ(this, T, e, nO, s, l, u, c, h, E, E + 1, E + 2)) && (n.faceIndex = Math.floor(E / 3), n.face.materialIndex = S.materialIndex, t.push(n));
                                        else
                                            for (var A = Math.max(0, f.start), R = Math.min(s.count, f.start + f.count); A < R; A += 3)(n = nQ(this, i, e, nO, s, l, u, c, h, A, A + 1, A + 2)) && (n.faceIndex = Math.floor(A / 3), t.push(n))
                                    }
                                } else r.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                            }
                        }
                    }]), t
                }(t7);

            function nQ(e, t, n, r, i, a, o, s, l, u, c, h) {
                nF.fromBufferAttribute(i, u), nU.fromBufferAttribute(i, c), nB.fromBufferAttribute(i, h);
                var d = e.morphTargetInfluences;
                if (a && d) {
                    nG.set(0, 0, 0), nW.set(0, 0, 0), nj.set(0, 0, 0);
                    for (var f = 0, p = a.length; f < p; f++) {
                        var m = d[f],
                            v = a[f];
                        0 !== m && (nz.fromBufferAttribute(v, u), nH.fromBufferAttribute(v, c), nV.fromBufferAttribute(v, h), o ? (nG.addScaledVector(nz, m), nW.addScaledVector(nH, m), nj.addScaledVector(nV, m)) : (nG.addScaledVector(nz.sub(nF), m), nW.addScaledVector(nH.sub(nU), m), nj.addScaledVector(nV.sub(nB), m)))
                    }
                    nF.add(nG), nU.add(nW), nB.add(nj)
                }
                e.isSkinnedMesh && (e.boneTransform(u, nF), e.boneTransform(c, nU), e.boneTransform(h, nB));
                var g = function(e, t, n, r, i, a, o, s) {
                    if (null === (1 === t.side ? r.intersectTriangle(o, a, i, !0, s) : r.intersectTriangle(i, a, o, 2 !== t.side, s))) return null;
                    nZ.copy(s), nZ.applyMatrix4(e.matrixWorld);
                    var l = n.ray.origin.distanceTo(nZ);
                    return l < n.near || l > n.far ? null : {
                        distance: l,
                        point: nZ.clone(),
                        object: e
                    }
                }(e, t, n, r, nF, nU, nB, nJ);
                if (g) {
                    s && (nq.fromBufferAttribute(s, u), nX.fromBufferAttribute(s, c), nY.fromBufferAttribute(s, h), g.uv = nu.getUV(nJ, nF, nU, nB, nq, nX, nY, new e4)), l && (nq.fromBufferAttribute(l, u), nX.fromBufferAttribute(l, c), nY.fromBufferAttribute(l, h), g.uv2 = nu.getUV(nJ, nF, nU, nB, nq, nX, nY, new e4));
                    var y = {
                        a: u,
                        b: c,
                        c: h,
                        normal: new to,
                        materialIndex: 0
                    };
                    nu.getNormal(nF, nU, nB, y.normal), g.face = y
                }
                return g
            }
            nK.prototype.isMesh = !0;
            var n$ = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                        a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                        o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1,
                        s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
                    (0, k._)(this, t), (e = (0, E._)(this, t)).type = "BoxGeometry", e.parameters = {
                        width: n,
                        height: r,
                        depth: i,
                        widthSegments: a,
                        heightSegments: o,
                        depthSegments: s
                    }, a = Math.floor(a), o = Math.floor(o);
                    var l = [],
                        u = [],
                        c = [],
                        h = [],
                        d = 0,
                        f = 0;

                    function p(t, n, r, i, a, o, s, p, m, v, g) {
                        for (var y = o / m, _ = s / v, x = o / 2, b = s / 2, w = p / 2, M = m + 1, S = v + 1, T = 0, E = 0, k = new to, A = 0; A < S; A++)
                            for (var R = A * _ - b, C = 0; C < M; C++) {
                                var L = C * y - x;
                                k[t] = L * i, k[n] = R * a, k[r] = w, u.push(k.x, k.y, k.z), k[t] = 0, k[n] = 0, k[r] = p > 0 ? 1 : -1, c.push(k.x, k.y, k.z), h.push(C / m), h.push(1 - A / v), T += 1
                            }
                        for (var P = 0; P < v; P++)
                            for (var I = 0; I < m; I++) {
                                var D = d + I + M * P,
                                    O = d + I + M * (P + 1),
                                    N = d + (I + 1) + M * (P + 1),
                                    F = d + (I + 1) + M * P;
                                l.push(D, O, F), l.push(O, N, F), E += 6
                            }
                        e.addGroup(f, E, g), f += E, d += T
                    }
                    return p("z", "y", "x", -1, -1, i, r, n, s = Math.floor(s), o, 0), p("z", "y", "x", 1, -1, i, r, -n, s, o, 1), p("x", "z", "y", 1, 1, n, i, r, a, s, 2), p("x", "z", "y", 1, -1, n, i, -r, a, s, 3), p("x", "y", "z", 1, -1, n, r, i, a, o, 4), p("x", "y", "z", -1, -1, n, r, -i, a, o, 5), e.setIndex(l), e.setAttribute("position", new nT(u, 3)), e.setAttribute("normal", new nT(c, 3)), e.setAttribute("uv", new nT(h, 2)), e
                }
                return (0, P._)(t, e), (0, A._)(t, null, [{
                    key: "fromJSON",
                    value: function(e) {
                        return new t(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
                    }
                }]), t
            }(nI);

            function n0(e) {
                var t = {};
                for (var n in e)
                    for (var r in t[n] = {}, e[n]) {
                        var i = e[n][r];
                        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
                    }
                return t
            }

            function n1(e) {
                for (var t = {}, n = 0; n < e.length; n++) {
                    var r = n0(e[n]);
                    for (var i in r) t[i] = r[i]
                }
                return t
            }
            var n2 = {
                    clone: n0
                },
                n3 = function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t)).type = "ShaderMaterial", n.defines = {}, n.uniforms = {}, n.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", n.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", n.linewidth = 1, n.wireframe = !1, n.wireframeLinewidth = 1, n.fog = !1, n.lights = !1, n.clipping = !1, n.extensions = {
                            derivatives: !1,
                            fragDepth: !1,
                            drawBuffers: !1,
                            shaderTextureLOD: !1
                        }, n.defaultAttributeValues = {
                            color: [1, 1, 1],
                            uv: [0, 0],
                            uv2: [0, 0]
                        }, n.index0AttributeName = void 0, n.uniformsNeedUpdate = !1, n.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), n.setValues(e)), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = n0(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
                        }
                    }, {
                        key: "toJSON",
                        value: function(e) {
                            var n = L((0, C._)(t.prototype), "toJSON", this).call(this, e);
                            for (var r in n.glslVersion = this.glslVersion, n.uniforms = {}, this.uniforms) {
                                var i = this.uniforms[r].value;
                                i && i.isTexture ? n.uniforms[r] = {
                                    type: "t",
                                    value: i.toJSON(e).uuid
                                } : i && i.isColor ? n.uniforms[r] = {
                                    type: "c",
                                    value: i.getHex()
                                } : i && i.isVector2 ? n.uniforms[r] = {
                                    type: "v2",
                                    value: i.toArray()
                                } : i && i.isVector3 ? n.uniforms[r] = {
                                    type: "v3",
                                    value: i.toArray()
                                } : i && i.isVector4 ? n.uniforms[r] = {
                                    type: "v4",
                                    value: i.toArray()
                                } : i && i.isMatrix3 ? n.uniforms[r] = {
                                    type: "m3",
                                    value: i.toArray()
                                } : i && i.isMatrix4 ? n.uniforms[r] = {
                                    type: "m4",
                                    value: i.toArray()
                                } : n.uniforms[r] = {
                                    value: i
                                }
                            }
                            Object.keys(this.defines).length > 0 && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader;
                            var a = {};
                            for (var o in this.extensions) !0 === this.extensions[o] && (a[o] = !0);
                            return Object.keys(a).length > 0 && (n.extensions = a), n
                        }
                    }]), t
                }(nh);
            n3.prototype.isShaderMaterial = !0;
            var n4 = function(e) {
                function t() {
                    var e;
                    return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "Camera", e.matrixWorldInverse = new tF, e.projectionMatrix = new tF, e.projectionMatrixInverse = new tF, e
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e, n) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e, n), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
                    }
                }, {
                    key: "getWorldDirection",
                    value: function(e) {
                        this.updateWorldMatrix(!0, !1);
                        var t = this.matrixWorld.elements;
                        return e.set(-t[8], -t[9], -t[10]).normalize()
                    }
                }, {
                    key: "updateMatrixWorld",
                    value: function(e) {
                        L((0, C._)(t.prototype), "updateMatrixWorld", this).call(this, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                }, {
                    key: "updateWorldMatrix",
                    value: function(e, n) {
                        L((0, C._)(t.prototype), "updateWorldMatrix", this).call(this, e, n), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return (new this.constructor).copy(this)
                    }
                }]), t
            }(t7);
            n4.prototype.isCamera = !0;
            var n5 = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 50,
                        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1,
                        a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2e3;
                    return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "PerspectiveCamera", e.fov = n, e.zoom = 1, e.near = i, e.far = a, e.focus = 10, e.aspect = r, e.view = null, e.filmGauge = 35, e.filmOffset = 0, e.updateProjectionMatrix(), e
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e, n) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e, n), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
                    }
                }, {
                    key: "setFocalLength",
                    value: function(e) {
                        var t = .5 * this.getFilmHeight() / e;
                        this.fov = 2 * eJ * Math.atan(t), this.updateProjectionMatrix()
                    }
                }, {
                    key: "getFocalLength",
                    value: function() {
                        var e = Math.tan(.5 * eY * this.fov);
                        return .5 * this.getFilmHeight() / e
                    }
                }, {
                    key: "getEffectiveFOV",
                    value: function() {
                        return 2 * eJ * Math.atan(Math.tan(.5 * eY * this.fov) / this.zoom)
                    }
                }, {
                    key: "getFilmWidth",
                    value: function() {
                        return this.filmGauge * Math.min(this.aspect, 1)
                    }
                }, {
                    key: "getFilmHeight",
                    value: function() {
                        return this.filmGauge / Math.max(this.aspect, 1)
                    }
                }, {
                    key: "setViewOffset",
                    value: function(e, t, n, r, i, a) {
                        this.aspect = e / t, null === this.view && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix()
                    }
                }, {
                    key: "clearViewOffset",
                    value: function() {
                        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                    }
                }, {
                    key: "updateProjectionMatrix",
                    value: function() {
                        var e = this.near,
                            t = e * Math.tan(.5 * eY * this.fov) / this.zoom,
                            n = 2 * t,
                            r = this.aspect * n,
                            i = -.5 * r,
                            a = this.view;
                        if (null !== this.view && this.view.enabled) {
                            var o = a.fullWidth,
                                s = a.fullHeight;
                            i += a.offsetX * r / o, t -= a.offsetY * n / s, r *= a.width / o, n *= a.height / s
                        }
                        var l = this.filmOffset;
                        0 !== l && (i += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                }, {
                    key: "toJSON",
                    value: function(e) {
                        var n = L((0, C._)(t.prototype), "toJSON", this).call(this, e);
                        return n.object.fov = this.fov, n.object.zoom = this.zoom, n.object.near = this.near, n.object.far = this.far, n.object.focus = this.focus, n.object.aspect = this.aspect, null !== this.view && (n.object.view = Object.assign({}, this.view)), n.object.filmGauge = this.filmGauge, n.object.filmOffset = this.filmOffset, n
                    }
                }]), t
            }(n4);
            n5.prototype.isPerspectiveCamera = !0;
            var n6 = function(e) {
                    function t(e, n, r) {
                        if ((0, k._)(this, t), (i = (0, E._)(this, t)).type = "CubeCamera", !0 !== r.isWebGLCubeRenderTarget) return (0, D._)(i, void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."));
                        i.renderTarget = r;
                        var i, a = new n5(90, 1, e, n);
                        a.layers = i.layers, a.up.set(0, -1, 0), a.lookAt(new to(1, 0, 0)), i.add(a);
                        var o = new n5(90, 1, e, n);
                        o.layers = i.layers, o.up.set(0, -1, 0), o.lookAt(new to(-1, 0, 0)), i.add(o);
                        var s = new n5(90, 1, e, n);
                        s.layers = i.layers, s.up.set(0, 0, 1), s.lookAt(new to(0, 1, 0)), i.add(s);
                        var l = new n5(90, 1, e, n);
                        l.layers = i.layers, l.up.set(0, 0, -1), l.lookAt(new to(0, -1, 0)), i.add(l);
                        var u = new n5(90, 1, e, n);
                        u.layers = i.layers, u.up.set(0, -1, 0), u.lookAt(new to(0, 0, 1)), i.add(u);
                        var c = new n5(90, 1, e, n);
                        return c.layers = i.layers, c.up.set(0, -1, 0), c.lookAt(new to(0, 0, -1)), i.add(c), i
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "update",
                        value: function(e, t) {
                            null === this.parent && this.updateMatrixWorld();
                            var n = this.renderTarget,
                                r = (0, O._)(this.children, 6),
                                i = r[0],
                                a = r[1],
                                o = r[2],
                                s = r[3],
                                l = r[4],
                                u = r[5],
                                c = e.xr.enabled,
                                h = e.getRenderTarget();
                            e.xr.enabled = !1;
                            var d = n.texture.generateMipmaps;
                            n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, a), e.setRenderTarget(n, 2), e.render(t, o), e.setRenderTarget(n, 3), e.render(t, s), e.setRenderTarget(n, 4), e.render(t, l), n.texture.generateMipmaps = d, e.setRenderTarget(n, 5), e.render(t, u), e.setRenderTarget(h), e.xr.enabled = c
                        }
                    }]), t
                }(t7),
                n8 = function(e) {
                    function t(e, n, r, i, a, o, s, l, u, c) {
                        var h;
                        return (0, k._)(this, t), (h = (0, E._)(this, t, [e = void 0 !== e ? e : [], n = void 0 !== n ? n : 301, r, i, a, o, s, l, u, c])).flipY = !1, h
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "images",
                        get: function() {
                            return this.image
                        },
                        set: function(e) {
                            this.image = e
                        }
                    }]), t
                }(te);
            n8.prototype.isCubeTexture = !0;
            var n7 = function(e) {
                function t(e, n, r) {
                    var i;
                    return (0, k._)(this, t), Number.isInteger(n) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), n = r), i = (0, E._)(this, t, [e, e, n]), n = n || {}, i.texture = new n8(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), i.texture.isRenderTargetTexture = !0, i.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, i.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, i.texture._needsFlipEnvMap = !1, i
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "fromEquirectangularTexture",
                    value: function(e, t) {
                        this.texture.type = t.type, this.texture.format = 1023, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                        var n = new n$(5, 5, 5),
                            r = new n3({
                                name: "CubemapFromEquirect",
                                uniforms: n0({
                                    tEquirect: {
                                        value: null
                                    }
                                }),
                                vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			",
                                fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			",
                                side: 1,
                                blending: 0
                            });
                        r.uniforms.tEquirect.value = t;
                        var i = new nK(n, r),
                            a = t.minFilter;
                        return 1008 === t.minFilter && (t.minFilter = 1006), new n6(1, 10, this).update(e, i), t.minFilter = a, i.geometry.dispose(), i.material.dispose(), this
                    }
                }, {
                    key: "clear",
                    value: function(e, t, n, r) {
                        for (var i = e.getRenderTarget(), a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, n, r);
                        e.setRenderTarget(i)
                    }
                }]), t
            }(tr);
            n7.prototype.isWebGLCubeRenderTarget = !0;
            var n9 = new to,
                re = new to,
                rt = new e5,
                rn = function() {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new to(1, 0, 0),
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        (0, k._)(this, e), this.normal = t, this.constant = n
                    }
                    return (0, A._)(e, [{
                        key: "set",
                        value: function(e, t) {
                            return this.normal.copy(e), this.constant = t, this
                        }
                    }, {
                        key: "setComponents",
                        value: function(e, t, n, r) {
                            return this.normal.set(e, t, n), this.constant = r, this
                        }
                    }, {
                        key: "setFromNormalAndCoplanarPoint",
                        value: function(e, t) {
                            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                        }
                    }, {
                        key: "setFromCoplanarPoints",
                        value: function(e, t, n) {
                            var r = n9.subVectors(n, t).cross(re.subVectors(e, t)).normalize();
                            return this.setFromNormalAndCoplanarPoint(r, e), this
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return this.normal.copy(e.normal), this.constant = e.constant, this
                        }
                    }, {
                        key: "normalize",
                        value: function() {
                            var e = 1 / this.normal.length();
                            return this.normal.multiplyScalar(e), this.constant *= e, this
                        }
                    }, {
                        key: "negate",
                        value: function() {
                            return this.constant *= -1, this.normal.negate(), this
                        }
                    }, {
                        key: "distanceToPoint",
                        value: function(e) {
                            return this.normal.dot(e) + this.constant
                        }
                    }, {
                        key: "distanceToSphere",
                        value: function(e) {
                            return this.distanceToPoint(e.center) - e.radius
                        }
                    }, {
                        key: "projectPoint",
                        value: function(e, t) {
                            return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
                        }
                    }, {
                        key: "intersectLine",
                        value: function(e, t) {
                            var n = e.delta(n9),
                                r = this.normal.dot(n);
                            if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                            var i = -(e.start.dot(this.normal) + this.constant) / r;
                            return i < 0 || i > 1 ? null : t.copy(n).multiplyScalar(i).add(e.start)
                        }
                    }, {
                        key: "intersectsLine",
                        value: function(e) {
                            var t = this.distanceToPoint(e.start),
                                n = this.distanceToPoint(e.end);
                            return t < 0 && n > 0 || n < 0 && t > 0
                        }
                    }, {
                        key: "intersectsBox",
                        value: function(e) {
                            return e.intersectsPlane(this)
                        }
                    }, {
                        key: "intersectsSphere",
                        value: function(e) {
                            return e.intersectsPlane(this)
                        }
                    }, {
                        key: "coplanarPoint",
                        value: function(e) {
                            return e.copy(this.normal).multiplyScalar(-this.constant)
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function(e, t) {
                            var n = t || rt.getNormalMatrix(e),
                                r = this.coplanarPoint(n9).applyMatrix4(e),
                                i = this.normal.applyMatrix3(n).normalize();
                            return this.constant = -r.dot(i), this
                        }
                    }, {
                        key: "translate",
                        value: function(e) {
                            return this.constant -= e.dot(this.normal), this
                        }
                    }, {
                        key: "equals",
                        value: function(e) {
                            return e.normal.equals(this.normal) && e.constant === this.constant
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return (new this.constructor).copy(this)
                        }
                    }]), e
                }();
            rn.prototype.isPlane = !0;
            var rr = new tA,
                ri = new to,
                ra = function() {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new rn,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new rn,
                            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new rn,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new rn,
                            a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : new rn,
                            o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : new rn;
                        (0, k._)(this, e), this.planes = [t, n, r, i, a, o]
                    }
                    return (0, A._)(e, [{
                        key: "set",
                        value: function(e, t, n, r, i, a) {
                            var o = this.planes;
                            return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(a), this
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                            return this
                        }
                    }, {
                        key: "setFromProjectionMatrix",
                        value: function(e) {
                            var t = this.planes,
                                n = e.elements,
                                r = n[0],
                                i = n[1],
                                a = n[2],
                                o = n[3],
                                s = n[4],
                                l = n[5],
                                u = n[6],
                                c = n[7],
                                h = n[8],
                                d = n[9],
                                f = n[10],
                                p = n[11],
                                m = n[12],
                                v = n[13],
                                g = n[14],
                                y = n[15];
                            return t[0].setComponents(o - r, c - s, p - h, y - m).normalize(), t[1].setComponents(o + r, c + s, p + h, y + m).normalize(), t[2].setComponents(o + i, c + l, p + d, y + v).normalize(), t[3].setComponents(o - i, c - l, p - d, y - v).normalize(), t[4].setComponents(o - a, c - u, p - f, y - g).normalize(), t[5].setComponents(o + a, c + u, p + f, y + g).normalize(), this
                        }
                    }, {
                        key: "intersectsObject",
                        value: function(e) {
                            var t = e.geometry;
                            return null === t.boundingSphere && t.computeBoundingSphere(), rr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(rr)
                        }
                    }, {
                        key: "intersectsSprite",
                        value: function(e) {
                            return rr.center.set(0, 0, 0), rr.radius = .7071067811865476, rr.applyMatrix4(e.matrixWorld), this.intersectsSphere(rr)
                        }
                    }, {
                        key: "intersectsSphere",
                        value: function(e) {
                            for (var t = this.planes, n = e.center, r = -e.radius, i = 0; i < 6; i++)
                                if (t[i].distanceToPoint(n) < r) return !1;
                            return !0
                        }
                    }, {
                        key: "intersectsBox",
                        value: function(e) {
                            for (var t = this.planes, n = 0; n < 6; n++) {
                                var r = t[n];
                                if (ri.x = r.normal.x > 0 ? e.max.x : e.min.x, ri.y = r.normal.y > 0 ? e.max.y : e.min.y, ri.z = r.normal.z > 0 ? e.max.z : e.min.z, 0 > r.distanceToPoint(ri)) return !1
                            }
                            return !0
                        }
                    }, {
                        key: "containsPoint",
                        value: function(e) {
                            for (var t = this.planes, n = 0; n < 6; n++)
                                if (0 > t[n].distanceToPoint(e)) return !1;
                            return !0
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return (new this.constructor).copy(this)
                        }
                    }]), e
                }();

            function ro() {
                var e = null,
                    t = !1,
                    n = null,
                    r = null;

                function i(t, a) {
                    n(t, a), r = e.requestAnimationFrame(i)
                }
                return {
                    start: function() {
                        !0 !== t && null !== n && (r = e.requestAnimationFrame(i), t = !0)
                    },
                    stop: function() {
                        e.cancelAnimationFrame(r), t = !1
                    },
                    setAnimationLoop: function(e) {
                        n = e
                    },
                    setContext: function(t) {
                        e = t
                    }
                }
            }

            function rs(e, t) {
                var n = t.isWebGL2,
                    r = new WeakMap;
                return {
                    get: function(e) {
                        return e.isInterleavedBufferAttribute && (e = e.data), r.get(e)
                    },
                    remove: function(t) {
                        t.isInterleavedBufferAttribute && (t = t.data);
                        var n = r.get(t);
                        n && (e.deleteBuffer(n.buffer), r.delete(t))
                    },
                    update: function(t, i) {
                        if (t.isGLBufferAttribute) {
                            var a, o, s, l, u, c, h, d, f, p = r.get(t);
                            return void((!p || p.version < t.version) && r.set(t, {
                                buffer: t.buffer,
                                type: t.type,
                                bytesPerElement: t.elementSize,
                                version: t.version
                            }))
                        }
                        t.isInterleavedBufferAttribute && (t = t.data);
                        var m = r.get(t);
                        void 0 === m ? r.set(t, (o = (a = t).array, s = a.usage, l = e.createBuffer(), e.bindBuffer(i, l), e.bufferData(i, o, s), a.onUploadCallback(), u = 5126, o instanceof Float32Array ? u = 5126 : o instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : o instanceof Uint16Array ? a.isFloat16BufferAttribute ? n ? u = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : u = 5123 : o instanceof Int16Array ? u = 5122 : o instanceof Uint32Array ? u = 5125 : o instanceof Int32Array ? u = 5124 : o instanceof Int8Array ? u = 5120 : (o instanceof Uint8Array || o instanceof Uint8ClampedArray) && (u = 5121), {
                            buffer: l,
                            type: u,
                            bytesPerElement: o.BYTES_PER_ELEMENT,
                            version: a.version
                        })) : m.version < t.version && (c = m.buffer, d = (h = t).array, f = h.updateRange, e.bindBuffer(i, c), -1 === f.count ? e.bufferSubData(i, 0, d) : (n ? e.bufferSubData(i, f.offset * d.BYTES_PER_ELEMENT, d, f.offset, f.count) : e.bufferSubData(i, f.offset * d.BYTES_PER_ELEMENT, d.subarray(f.offset, f.offset + f.count)), f.count = -1), m.version = t.version)
                    }
                }
            }
            var rl = function(e) {
                    function t() {
                        var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                        (0, k._)(this, t), (e = (0, E._)(this, t)).type = "PlaneGeometry", e.parameters = {
                            width: n,
                            height: r,
                            widthSegments: i,
                            heightSegments: a
                        };
                        for (var o = n / 2, s = r / 2, l = Math.floor(i), u = Math.floor(a), c = l + 1, h = u + 1, d = n / l, f = r / u, p = [], m = [], v = [], g = [], y = 0; y < h; y++)
                            for (var _ = y * f - s, x = 0; x < c; x++) {
                                var b = x * d - o;
                                m.push(b, -_, 0), v.push(0, 0, 1), g.push(x / l), g.push(1 - y / u)
                            }
                        for (var w = 0; w < u; w++)
                            for (var M = 0; M < l; M++) {
                                var S = M + c * w,
                                    T = M + c * (w + 1),
                                    A = M + 1 + c * (w + 1),
                                    R = M + 1 + c * w;
                                p.push(S, T, R), p.push(T, A, R)
                            }
                        return e.setIndex(p), e.setAttribute("position", new nT(m, 3)), e.setAttribute("normal", new nT(v, 3)), e.setAttribute("uv", new nT(g, 2)), e
                    }
                    return (0, P._)(t, e), (0, A._)(t, null, [{
                        key: "fromJSON",
                        value: function(e) {
                            return new t(e.width, e.height, e.widthSegments, e.heightSegments)
                        }
                    }]), t
                }(nI),
                ru = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif",
                    alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		return texture2D( envMap, uv ).rgb;\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n		envColor = envMapTexelToLinear( envColor );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n			float texelIndex = float( vertexIndex * stride + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV ).xyz;\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			#ifndef USE_MORPHNORMALS\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n			#else\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n			#endif\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif",
                    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                    normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
                    normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
                    normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif",
                    output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmission_fragment: "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
                    transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( float roughness, float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef TEXTURE_LOD_EXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif",
                    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",
                    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",
                    meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}"
                },
                rc = {
                    common: {
                        diffuse: {
                            value: new ny(0xffffff)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new e5
                        },
                        uv2Transform: {
                            value: new e5
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: .98
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new e4(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new ny(0xffffff)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new ny(0xffffff)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new e5
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new ny(0xffffff)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new e4(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new e5
                        }
                    }
                },
                rh = {
                    basic: {
                        uniforms: n1([rc.common, rc.specularmap, rc.envmap, rc.aomap, rc.lightmap, rc.fog]),
                        vertexShader: ru.meshbasic_vert,
                        fragmentShader: ru.meshbasic_frag
                    },
                    lambert: {
                        uniforms: n1([rc.common, rc.specularmap, rc.envmap, rc.aomap, rc.lightmap, rc.emissivemap, rc.fog, rc.lights, {
                            emissive: {
                                value: new ny(0)
                            }
                        }]),
                        vertexShader: ru.meshlambert_vert,
                        fragmentShader: ru.meshlambert_frag
                    },
                    phong: {
                        uniforms: n1([rc.common, rc.specularmap, rc.envmap, rc.aomap, rc.lightmap, rc.emissivemap, rc.bumpmap, rc.normalmap, rc.displacementmap, rc.fog, rc.lights, {
                            emissive: {
                                value: new ny(0)
                            },
                            specular: {
                                value: new ny(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: ru.meshphong_vert,
                        fragmentShader: ru.meshphong_frag
                    },
                    standard: {
                        uniforms: n1([rc.common, rc.envmap, rc.aomap, rc.lightmap, rc.emissivemap, rc.bumpmap, rc.normalmap, rc.displacementmap, rc.roughnessmap, rc.metalnessmap, rc.fog, rc.lights, {
                            emissive: {
                                value: new ny(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ru.meshphysical_vert,
                        fragmentShader: ru.meshphysical_frag
                    },
                    toon: {
                        uniforms: n1([rc.common, rc.aomap, rc.lightmap, rc.emissivemap, rc.bumpmap, rc.normalmap, rc.displacementmap, rc.gradientmap, rc.fog, rc.lights, {
                            emissive: {
                                value: new ny(0)
                            }
                        }]),
                        vertexShader: ru.meshtoon_vert,
                        fragmentShader: ru.meshtoon_frag
                    },
                    matcap: {
                        uniforms: n1([rc.common, rc.bumpmap, rc.normalmap, rc.displacementmap, rc.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: ru.meshmatcap_vert,
                        fragmentShader: ru.meshmatcap_frag
                    },
                    points: {
                        uniforms: n1([rc.points, rc.fog]),
                        vertexShader: ru.points_vert,
                        fragmentShader: ru.points_frag
                    },
                    dashed: {
                        uniforms: n1([rc.common, rc.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: ru.linedashed_vert,
                        fragmentShader: ru.linedashed_frag
                    },
                    depth: {
                        uniforms: n1([rc.common, rc.displacementmap]),
                        vertexShader: ru.depth_vert,
                        fragmentShader: ru.depth_frag
                    },
                    normal: {
                        uniforms: n1([rc.common, rc.bumpmap, rc.normalmap, rc.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ru.meshnormal_vert,
                        fragmentShader: ru.meshnormal_frag
                    },
                    sprite: {
                        uniforms: n1([rc.sprite, rc.fog]),
                        vertexShader: ru.sprite_vert,
                        fragmentShader: ru.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new e5
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: ru.background_vert,
                        fragmentShader: ru.background_frag
                    },
                    cube: {
                        uniforms: n1([rc.envmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ru.cube_vert,
                        fragmentShader: ru.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: ru.equirect_vert,
                        fragmentShader: ru.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: n1([rc.common, rc.displacementmap, {
                            referencePosition: {
                                value: new to
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: ru.distanceRGBA_vert,
                        fragmentShader: ru.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: n1([rc.lights, rc.fog, {
                            color: {
                                value: new ny(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ru.shadow_vert,
                        fragmentShader: ru.shadow_frag
                    }
                };

            function rd(e, t, n, r, i) {
                var a, o, s = new ny(0),
                    l = 0,
                    u = null,
                    c = 0,
                    h = null;

                function d(e, t) {
                    n.buffers.color.setClear(e.r, e.g, e.b, t, i)
                }
                return {
                    getClearColor: function() {
                        return s
                    },
                    setClearColor: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                        s.set(e), d(s, l = t)
                    },
                    getClearAlpha: function() {
                        return l
                    },
                    setClearAlpha: function(e) {
                        d(s, l = e)
                    },
                    render: function(n, i) {
                        var f = !1,
                            p = !0 === i.isScene ? i.background : null;
                        p && p.isTexture && (p = t.get(p));
                        var m = e.xr,
                            v = m.getSession && m.getSession();
                        v && "additive" === v.environmentBlendMode && (p = null), null === p ? d(s, l) : p && p.isColor && (d(p, 1), f = !0), (e.autoClear || f) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), p && (p.isCubeTexture || 306 === p.mapping) ? (void 0 === o && ((o = new nK(new n$(1, 1, 1), new n3({
                            name: "BackgroundCubeMaterial",
                            uniforms: n0(rh.cube.uniforms),
                            vertexShader: rh.cube.vertexShader,
                            fragmentShader: rh.cube.fragmentShader,
                            side: 1,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), o.geometry.deleteAttribute("uv"), o.onBeforeRender = function(e, t, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, Object.defineProperty(o.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }), r.update(o)), o.material.uniforms.envMap.value = p, o.material.uniforms.flipEnvMap.value = p.isCubeTexture && !1 === p.isRenderTargetTexture ? -1 : 1, u === p && c === p.version && h === e.toneMapping || (o.material.needsUpdate = !0, u = p, c = p.version, h = e.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null)) : p && p.isTexture && (void 0 === a && ((a = new nK(new rl(2, 2), new n3({
                            name: "BackgroundMaterial",
                            uniforms: n0(rh.background.uniforms),
                            vertexShader: rh.background.vertexShader,
                            fragmentShader: rh.background.fragmentShader,
                            side: 0,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), r.update(a)), a.material.uniforms.t2D.value = p, !0 === p.matrixAutoUpdate && p.updateMatrix(), a.material.uniforms.uvTransform.value.copy(p.matrix), u === p && c === p.version && h === e.toneMapping || (a.material.needsUpdate = !0, u = p, c = p.version, h = e.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null))
                    }
                }
            }

            function rf(e, t, n, r) {
                var i = e.getParameter(34921),
                    a = r.isWebGL2 ? null : t.get("OES_vertex_array_object"),
                    o = r.isWebGL2 || null !== a,
                    s = {},
                    l = d(null),
                    u = l;

                function c(t) {
                    return r.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t)
                }

                function h(t) {
                    return r.isWebGL2 ? e.deleteVertexArray(t) : a.deleteVertexArrayOES(t)
                }

                function d(e) {
                    for (var t = [], n = [], r = [], a = 0; a < i; a++) t[a] = 0, n[a] = 0, r[a] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: t,
                        enabledAttributes: n,
                        attributeDivisors: r,
                        object: e,
                        attributes: {},
                        index: null
                    }
                }

                function f() {
                    for (var e = u.newAttributes, t = 0, n = e.length; t < n; t++) e[t] = 0
                }

                function p(e) {
                    m(e, 0)
                }

                function m(n, i) {
                    var a = u.newAttributes,
                        o = u.enabledAttributes,
                        s = u.attributeDivisors;
                    a[n] = 1, 0 === o[n] && (e.enableVertexAttribArray(n), o[n] = 1), s[n] !== i && ((r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), s[n] = i)
                }

                function v() {
                    for (var t = u.newAttributes, n = u.enabledAttributes, r = 0, i = n.length; r < i; r++) n[r] !== t[r] && (e.disableVertexAttribArray(r), n[r] = 0)
                }

                function g(t, n, i, a, o, s) {
                    !0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? e.vertexAttribPointer(t, n, i, a, o, s) : e.vertexAttribIPointer(t, n, i, o, s)
                }

                function y() {
                    _(), u !== l && c((u = l).object)
                }

                function _() {
                    l.geometry = null, l.program = null, l.wireframe = !1
                }
                return {
                    setup: function(i, l, h, y, _) {
                        var x = !1;
                        if (o) {
                            var b, w, M, S, T = (b = !0 === l.wireframe, void 0 === (w = s[y.id]) && (w = {}, s[y.id] = w), void 0 === (M = w[h.id]) && (M = {}, w[h.id] = M), void 0 === (S = M[b]) && (S = d(r.isWebGL2 ? e.createVertexArray() : a.createVertexArrayOES()), M[b] = S), S);
                            u !== T && c((u = T).object), (x = function(e, t) {
                                var n = u.attributes,
                                    r = e.attributes,
                                    i = 0;
                                for (var a in r) {
                                    var o = n[a],
                                        s = r[a];
                                    if (void 0 === o || o.attribute !== s || o.data !== s.data) return !0;
                                    i++
                                }
                                return u.attributesNum !== i || u.index !== t
                            }(y, _)) && function(e, t) {
                                var n = {},
                                    r = e.attributes,
                                    i = 0;
                                for (var a in r) {
                                    var o = r[a],
                                        s = {};
                                    s.attribute = o, o.data && (s.data = o.data), n[a] = s, i++
                                }
                                u.attributes = n, u.attributesNum = i, u.index = t
                            }(y, _)
                        } else {
                            var E = !0 === l.wireframe;
                            u.geometry === y.id && u.program === h.id && u.wireframe === E || (u.geometry = y.id, u.program = h.id, u.wireframe = E, x = !0)
                        }!0 === i.isInstancedMesh && (x = !0), null !== _ && n.update(_, 34963), x && (function(i, a, o, s) {
                            if (!1 !== r.isWebGL2 || !i.isInstancedMesh && !s.isInstancedBufferGeometry || null !== t.get("ANGLE_instanced_arrays")) {
                                f();
                                var l = s.attributes,
                                    u = o.getAttributes(),
                                    c = a.defaultAttributeValues;
                                for (var h in u) {
                                    var d = u[h];
                                    if (d.location >= 0) {
                                        var y = l[h];
                                        if (void 0 === y && ("instanceMatrix" === h && i.instanceMatrix && (y = i.instanceMatrix), "instanceColor" === h && i.instanceColor && (y = i.instanceColor)), void 0 !== y) {
                                            var _ = y.normalized,
                                                x = y.itemSize,
                                                b = n.get(y);
                                            if (void 0 === b) continue;
                                            var w = b.buffer,
                                                M = b.type,
                                                S = b.bytesPerElement;
                                            if (y.isInterleavedBufferAttribute) {
                                                var T = y.data,
                                                    E = T.stride,
                                                    k = y.offset;
                                                if (T && T.isInstancedInterleavedBuffer) {
                                                    for (var A = 0; A < d.locationSize; A++) m(d.location + A, T.meshPerAttribute);
                                                    !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = T.meshPerAttribute * T.count)
                                                } else
                                                    for (var R = 0; R < d.locationSize; R++) p(d.location + R);
                                                e.bindBuffer(34962, w);
                                                for (var C = 0; C < d.locationSize; C++) g(d.location + C, x / d.locationSize, M, _, E * S, (k + x / d.locationSize * C) * S)
                                            } else {
                                                if (y.isInstancedBufferAttribute) {
                                                    for (var L = 0; L < d.locationSize; L++) m(d.location + L, y.meshPerAttribute);
                                                    !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = y.meshPerAttribute * y.count)
                                                } else
                                                    for (var P = 0; P < d.locationSize; P++) p(d.location + P);
                                                e.bindBuffer(34962, w);
                                                for (var I = 0; I < d.locationSize; I++) g(d.location + I, x / d.locationSize, M, _, x * S, x / d.locationSize * I * S)
                                            }
                                        } else if (void 0 !== c) {
                                            var D = c[h];
                                            if (void 0 !== D) switch (D.length) {
                                                case 2:
                                                    e.vertexAttrib2fv(d.location, D);
                                                    break;
                                                case 3:
                                                    e.vertexAttrib3fv(d.location, D);
                                                    break;
                                                case 4:
                                                    e.vertexAttrib4fv(d.location, D);
                                                    break;
                                                default:
                                                    e.vertexAttrib1fv(d.location, D)
                                            }
                                        }
                                    }
                                }
                                v()
                            }
                        }(i, l, h, y), null !== _ && e.bindBuffer(34963, n.get(_).buffer))
                    },
                    reset: y,
                    resetDefaultState: _,
                    dispose: function() {
                        for (var e in y(), s) {
                            var t = s[e];
                            for (var n in t) {
                                var r = t[n];
                                for (var i in r) h(r[i].object), delete r[i];
                                delete t[n]
                            }
                            delete s[e]
                        }
                    },
                    releaseStatesOfGeometry: function(e) {
                        if (void 0 !== s[e.id]) {
                            var t = s[e.id];
                            for (var n in t) {
                                var r = t[n];
                                for (var i in r) h(r[i].object), delete r[i];
                                delete t[n]
                            }
                            delete s[e.id]
                        }
                    },
                    releaseStatesOfProgram: function(e) {
                        for (var t in s) {
                            var n = s[t];
                            if (void 0 !== n[e.id]) {
                                var r = n[e.id];
                                for (var i in r) h(r[i].object), delete r[i];
                                delete n[e.id]
                            }
                        }
                    },
                    initAttributes: f,
                    enableAttribute: p,
                    disableUnusedAttributes: v
                }
            }

            function rp(e, t, n, r) {
                var i, a = r.isWebGL2;
                this.setMode = function(e) {
                    i = e
                }, this.render = function(t, r) {
                    e.drawArrays(i, t, r), n.update(r, i, 1)
                }, this.renderInstances = function(r, o, s) {
                    var l, u;
                    if (0 !== s) {
                        if (a) l = e, u = "drawArraysInstanced";
                        else if (l = t.get("ANGLE_instanced_arrays"), u = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        l[u](i, r, o, s), n.update(o, i, s)
                    }
                }
            }

            function rm(e, t, n) {
                function r(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                var i, a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext,
                    o = void 0 !== n.precision ? n.precision : "highp",
                    s = r(o);
                s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s);
                var l = a || t.has("WEBGL_draw_buffers"),
                    u = !0 === n.logarithmicDepthBuffer,
                    c = e.getParameter(34930),
                    h = e.getParameter(35660),
                    d = e.getParameter(3379),
                    f = e.getParameter(34076),
                    p = e.getParameter(34921),
                    m = e.getParameter(36347),
                    v = e.getParameter(36348),
                    g = e.getParameter(36349),
                    y = h > 0,
                    _ = a || t.has("OES_texture_float");
                return {
                    isWebGL2: a,
                    drawBuffers: l,
                    getMaxAnisotropy: function() {
                        if (void 0 !== i) return i;
                        if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                            var n = t.get("EXT_texture_filter_anisotropic");
                            i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else i = 0;
                        return i
                    },
                    getMaxPrecision: r,
                    precision: o,
                    logarithmicDepthBuffer: u,
                    maxTextures: c,
                    maxVertexTextures: h,
                    maxTextureSize: d,
                    maxCubemapSize: f,
                    maxAttributes: p,
                    maxVertexUniforms: m,
                    maxVaryings: v,
                    maxFragmentUniforms: g,
                    vertexTextures: y,
                    floatFragmentTextures: _,
                    floatVertexTextures: y && _,
                    maxSamples: a ? e.getParameter(36183) : 0
                }
            }

            function rv(e) {
                var t = this,
                    n = null,
                    r = 0,
                    i = !1,
                    a = !1,
                    o = new rn,
                    s = new e5,
                    l = {
                        value: null,
                        needsUpdate: !1
                    };

                function u() {
                    l.value !== n && (l.value = n, l.needsUpdate = r > 0), t.numPlanes = r, t.numIntersection = 0
                }

                function c(e, n, r, i) {
                    var a = null !== e ? e.length : 0,
                        u = null;
                    if (0 !== a) {
                        if (u = l.value, !0 !== i || null === u) {
                            var c = r + 4 * a,
                                h = n.matrixWorldInverse;
                            s.getNormalMatrix(h), (null === u || u.length < c) && (u = new Float32Array(c));
                            for (var d = 0, f = r; d !== a; ++d, f += 4) o.copy(e[d]).applyMatrix4(h, s), o.normal.toArray(u, f), u[f + 3] = o.constant
                        }
                        l.value = u, l.needsUpdate = !0
                    }
                    return t.numPlanes = a, t.numIntersection = 0, u
                }
                this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t, a) {
                    var o = 0 !== e.length || t || 0 !== r || i;
                    return i = t, n = c(e, a, 0), r = e.length, o
                }, this.beginShadows = function() {
                    a = !0, c(null)
                }, this.endShadows = function() {
                    a = !1, u()
                }, this.setState = function(t, o, s) {
                    var h = t.clippingPlanes,
                        d = t.clipIntersection,
                        f = t.clipShadows,
                        p = e.get(t);
                    if (i && null !== h && 0 !== h.length && (!a || f)) {
                        var m = a ? 0 : r,
                            v = 4 * m,
                            g = p.clippingState || null;
                        l.value = g, g = c(h, o, v, s);
                        for (var y = 0; y !== v; ++y) g[y] = n[y];
                        p.clippingState = g, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += m
                    } else a ? c(null) : u()
                }
            }

            function rg(e) {
                var t = new WeakMap;

                function n(e, t) {
                    return 303 === t ? e.mapping = 301 : 304 === t && (e.mapping = 302), e
                }

                function r(e) {
                    var n = e.target;
                    n.removeEventListener("dispose", r);
                    var i = t.get(n);
                    void 0 !== i && (t.delete(n), i.dispose())
                }
                return {
                    get: function(i) {
                        if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
                            var a = i.mapping;
                            if (303 === a || 304 === a) {
                                if (t.has(i)) return n(t.get(i).texture, i.mapping);
                                var o = i.image;
                                if (o && o.height > 0) {
                                    var s = e.getRenderTarget(),
                                        l = new n7(o.height / 2);
                                    return l.fromEquirectangularTexture(e, i), t.set(i, l), e.setRenderTarget(s), i.addEventListener("dispose", r), n(l.texture, i.mapping)
                                }
                                return null
                            }
                        }
                        return i
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }
            rh.physical = {
                uniforms: n1([rh.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatNormalScale: {
                        value: new e4(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    sheen: {
                        value: 0
                    },
                    sheenColor: {
                        value: new ny(0)
                    },
                    sheenColorMap: {
                        value: null
                    },
                    sheenRoughness: {
                        value: 0
                    },
                    sheenRoughnessMap: {
                        value: null
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    },
                    transmissionSamplerSize: {
                        value: new e4
                    },
                    transmissionSamplerMap: {
                        value: null
                    },
                    thickness: {
                        value: 0
                    },
                    thicknessMap: {
                        value: null
                    },
                    attenuationDistance: {
                        value: 0
                    },
                    attenuationColor: {
                        value: new ny(0)
                    },
                    specularIntensity: {
                        value: 0
                    },
                    specularIntensityMap: {
                        value: null
                    },
                    specularColor: {
                        value: new ny(1, 1, 1)
                    },
                    specularColorMap: {
                        value: null
                    }
                }]),
                vertexShader: ru.meshphysical_vert,
                fragmentShader: ru.meshphysical_frag
            };
            var ry = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1,
                        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                        a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1,
                        o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .1,
                        s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2e3;
                    return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "OrthographicCamera", e.zoom = 1, e.view = null, e.left = n, e.right = r, e.top = i, e.bottom = a, e.near = o, e.far = s, e.updateProjectionMatrix(), e
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e, n) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e, n), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
                    }
                }, {
                    key: "setViewOffset",
                    value: function(e, t, n, r, i, a) {
                        null === this.view && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix()
                    }
                }, {
                    key: "clearViewOffset",
                    value: function() {
                        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                    }
                }, {
                    key: "updateProjectionMatrix",
                    value: function() {
                        var e = (this.right - this.left) / (2 * this.zoom),
                            t = (this.top - this.bottom) / (2 * this.zoom),
                            n = (this.right + this.left) / 2,
                            r = (this.top + this.bottom) / 2,
                            i = n - e,
                            a = n + e,
                            o = r + t,
                            s = r - t;
                        if (null !== this.view && this.view.enabled) {
                            var l = (this.right - this.left) / this.view.fullWidth / this.zoom,
                                u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                            i += l * this.view.offsetX, a = i + l * this.view.width, o -= u * this.view.offsetY, s = o - u * this.view.height
                        }
                        this.projectionMatrix.makeOrthographic(i, a, o, s, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                }, {
                    key: "toJSON",
                    value: function(e) {
                        var n = L((0, C._)(t.prototype), "toJSON", this).call(this, e);
                        return n.object.zoom = this.zoom, n.object.left = this.left, n.object.right = this.right, n.object.top = this.top, n.object.bottom = this.bottom, n.object.near = this.near, n.object.far = this.far, null !== this.view && (n.object.view = Object.assign({}, this.view)), n
                    }
                }]), t
            }(n4);
            ry.prototype.isOrthographicCamera = !0;
            var r_ = function(e) {
                function t(e) {
                    var n;
                    return (0, k._)(this, t), (n = (0, E._)(this, t, [e])).type = "RawShaderMaterial", n
                }
                return (0, P._)(t, e), t
            }(n3);
            r_.prototype.isRawShaderMaterial = !0;
            var rx = [.125, .215, .35, .446, .526, .582],
                rb = 5 + rx.length,
                rw = {
                    3e3: 0,
                    3001: 1
                },
                rM = new ry,
                rS = function() {
                    for (var e = [], t = [], n = [], r = 8, i = 0; i < rb; i++) {
                        var a = Math.pow(2, r);
                        t.push(a);
                        var o = 1 / a;
                        i > 4 ? o = rx[i - 8 + 4 - 1] : 0 == i && (o = 0), n.push(o);
                        for (var s = 1 / (a - 1), l = -s / 2, u = 1 + s / 2, c = [l, l, u, l, u, u, l, l, u, u, l, u], h = new Float32Array(108), d = new Float32Array(72), f = new Float32Array(36), p = 0; p < 6; p++) {
                            var m = p % 3 * 2 / 3 - 1,
                                v = p > 2 ? 0 : -1,
                                g = [m, v, 0, m + 2 / 3, v, 0, m + 2 / 3, v + 1, 0, m, v, 0, m + 2 / 3, v + 1, 0, m, v + 1, 0];
                            h.set(g, 18 * p), d.set(c, 12 * p);
                            var y = [p, p, p, p, p, p];
                            f.set(y, 6 * p)
                        }
                        var _ = new nI;
                        _.setAttribute("position", new nw(h, 3)), _.setAttribute("uv", new nw(d, 2)), _.setAttribute("faceIndex", new nw(f, 1)), e.push(_), r > 4 && r--
                    }
                    return {
                        _lodPlanes: e,
                        _sizeLods: t,
                        _sigmas: n
                    }
                }(),
                rT = rS._lodPlanes,
                rE = rS._sizeLods,
                rk = rS._sigmas,
                rA = new ny,
                rR = null,
                rC = (1 + Math.sqrt(5)) / 2,
                rL = 1 / rC,
                rP = [new to(1, 1, 1), new to(-1, 1, 1), new to(1, 1, -1), new to(-1, 1, -1), new to(0, rC, rL), new to(0, rC, -rL), new to(rL, 0, rC), new to(-rL, 0, rC), new to(rC, rL, 0), new to(-rC, rL, 0)],
                rI = function() {
                    function e(t) {
                        (0, k._)(this, e), this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = new r_({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: 20
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: new Float32Array(20)
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: new to(0, 1, 0)
                                }
                            },
                            vertexShader: rU(),
                            fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			".concat(rB(), "\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n			}\n		"),
                            blending: 0,
                            depthTest: !1,
                            depthWrite: !1
                        }), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
                    }
                    return (0, A._)(e, [{
                        key: "fromScene",
                        value: function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1,
                                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 100;
                            rR = this._renderer.getRenderTarget();
                            var i = this._allocateTargets();
                            return this._sceneToCubeUV(e, n, r, i), t > 0 && this._blur(i, 0, 0, t), this._applyPMREM(i), this._cleanup(i), i
                        }
                    }, {
                        key: "fromEquirectangular",
                        value: function(e) {
                            return this._fromTexture(e)
                        }
                    }, {
                        key: "fromCubemap",
                        value: function(e) {
                            return this._fromTexture(e)
                        }
                    }, {
                        key: "compileCubemapShader",
                        value: function() {
                            null === this._cubemapShader && (this._cubemapShader = rF(), this._compileMaterial(this._cubemapShader))
                        }
                    }, {
                        key: "compileEquirectangularShader",
                        value: function() {
                            null === this._equirectShader && (this._equirectShader = rN(), this._compileMaterial(this._equirectShader))
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
                            for (var e = 0; e < rT.length; e++) rT[e].dispose()
                        }
                    }, {
                        key: "_cleanup",
                        value: function(e) {
                            this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(rR), e.scissorTest = !1, rO(e, 0, 0, e.width, e.height)
                        }
                    }, {
                        key: "_fromTexture",
                        value: function(e) {
                            rR = this._renderer.getRenderTarget();
                            var t = this._allocateTargets(e);
                            return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t
                        }
                    }, {
                        key: "_allocateTargets",
                        value: function(e) {
                            var t = {
                                    magFilter: 1006,
                                    minFilter: 1006,
                                    generateMipmaps: !1,
                                    type: 1016,
                                    format: 1023,
                                    encoding: 3e3,
                                    depthBuffer: !1
                                },
                                n = rD(t);
                            return n.depthBuffer = !e, this._pingPongRenderTarget = rD(t), n
                        }
                    }, {
                        key: "_compileMaterial",
                        value: function(e) {
                            var t = new nK(rT[0], e);
                            this._renderer.compile(t, rM)
                        }
                    }, {
                        key: "_sceneToCubeUV",
                        value: function(e, t, n, r) {
                            var i = new n5(90, 1, t, n),
                                a = [1, -1, 1, 1, 1, 1],
                                o = [1, 1, 1, -1, -1, -1],
                                s = this._renderer,
                                l = s.autoClear,
                                u = s.toneMapping;
                            s.getClearColor(rA), s.toneMapping = 0, s.autoClear = !1;
                            var c = new n_({
                                    name: "PMREM.Background",
                                    side: 1,
                                    depthWrite: !1,
                                    depthTest: !1
                                }),
                                h = new nK(new n$, c),
                                d = !1,
                                f = e.background;
                            f ? f.isColor && (c.color.copy(f), e.background = null, d = !0) : (c.color.copy(rA), d = !0);
                            for (var p = 0; p < 6; p++) {
                                var m = p % 3;
                                0 == m ? (i.up.set(0, a[p], 0), i.lookAt(o[p], 0, 0)) : 1 == m ? (i.up.set(0, 0, a[p]), i.lookAt(0, o[p], 0)) : (i.up.set(0, a[p], 0), i.lookAt(0, 0, o[p])), rO(r, 256 * m, p > 2 ? 256 : 0, 256, 256), s.setRenderTarget(r), d && s.render(h, i), s.render(e, i)
                            }
                            h.geometry.dispose(), h.material.dispose(), s.toneMapping = u, s.autoClear = l, e.background = f
                        }
                    }, {
                        key: "_setEncoding",
                        value: function(e, t) {
                            !0 === this._renderer.capabilities.isWebGL2 && 1023 === t.format && 1009 === t.type && 3001 === t.encoding ? e.value = rw[3e3] : e.value = rw[t.encoding]
                        }
                    }, {
                        key: "_textureToCubeUV",
                        value: function(e, t) {
                            var n = this._renderer,
                                r = 301 === e.mapping || 302 === e.mapping;
                            r ? null == this._cubemapShader && (this._cubemapShader = rF()) : null == this._equirectShader && (this._equirectShader = rN());
                            var i = r ? this._cubemapShader : this._equirectShader,
                                a = new nK(rT[0], i),
                                o = i.uniforms;
                            o.envMap.value = e, r || o.texelSize.value.set(1 / e.image.width, 1 / e.image.height), this._setEncoding(o.inputEncoding, e), rO(t, 0, 0, 768, 512), n.setRenderTarget(t), n.render(a, rM)
                        }
                    }, {
                        key: "_applyPMREM",
                        value: function(e) {
                            var t = this._renderer,
                                n = t.autoClear;
                            t.autoClear = !1;
                            for (var r = 1; r < rb; r++) {
                                var i = Math.sqrt(rk[r] * rk[r] - rk[r - 1] * rk[r - 1]),
                                    a = rP[(r - 1) % rP.length];
                                this._blur(e, r - 1, r, i, a)
                            }
                            t.autoClear = n
                        }
                    }, {
                        key: "_blur",
                        value: function(e, t, n, r, i) {
                            var a = this._pingPongRenderTarget;
                            this._halfBlur(e, a, t, n, r, "latitudinal", i), this._halfBlur(a, e, n, n, r, "longitudinal", i)
                        }
                    }, {
                        key: "_halfBlur",
                        value: function(e, t, n, r, i, a, o) {
                            var s = this._renderer,
                                l = this._blurMaterial;
                            "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
                            var u = new nK(rT[r], l),
                                c = l.uniforms,
                                h = rE[n] - 1,
                                d = isFinite(i) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
                                f = i / d,
                                p = isFinite(i) ? 1 + Math.floor(3 * f) : 20;
                            p > 20 && console.warn("sigmaRadians, ".concat(i, ", is too large and will clip, as it requested ").concat(p, " samples when the maximum is set to 20"));
                            for (var m = [], v = 0, g = 0; g < 20; ++g) {
                                var y = g / f,
                                    _ = Math.exp(-y * y / 2);
                                m.push(_), 0 == g ? v += _ : g < p && (v += 2 * _)
                            }
                            for (var x = 0; x < m.length; x++) m[x] = m[x] / v;
                            c.envMap.value = e.texture, c.samples.value = p, c.weights.value = m, c.latitudinal.value = "latitudinal" === a, o && (c.poleAxis.value = o), c.dTheta.value = d, c.mipInt.value = 8 - n;
                            var b = rE[r];
                            rO(t, 3 * Math.max(0, 256 - 2 * b), (0 === r ? 0 : 512) + 2 * b * (r > 4 ? r - 8 + 4 : 0), 3 * b, 2 * b), s.setRenderTarget(t), s.render(u, rM)
                        }
                    }]), e
                }();

            function rD(e) {
                var t = new tr(768, 768, e);
                return t.texture.mapping = 306, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t
            }

            function rO(e, t, n, r, i) {
                e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i)
            }

            function rN() {
                return new r_({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        texelSize: {
                            value: new e4(1, 1)
                        },
                        inputEncoding: {
                            value: rw[3e3]
                        }
                    },
                    vertexShader: rU(),
                    fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform vec2 texelSize;\n\n			".concat(rB(), "\n\n			#include <common>\n\n			void main() {\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				vec2 f = fract( uv / texelSize - 0.5 );\n				uv -= f * texelSize;\n				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n				uv.x += texelSize.x;\n				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n				uv.y += texelSize.y;\n				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n				uv.x -= texelSize.x;\n				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n				vec3 tm = mix( tl, tr, f.x );\n				vec3 bm = mix( bl, br, f.x );\n				gl_FragColor.rgb = mix( tm, bm, f.y );\n\n			}\n		"),
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function rF() {
                return new r_({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        inputEncoding: {
                            value: rw[3e3]
                        }
                    },
                    vertexShader: rU(),
                    fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			".concat(rB(), "\n\n			void main() {\n\n				gl_FragColor = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) );\n\n			}\n		"),
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function rU() {
                return "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	"
            }

            function rB() {
                return "\n\n		uniform int inputEncoding;\n\n		#include <encodings_pars_fragment>\n\n		vec4 inputTexelToLinear( vec4 value ) {\n\n			if ( inputEncoding == 0 ) {\n\n				return value;\n\n			} else {\n\n				return sRGBToLinear( value );\n\n			}\n\n		}\n\n		vec4 envMapTexelToLinear( vec4 color ) {\n\n			return inputTexelToLinear( color );\n\n		}\n	"
            }

            function rz(e) {
                var t = new WeakMap,
                    n = null;

                function r(e) {
                    var n = e.target;
                    n.removeEventListener("dispose", r);
                    var i = t.get(n);
                    void 0 !== i && (t.delete(n), i.dispose())
                }
                return {
                    get: function(i) {
                        if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
                            var a = i.mapping,
                                o = 303 === a || 304 === a,
                                s = 301 === a || 302 === a;
                            if (o || s) {
                                if (t.has(i)) return t.get(i).texture;
                                var l = i.image;
                                if (o && l && l.height > 0 || s && l && function(e) {
                                        for (var t = 0, n = 0; n < 6; n++) void 0 !== e[n] && t++;
                                        return 6 === t
                                    }(l)) {
                                    var u = e.getRenderTarget();
                                    null === n && (n = new rI(e));
                                    var c = o ? n.fromEquirectangular(i) : n.fromCubemap(i);
                                    return t.set(i, c), e.setRenderTarget(u), i.addEventListener("dispose", r), c.texture
                                }
                                return null
                            }
                        }
                        return i
                    },
                    dispose: function() {
                        t = new WeakMap, null !== n && (n.dispose(), n = null)
                    }
                }
            }

            function rH(e) {
                var t = {};

                function n(n) {
                    var r;
                    if (void 0 !== t[n]) return t[n];
                    switch (n) {
                        case "WEBGL_depth_texture":
                            r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            r = e.getExtension(n)
                    }
                    return t[n] = r, r
                }
                return {
                    has: function(e) {
                        return null !== n(e)
                    },
                    init: function(e) {
                        e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
                    },
                    get: function(e) {
                        var t = n(e);
                        return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t
                    }
                }
            }

            function rV(e, t, n, r) {
                var i = {},
                    a = new WeakMap;

                function o(e) {
                    var s = e.target;
                    for (var l in null !== s.index && t.remove(s.index), s.attributes) t.remove(s.attributes[l]);
                    s.removeEventListener("dispose", o), delete i[s.id];
                    var u = a.get(s);
                    u && (t.remove(u), a.delete(s)), r.releaseStatesOfGeometry(s), !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount, n.memory.geometries--
                }

                function s(e) {
                    var n = [],
                        r = e.index,
                        i = e.attributes.position,
                        o = 0;
                    if (null !== r) {
                        var s = r.array;
                        o = r.version;
                        for (var l = 0, u = s.length; l < u; l += 3) {
                            var c = s[l + 0],
                                h = s[l + 1],
                                d = s[l + 2];
                            n.push(c, h, h, d, d, c)
                        }
                    } else {
                        var f = i.array;
                        o = i.version;
                        for (var p = 0, m = f.length / 3 - 1; p < m; p += 3) {
                            var v = p + 0,
                                g = p + 1,
                                y = p + 2;
                            n.push(v, g, g, y, y, v)
                        }
                    }
                    var _ = new(e6(n) > 65535 ? nS : nM)(n, 1);
                    _.version = o;
                    var x = a.get(e);
                    x && t.remove(x), a.set(e, _)
                }
                return {
                    get: function(e, t) {
                        return !0 === i[t.id] || (t.addEventListener("dispose", o), i[t.id] = !0, n.memory.geometries++), t
                    },
                    update: function(e) {
                        var n = e.attributes;
                        for (var r in n) t.update(n[r], 34962);
                        var i = e.morphAttributes;
                        for (var a in i)
                            for (var o = i[a], s = 0, l = o.length; s < l; s++) t.update(o[s], 34962)
                    },
                    getWireframeAttribute: function(e) {
                        var t = a.get(e);
                        if (t) {
                            var n = e.index;
                            null !== n && t.version < n.version && s(e)
                        } else s(e);
                        return a.get(e)
                    }
                }
            }

            function rG(e, t, n, r) {
                var i, a, o, s = r.isWebGL2;
                this.setMode = function(e) {
                    i = e
                }, this.setIndex = function(e) {
                    a = e.type, o = e.bytesPerElement
                }, this.render = function(t, r) {
                    e.drawElements(i, r, a, t * o), n.update(r, i, 1)
                }, this.renderInstances = function(r, l, u) {
                    var c, h;
                    if (0 !== u) {
                        if (s) c = e, h = "drawElementsInstanced";
                        else if (c = t.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === c) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        c[h](i, l, a, r * o, u), n.update(l, i, u)
                    }
                }
            }

            function rW(e) {
                var t = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: t,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
                    },
                    update: function(e, n, r) {
                        switch (t.calls++, n) {
                            case 4:
                                t.triangles += e / 3 * r;
                                break;
                            case 1:
                                t.lines += e / 2 * r;
                                break;
                            case 3:
                                t.lines += r * (e - 1);
                                break;
                            case 2:
                                t.lines += r * e;
                                break;
                            case 0:
                                t.points += r * e;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                        }
                    }
                }
            }
            var rj = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                        a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                    return (0, k._)(this, t), (e = (0, E._)(this, t, [null])).image = {
                        data: n,
                        width: r,
                        height: i,
                        depth: a
                    }, e.magFilter = 1003, e.minFilter = 1003, e.wrapR = 1001, e.generateMipmaps = !1, e.flipY = !1, e.unpackAlignment = 1, e
                }
                return (0, P._)(t, e), t
            }(te);

            function rq(e, t) {
                return e[0] - t[0]
            }

            function rX(e, t) {
                return Math.abs(t[1]) - Math.abs(e[1])
            }

            function rY(e, t) {
                var n = 1,
                    r = t.isInterleavedBufferAttribute ? t.data.array : t.array;
                r instanceof Int8Array ? n = 127 : r instanceof Int16Array ? n = 32767 : r instanceof Int32Array ? n = 0x7fffffff : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", r), e.divideScalar(n)
            }

            function rJ(e, t, n) {
                for (var r = {}, i = new Float32Array(8), a = new WeakMap, o = new to, s = [], l = 0; l < 8; l++) s[l] = [l, 0];
                return {
                    update: function(l, u, c, h) {
                        var d = l.morphTargetInfluences;
                        if (!0 === t.isWebGL2) {
                            var f = u.morphAttributes.position.length,
                                p = a.get(u);
                            if (void 0 === p || p.count !== f) {
                                void 0 !== p && p.texture.dispose();
                                var m = void 0 !== u.morphAttributes.normal,
                                    v = u.morphAttributes.position,
                                    g = u.morphAttributes.normal || [],
                                    y = !0 === m ? 2 : 1,
                                    _ = u.attributes.position.count * y,
                                    x = 1;
                                _ > t.maxTextureSize && (x = Math.ceil(_ / t.maxTextureSize), _ = t.maxTextureSize);
                                var b = new Float32Array(_ * x * 4 * f),
                                    w = new rj(b, _, x, f);
                                w.format = 1023, w.type = 1015, w.needsUpdate = !0;
                                for (var M = 4 * y, S = 0; S < f; S++)
                                    for (var T = v[S], E = g[S], k = _ * x * 4 * S, A = 0; A < T.count; A++) {
                                        o.fromBufferAttribute(T, A), !0 === T.normalized && rY(o, T);
                                        var R = A * M;
                                        b[k + R + 0] = o.x, b[k + R + 1] = o.y, b[k + R + 2] = o.z, b[k + R + 3] = 0, !0 === m && (o.fromBufferAttribute(E, A), !0 === E.normalized && rY(o, E), b[k + R + 4] = o.x, b[k + R + 5] = o.y, b[k + R + 6] = o.z, b[k + R + 7] = 0)
                                    }
                                p = {
                                    count: f,
                                    texture: w,
                                    size: new e4(_, x)
                                }, a.set(u, p)
                            }
                            for (var C = 0, L = 0; L < d.length; L++) C += d[L];
                            var P = u.morphTargetsRelative ? 1 : 1 - C;
                            h.getUniforms().setValue(e, "morphTargetBaseInfluence", P), h.getUniforms().setValue(e, "morphTargetInfluences", d), h.getUniforms().setValue(e, "morphTargetsTexture", p.texture, n), h.getUniforms().setValue(e, "morphTargetsTextureSize", p.size)
                        } else {
                            var I = void 0 === d ? 0 : d.length,
                                D = r[u.id];
                            if (void 0 === D || D.length !== I) {
                                D = [];
                                for (var O = 0; O < I; O++) D[O] = [O, 0];
                                r[u.id] = D
                            }
                            for (var N = 0; N < I; N++) {
                                var F = D[N];
                                F[0] = N, F[1] = d[N]
                            }
                            D.sort(rX);
                            for (var U = 0; U < 8; U++) U < I && D[U][1] ? (s[U][0] = D[U][0], s[U][1] = D[U][1]) : (s[U][0] = Number.MAX_SAFE_INTEGER, s[U][1] = 0);
                            s.sort(rq);
                            for (var B = u.morphAttributes.position, z = u.morphAttributes.normal, H = 0, V = 0; V < 8; V++) {
                                var G = s[V],
                                    W = G[0],
                                    j = G[1];
                                W !== Number.MAX_SAFE_INTEGER && j ? (B && u.getAttribute("morphTarget" + V) !== B[W] && u.setAttribute("morphTarget" + V, B[W]), z && u.getAttribute("morphNormal" + V) !== z[W] && u.setAttribute("morphNormal" + V, z[W]), i[V] = j, H += j) : (B && !0 === u.hasAttribute("morphTarget" + V) && u.deleteAttribute("morphTarget" + V), z && !0 === u.hasAttribute("morphNormal" + V) && u.deleteAttribute("morphNormal" + V), i[V] = 0)
                            }
                            var q = u.morphTargetsRelative ? 1 : 1 - H;
                            h.getUniforms().setValue(e, "morphTargetBaseInfluence", q), h.getUniforms().setValue(e, "morphTargetInfluences", i)
                        }
                    }
                }
            }

            function rZ(e, t, n, r) {
                var i = new WeakMap;

                function a(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", a), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
                }
                return {
                    update: function(e) {
                        var o = r.render.frame,
                            s = e.geometry,
                            l = t.get(e, s);
                        return i.get(l) !== o && (t.update(l), i.set(l, o)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", a) && e.addEventListener("dispose", a), n.update(e.instanceMatrix, 34962), null !== e.instanceColor && n.update(e.instanceColor, 34962)), l
                    },
                    dispose: function() {
                        i = new WeakMap
                    }
                }
            }
            rj.prototype.isDataTexture2DArray = !0;
            var rK = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                        a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                    return (0, k._)(this, t), (e = (0, E._)(this, t, [null])).image = {
                        data: n,
                        width: r,
                        height: i,
                        depth: a
                    }, e.magFilter = 1003, e.minFilter = 1003, e.wrapR = 1001, e.generateMipmaps = !1, e.flipY = !1, e.unpackAlignment = 1, e
                }
                return (0, P._)(t, e), t
            }(te);
            rK.prototype.isDataTexture3D = !0;
            var rQ = new te,
                r$ = new rj,
                r0 = new rK,
                r1 = new n8,
                r2 = [],
                r3 = [],
                r4 = new Float32Array(16),
                r5 = new Float32Array(9),
                r6 = new Float32Array(4);

            function r8(e, t, n) {
                var r = e[0];
                if (r <= 0 || r > 0) return e;
                var i = t * n,
                    a = r2[i];
                if (void 0 === a && (a = new Float32Array(i), r2[i] = a), 0 !== t) {
                    r.toArray(a, 0);
                    for (var o = 1, s = 0; o !== t; ++o) s += n, e[o].toArray(a, s)
                }
                return a
            }

            function r7(e, t) {
                if (e.length !== t.length) return !1;
                for (var n = 0, r = e.length; n < r; n++)
                    if (e[n] !== t[n]) return !1;
                return !0
            }

            function r9(e, t) {
                for (var n = 0, r = t.length; n < r; n++) e[n] = t[n]
            }

            function ie(e, t) {
                var n = r3[t];
                void 0 === n && (n = new Int32Array(t), r3[t] = n);
                for (var r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
                return n
            }

            function it(e, t) {
                var n = this.cache;
                n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
            }

            function ir(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (r7(n, t)) return;
                    e.uniform2fv(this.addr, t), r9(n, t)
                }
            }

            function ii(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
                else {
                    if (r7(n, t)) return;
                    e.uniform3fv(this.addr, t), r9(n, t)
                }
            }

            function ia(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (r7(n, t)) return;
                    e.uniform4fv(this.addr, t), r9(n, t)
                }
            }

            function io(e, t) {
                var n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (r7(n, t)) return;
                    e.uniformMatrix2fv(this.addr, !1, t), r9(n, t)
                } else {
                    if (r7(n, r)) return;
                    r6.set(r), e.uniformMatrix2fv(this.addr, !1, r6), r9(n, r)
                }
            }

            function is(e, t) {
                var n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (r7(n, t)) return;
                    e.uniformMatrix3fv(this.addr, !1, t), r9(n, t)
                } else {
                    if (r7(n, r)) return;
                    r5.set(r), e.uniformMatrix3fv(this.addr, !1, r5), r9(n, r)
                }
            }

            function il(e, t) {
                var n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (r7(n, t)) return;
                    e.uniformMatrix4fv(this.addr, !1, t), r9(n, t)
                } else {
                    if (r7(n, r)) return;
                    r4.set(r), e.uniformMatrix4fv(this.addr, !1, r4), r9(n, r)
                }
            }

            function iu(e, t) {
                var n = this.cache;
                n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
            }

            function ic(e, t) {
                var n = this.cache;
                r7(n, t) || (e.uniform2iv(this.addr, t), r9(n, t))
            }

            function ih(e, t) {
                var n = this.cache;
                r7(n, t) || (e.uniform3iv(this.addr, t), r9(n, t))
            }

            function id(e, t) {
                var n = this.cache;
                r7(n, t) || (e.uniform4iv(this.addr, t), r9(n, t))
            }

            function ip(e, t) {
                var n = this.cache;
                n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
            }

            function im(e, t) {
                var n = this.cache;
                r7(n, t) || (e.uniform2uiv(this.addr, t), r9(n, t))
            }

            function iv(e, t) {
                var n = this.cache;
                r7(n, t) || (e.uniform3uiv(this.addr, t), r9(n, t))
            }

            function ig(e, t) {
                var n = this.cache;
                r7(n, t) || (e.uniform4uiv(this.addr, t), r9(n, t))
            }

            function iy(e, t, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(t || rQ, i)
            }

            function i_(e, t, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || r0, i)
            }

            function ix(e, t, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(t || r1, i)
            }

            function ib(e, t, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || r$, i)
            }

            function iw(e, t) {
                e.uniform1fv(this.addr, t)
            }

            function iM(e, t) {
                var n = r8(t, this.size, 2);
                e.uniform2fv(this.addr, n)
            }

            function iS(e, t) {
                var n = r8(t, this.size, 3);
                e.uniform3fv(this.addr, n)
            }

            function iT(e, t) {
                var n = r8(t, this.size, 4);
                e.uniform4fv(this.addr, n)
            }

            function iE(e, t) {
                var n = r8(t, this.size, 4);
                e.uniformMatrix2fv(this.addr, !1, n)
            }

            function ik(e, t) {
                var n = r8(t, this.size, 9);
                e.uniformMatrix3fv(this.addr, !1, n)
            }

            function iA(e, t) {
                var n = r8(t, this.size, 16);
                e.uniformMatrix4fv(this.addr, !1, n)
            }

            function iR(e, t) {
                e.uniform1iv(this.addr, t)
            }

            function iC(e, t) {
                e.uniform2iv(this.addr, t)
            }

            function iL(e, t) {
                e.uniform3iv(this.addr, t)
            }

            function iP(e, t) {
                e.uniform4iv(this.addr, t)
            }

            function iI(e, t) {
                e.uniform1uiv(this.addr, t)
            }

            function iD(e, t) {
                e.uniform2uiv(this.addr, t)
            }

            function iO(e, t) {
                e.uniform3uiv(this.addr, t)
            }

            function iN(e, t) {
                e.uniform4uiv(this.addr, t)
            }

            function iF(e, t, n) {
                var r = t.length,
                    i = ie(n, r);
                e.uniform1iv(this.addr, i);
                for (var a = 0; a !== r; ++a) n.safeSetTexture2D(t[a] || rQ, i[a])
            }

            function iU(e, t, n) {
                var r = t.length,
                    i = ie(n, r);
                e.uniform1iv(this.addr, i);
                for (var a = 0; a !== r; ++a) n.setTexture3D(t[a] || r0, i[a])
            }

            function iB(e, t, n) {
                var r = t.length,
                    i = ie(n, r);
                e.uniform1iv(this.addr, i);
                for (var a = 0; a !== r; ++a) n.safeSetTextureCube(t[a] || r1, i[a])
            }

            function iz(e, t, n) {
                var r = t.length,
                    i = ie(n, r);
                e.uniform1iv(this.addr, i);
                for (var a = 0; a !== r; ++a) n.setTexture2DArray(t[a] || r$, i[a])
            }

            function iH(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.setValue = function(e) {
                    switch (e) {
                        case 5126:
                            return it;
                        case 35664:
                            return ir;
                        case 35665:
                            return ii;
                        case 35666:
                            return ia;
                        case 35674:
                            return io;
                        case 35675:
                            return is;
                        case 35676:
                            return il;
                        case 5124:
                        case 35670:
                            return iu;
                        case 35667:
                        case 35671:
                            return ic;
                        case 35668:
                        case 35672:
                            return ih;
                        case 35669:
                        case 35673:
                            return id;
                        case 5125:
                            return ip;
                        case 36294:
                            return im;
                        case 36295:
                            return iv;
                        case 36296:
                            return ig;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return iy;
                        case 35679:
                        case 36299:
                        case 36307:
                            return i_;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return ix;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return ib
                    }
                }(t.type)
            }

            function iV(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function(e) {
                    switch (e) {
                        case 5126:
                            return iw;
                        case 35664:
                            return iM;
                        case 35665:
                            return iS;
                        case 35666:
                            return iT;
                        case 35674:
                            return iE;
                        case 35675:
                            return ik;
                        case 35676:
                            return iA;
                        case 5124:
                        case 35670:
                            return iR;
                        case 35667:
                        case 35671:
                            return iC;
                        case 35668:
                        case 35672:
                            return iL;
                        case 35669:
                        case 35673:
                            return iP;
                        case 5125:
                            return iI;
                        case 36294:
                            return iD;
                        case 36295:
                            return iO;
                        case 36296:
                            return iN;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return iF;
                        case 35679:
                        case 36299:
                        case 36307:
                            return iU;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return iB;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return iz
                    }
                }(t.type)
            }

            function iG(e) {
                this.id = e, this.seq = [], this.map = {}
            }
            iV.prototype.updateCache = function(e) {
                var t = this.cache;
                e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), r9(t, e)
            }, iG.prototype.setValue = function(e, t, n) {
                for (var r = this.seq, i = 0, a = r.length; i !== a; ++i) {
                    var o = r[i];
                    o.setValue(e, t[o.id], n)
                }
            };
            var iW = /(\w+)(\])?(\[|\.)?/g;

            function ij(e, t) {
                e.seq.push(t), e.map[t.id] = t
            }

            function iq(e, t) {
                this.seq = [], this.map = {};
                for (var n = e.getProgramParameter(t, 35718), r = 0; r < n; ++r) {
                    var i = e.getActiveUniform(t, r);
                    ! function(e, t, n) {
                        var r = e.name,
                            i = r.length;
                        for (iW.lastIndex = 0;;) {
                            var a = iW.exec(r),
                                o = iW.lastIndex,
                                s = a[1],
                                l = "]" === a[2],
                                u = a[3];
                            if (l && (s |= 0), void 0 === u || "[" === u && o + 2 === i) {
                                ij(n, void 0 === u ? new iH(s, e, t) : new iV(s, e, t));
                                break
                            }
                            var c = n.map[s];
                            void 0 === c && ij(n, c = new iG(s)), n = c
                        }
                    }(i, e.getUniformLocation(t, i.name), this)
                }
            }

            function iX(e, t, n) {
                var r = e.createShader(t);
                return e.shaderSource(r, n), e.compileShader(r), r
            }
            iq.prototype.setValue = function(e, t, n, r) {
                var i = this.map[t];
                void 0 !== i && i.setValue(e, n, r)
            }, iq.prototype.setOptional = function(e, t, n) {
                var r = t[n];
                void 0 !== r && this.setValue(e, n, r)
            }, iq.upload = function(e, t, n, r) {
                for (var i = 0, a = t.length; i !== a; ++i) {
                    var o = t[i],
                        s = n[o.id];
                    !1 !== s.needsUpdate && o.setValue(e, s.value, r)
                }
            }, iq.seqWithValue = function(e, t) {
                for (var n = [], r = 0, i = e.length; r !== i; ++r) {
                    var a = e[r];
                    a.id in t && n.push(a)
                }
                return n
            };
            var iY = 0;

            function iJ(e) {
                switch (e) {
                    case 3e3:
                        return ["Linear", "( value )"];
                    case 3001:
                        return ["sRGB", "( value )"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"]
                }
            }

            function iZ(e, t, n) {
                var r = e.getShaderParameter(t, 35713),
                    i = e.getShaderInfoLog(t).trim();
                return r && "" === i ? "" : n.toUpperCase() + "\n\n" + i + "\n\n" + function(e) {
                    for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
                    return t.join("\n")
                }(e.getShaderSource(t))
            }

            function iK(e, t) {
                var n = iJ(t);
                return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }

            function iQ(e) {
                return "" !== e
            }

            function i$(e, t) {
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
            }

            function i0(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }
            var i1 = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function i2(e) {
                return e.replace(i1, i3)
            }

            function i3(e, t) {
                var n = ru[t];
                if (void 0 === n) throw Error("Can not resolve #include <" + t + ">");
                return i2(n)
            }
            var i4 = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                i5 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function i6(e) {
                return e.replace(i5, i7).replace(i4, i8)
            }

            function i8(e, t, n, r) {
                return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), i7(e, t, n, r)
            }

            function i7(e, t, n, r) {
                for (var i = "", a = parseInt(t); a < parseInt(n); a++) i += r.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
                return i
            }

            function i9(e) {
                var t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
                return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
            }

            function ae(e, t, n, r) {
                var i, a, o, s, l, u, c = e.getContext(),
                    h = n.defines,
                    d = n.vertexShader,
                    f = n.fragmentShader,
                    p = (s = "SHADOWMAP_TYPE_BASIC", 1 === n.shadowMapType ? s = "SHADOWMAP_TYPE_PCF" : 2 === n.shadowMapType ? s = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === n.shadowMapType && (s = "SHADOWMAP_TYPE_VSM"), s),
                    m = function(e) {
                        var t = "ENVMAP_TYPE_CUBE";
                        if (e.envMap) switch (e.envMapMode) {
                            case 301:
                            case 302:
                                t = "ENVMAP_TYPE_CUBE";
                                break;
                            case 306:
                            case 307:
                                t = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return t
                    }(n),
                    v = function(e) {
                        var t = "ENVMAP_MODE_REFLECTION";
                        if (e.envMap) switch (e.envMapMode) {
                            case 302:
                            case 307:
                                t = "ENVMAP_MODE_REFRACTION"
                        }
                        return t
                    }(n),
                    g = function(e) {
                        var t = "ENVMAP_BLENDING_NONE";
                        if (e.envMap) switch (e.combine) {
                            case 0:
                                t = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case 1:
                                t = "ENVMAP_BLENDING_MIX";
                                break;
                            case 2:
                                t = "ENVMAP_BLENDING_ADD"
                        }
                        return t
                    }(n),
                    y = n.isWebGL2 ? "" : [n.extensionDerivatives || n.envMapCubeUV || n.bumpMap || n.tangentSpaceNormalMap || n.clearcoatNormalMap || n.flatShading || "physical" === n.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(iQ).join("\n"),
                    _ = function(e) {
                        var t = [];
                        for (var n in e) {
                            var r = e[n];
                            !1 !== r && t.push("#define " + n + " " + r)
                        }
                        return t.join("\n")
                    }(h),
                    x = c.createProgram(),
                    b = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                n.isRawShaderMaterial ? ((l = [_].filter(iQ).join("\n")).length > 0 && (l += "\n"), (u = [y, _].filter(iQ).join("\n")).length > 0 && (u += "\n")) : (l = [i9(n), "#define SHADER_NAME " + n.shaderName, _, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + v : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(iQ).join("\n"), u = [y, i9(n), "#define SHADER_NAME " + n.shaderName, _, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + m : "", n.envMap ? "#define " + v : "", n.envMap ? "#define " + g : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? ru.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? function(e, t) {
                    var n;
                    switch (t) {
                        case 1:
                            n = "Linear";
                            break;
                        case 2:
                            n = "Reinhard";
                            break;
                        case 3:
                            n = "OptimizedCineon";
                            break;
                        case 4:
                            n = "ACESFilmic";
                            break;
                        case 5:
                            n = "Custom";
                            break;
                        default:
                            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear"
                    }
                    return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", 1022 === n.format ? "#define OPAQUE" : "", ru.encodings_pars_fragment, n.map ? iK("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? iK("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? iK("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? iK("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.specularColorMap ? iK("specularColorMapTexelToLinear", n.specularColorMapEncoding) : "", n.sheenColorMap ? iK("sheenColorMapTexelToLinear", n.sheenColorMapEncoding) : "", n.lightMap ? iK("lightMapTexelToLinear", n.lightMapEncoding) : "", "vec4 linearToOutputTexel( vec4 value ) { return LinearTo" + (i = iJ(n.outputEncoding))[0] + i[1] + "; }", n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(iQ).join("\n")), d = i0(d = i$(d = i2(d), n), n), f = i0(f = i$(f = i2(f), n), n), d = i6(d), f = i6(f), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (b = "#version 300 es\n", l = "precision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\n" + l, u = ["#define varying in", "300 es" === n.glslVersion ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", "300 es" === n.glslVersion ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + u);
                var w = b + u + f,
                    M = iX(c, 35633, b + l + d),
                    S = iX(c, 35632, w);
                if (c.attachShader(x, M), c.attachShader(x, S), void 0 !== n.index0AttributeName ? c.bindAttribLocation(x, 0, n.index0AttributeName) : !0 === n.morphTargets && c.bindAttribLocation(x, 0, "position"), c.linkProgram(x), e.debug.checkShaderErrors) {
                    var T = c.getProgramInfoLog(x).trim(),
                        E = c.getShaderInfoLog(M).trim(),
                        k = c.getShaderInfoLog(S).trim(),
                        A = !0,
                        R = !0;
                    if (!1 === c.getProgramParameter(x, 35714)) {
                        A = !1;
                        var C = iZ(c, M, "vertex"),
                            L = iZ(c, S, "fragment");
                        console.error("THREE.WebGLProgram: Shader Error " + c.getError() + " - VALIDATE_STATUS " + c.getProgramParameter(x, 35715) + "\n\nProgram Info Log: " + T + "\n" + C + "\n" + L)
                    } else "" !== T ? console.warn("THREE.WebGLProgram: Program Info Log:", T) : "" !== E && "" !== k || (R = !1);
                    R && (this.diagnostics = {
                        runnable: A,
                        programLog: T,
                        vertexShader: {
                            log: E,
                            prefix: l
                        },
                        fragmentShader: {
                            log: k,
                            prefix: u
                        }
                    })
                }
                return c.deleteShader(M), c.deleteShader(S), this.getUniforms = function() {
                    return void 0 === a && (a = new iq(c, x)), a
                }, this.getAttributes = function() {
                    return void 0 === o && (o = function(e, t) {
                        for (var n = {}, r = e.getProgramParameter(t, 35721), i = 0; i < r; i++) {
                            var a = e.getActiveAttrib(t, i),
                                o = a.name,
                                s = 1;
                            35674 === a.type && (s = 2), 35675 === a.type && (s = 3), 35676 === a.type && (s = 4), n[o] = {
                                type: a.type,
                                location: e.getAttribLocation(t, o),
                                locationSize: s
                            }
                        }
                        return n
                    }(c, x)), o
                }, this.destroy = function() {
                    r.releaseStatesOfProgram(this), c.deleteProgram(x), this.program = void 0
                }, this.name = n.shaderName, this.id = iY++, this.cacheKey = t, this.usedTimes = 1, this.program = x, this.vertexShader = M, this.fragmentShader = S, this
            }
            var at = 0,
                an = function() {
                    function e() {
                        (0, k._)(this, e), this.shaderCache = new Map, this.materialCache = new Map
                    }
                    return (0, A._)(e, [{
                        key: "update",
                        value: function(e) {
                            var t = e.vertexShader,
                                n = e.fragmentShader,
                                r = this._getShaderStage(t),
                                i = this._getShaderStage(n),
                                a = this._getShaderCacheForMaterial(e);
                            return !1 === a.has(r) && (a.add(r), r.usedTimes++), !1 === a.has(i) && (a.add(i), i.usedTimes++), this
                        }
                    }, {
                        key: "remove",
                        value: function(e) {
                            var t = this.materialCache.get(e),
                                n = !0,
                                r = !1,
                                i = void 0;
                            try {
                                for (var a, o = t[Symbol.iterator](); !(n = (a = o.next()).done); n = !0) {
                                    var s = a.value;
                                    s.usedTimes--, 0 === s.usedTimes && this.shaderCache.delete(s)
                                }
                            } catch (e) {
                                r = !0, i = e
                            } finally {
                                try {
                                    n || null == o.return || o.return()
                                } finally {
                                    if (r) throw i
                                }
                            }
                            return this.materialCache.delete(e), this
                        }
                    }, {
                        key: "getVertexShaderID",
                        value: function(e) {
                            return this._getShaderStage(e.vertexShader).id
                        }
                    }, {
                        key: "getFragmentShaderID",
                        value: function(e) {
                            return this._getShaderStage(e.fragmentShader).id
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            this.shaderCache.clear(), this.materialCache.clear()
                        }
                    }, {
                        key: "_getShaderCacheForMaterial",
                        value: function(e) {
                            var t = this.materialCache;
                            return !1 === t.has(e) && t.set(e, new Set), t.get(e)
                        }
                    }, {
                        key: "_getShaderStage",
                        value: function(e) {
                            var t = this.shaderCache;
                            if (!1 === t.has(e)) {
                                var n = new ar;
                                t.set(e, n)
                            }
                            return t.get(e)
                        }
                    }]), e
                }(),
                ar = function e() {
                    (0, k._)(this, e), this.id = at++, this.usedTimes = 0
                };

            function ai(e, t, n, r, i, a, o) {
                var s = new tY,
                    l = new an,
                    u = [],
                    c = i.isWebGL2,
                    h = i.logarithmicDepthBuffer,
                    d = i.floatVertexTextures,
                    f = i.maxVertexUniforms,
                    p = i.vertexTextures,
                    m = i.precision,
                    v = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    };

                function g(e) {
                    var t;
                    return e && e.isTexture ? t = e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = e.texture.encoding) : t = 3e3, c && e && e.isTexture && 1023 === e.format && 1009 === e.type && 3001 === e.encoding && (t = 3e3), t
                }
                return {
                    getParameters: function(a, s, u, y, _) {
                        var x, b, w, M, S = y.fog,
                            T = a.isMeshStandardMaterial ? y.environment : null,
                            E = (a.isMeshStandardMaterial ? n : t).get(a.envMap || T),
                            k = v[a.type],
                            A = _.isSkinnedMesh ? function(e) {
                                var t = e.skeleton.bones;
                                if (d) return 1024;
                                var n = Math.min(Math.floor((f - 20) / 4), t.length);
                                return n < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + n + "."), 0) : n
                            }(_) : 0;
                        if (null !== a.precision && (m = i.getMaxPrecision(a.precision)) !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", m, "instead."), k) {
                            var R = rh[k];
                            x = R.vertexShader, b = R.fragmentShader
                        } else x = a.vertexShader, b = a.fragmentShader, l.update(a), w = l.getVertexShaderID(a), M = l.getFragmentShaderID(a);
                        var C = e.getRenderTarget(),
                            L = a.alphaTest > 0,
                            P = a.clearcoat > 0;
                        return {
                            isWebGL2: c,
                            shaderID: k,
                            shaderName: a.type,
                            vertexShader: x,
                            fragmentShader: b,
                            defines: a.defines,
                            customVertexShaderID: w,
                            customFragmentShaderID: M,
                            isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                            glslVersion: a.glslVersion,
                            precision: m,
                            instancing: !0 === _.isInstancedMesh,
                            instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor,
                            supportsVertexTextures: p,
                            outputEncoding: null !== C ? g(C.texture) : e.outputEncoding,
                            map: !!a.map,
                            mapEncoding: g(a.map),
                            matcap: !!a.matcap,
                            matcapEncoding: g(a.matcap),
                            envMap: !!E,
                            envMapMode: E && E.mapping,
                            envMapEncoding: g(E),
                            envMapCubeUV: !!E && (306 === E.mapping || 307 === E.mapping),
                            lightMap: !!a.lightMap,
                            lightMapEncoding: g(a.lightMap),
                            aoMap: !!a.aoMap,
                            emissiveMap: !!a.emissiveMap,
                            emissiveMapEncoding: g(a.emissiveMap),
                            bumpMap: !!a.bumpMap,
                            normalMap: !!a.normalMap,
                            objectSpaceNormalMap: 1 === a.normalMapType,
                            tangentSpaceNormalMap: 0 === a.normalMapType,
                            clearcoat: P,
                            clearcoatMap: P && !!a.clearcoatMap,
                            clearcoatRoughnessMap: P && !!a.clearcoatRoughnessMap,
                            clearcoatNormalMap: P && !!a.clearcoatNormalMap,
                            displacementMap: !!a.displacementMap,
                            roughnessMap: !!a.roughnessMap,
                            metalnessMap: !!a.metalnessMap,
                            specularMap: !!a.specularMap,
                            specularIntensityMap: !!a.specularIntensityMap,
                            specularColorMap: !!a.specularColorMap,
                            specularColorMapEncoding: g(a.specularColorMap),
                            alphaMap: !!a.alphaMap,
                            alphaTest: L,
                            gradientMap: !!a.gradientMap,
                            sheen: a.sheen > 0,
                            sheenColorMap: !!a.sheenColorMap,
                            sheenColorMapEncoding: g(a.sheenColorMap),
                            sheenRoughnessMap: !!a.sheenRoughnessMap,
                            transmission: a.transmission > 0,
                            transmissionMap: !!a.transmissionMap,
                            thicknessMap: !!a.thicknessMap,
                            combine: a.combine,
                            vertexTangents: !!a.normalMap && !!_.geometry && !!_.geometry.attributes.tangent,
                            vertexColors: a.vertexColors,
                            vertexAlphas: !0 === a.vertexColors && !!_.geometry && !!_.geometry.attributes.color && 4 === _.geometry.attributes.color.itemSize,
                            vertexUvs: !!(a.map || a.bumpMap || a.normalMap || a.specularMap || a.alphaMap || a.emissiveMap || a.roughnessMap || a.metalnessMap || a.clearcoatMap || a.clearcoatRoughnessMap || a.clearcoatNormalMap || a.displacementMap || a.transmissionMap || a.thicknessMap || a.specularIntensityMap || a.specularColorMap || a.sheenColorMap || a.sheenRoughnessMap),
                            uvsVertexOnly: !(a.map || a.bumpMap || a.normalMap || a.specularMap || a.alphaMap || a.emissiveMap || a.roughnessMap || a.metalnessMap || a.clearcoatNormalMap || a.transmission > 0 || a.transmissionMap || a.thicknessMap || a.specularIntensityMap || a.specularColorMap || a.sheen > 0 || a.sheenColorMap || a.sheenRoughnessMap || !a.displacementMap),
                            fog: !!S,
                            useFog: a.fog,
                            fogExp2: S && S.isFogExp2,
                            flatShading: !!a.flatShading,
                            sizeAttenuation: a.sizeAttenuation,
                            logarithmicDepthBuffer: h,
                            skinning: !0 === _.isSkinnedMesh && A > 0,
                            maxBones: A,
                            useVertexTexture: d,
                            morphTargets: !!_.geometry && !!_.geometry.morphAttributes.position,
                            morphNormals: !!_.geometry && !!_.geometry.morphAttributes.normal,
                            morphTargetsCount: _.geometry && _.geometry.morphAttributes.position ? _.geometry.morphAttributes.position.length : 0,
                            numDirLights: s.directional.length,
                            numPointLights: s.point.length,
                            numSpotLights: s.spot.length,
                            numRectAreaLights: s.rectArea.length,
                            numHemiLights: s.hemi.length,
                            numDirLightShadows: s.directionalShadowMap.length,
                            numPointLightShadows: s.pointShadowMap.length,
                            numSpotLightShadows: s.spotShadowMap.length,
                            numClippingPlanes: o.numPlanes,
                            numClipIntersection: o.numIntersection,
                            format: a.format,
                            dithering: a.dithering,
                            shadowMapEnabled: e.shadowMap.enabled && u.length > 0,
                            shadowMapType: e.shadowMap.type,
                            toneMapping: a.toneMapped ? e.toneMapping : 0,
                            physicallyCorrectLights: e.physicallyCorrectLights,
                            premultipliedAlpha: a.premultipliedAlpha,
                            doubleSided: 2 === a.side,
                            flipSided: 1 === a.side,
                            depthPacking: void 0 !== a.depthPacking && a.depthPacking,
                            index0AttributeName: a.index0AttributeName,
                            extensionDerivatives: a.extensions && a.extensions.derivatives,
                            extensionFragDepth: a.extensions && a.extensions.fragDepth,
                            extensionDrawBuffers: a.extensions && a.extensions.drawBuffers,
                            extensionShaderTextureLOD: a.extensions && a.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: c || r.has("EXT_frag_depth"),
                            rendererExtensionDrawBuffers: c || r.has("WEBGL_draw_buffers"),
                            rendererExtensionShaderTextureLod: c || r.has("EXT_shader_texture_lod"),
                            customProgramCacheKey: a.customProgramCacheKey()
                        }
                    },
                    getProgramCacheKey: function(t) {
                        var n = [];
                        if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines)
                            for (var r in t.defines) n.push(r), n.push(t.defines[r]);
                        return !1 === t.isRawShaderMaterial && (n.push(t.precision), n.push(t.outputEncoding), n.push(t.mapEncoding), n.push(t.matcapEncoding), n.push(t.envMapMode), n.push(t.envMapEncoding), n.push(t.lightMapEncoding), n.push(t.emissiveMapEncoding), n.push(t.combine), n.push(t.vertexUvs), n.push(t.fogExp2), n.push(t.sizeAttenuation), n.push(t.maxBones), n.push(t.morphTargetsCount), n.push(t.numDirLights), n.push(t.numPointLights), n.push(t.numSpotLights), n.push(t.numHemiLights), n.push(t.numRectAreaLights), n.push(t.numDirLightShadows), n.push(t.numPointLightShadows), n.push(t.numSpotLightShadows), n.push(t.shadowMapType), n.push(t.toneMapping), n.push(t.numClippingPlanes), n.push(t.numClipIntersection), n.push(t.format), n.push(t.specularColorMapEncoding), n.push(t.sheenColorMapEncoding), s.disableAll(), t.isWebGL2 && s.enable(0), t.supportsVertexTextures && s.enable(1), t.instancing && s.enable(2), t.instancingColor && s.enable(3), t.map && s.enable(4), t.matcap && s.enable(5), t.envMap && s.enable(6), t.envMapCubeUV && s.enable(7), t.lightMap && s.enable(8), t.aoMap && s.enable(9), t.emissiveMap && s.enable(10), t.bumpMap && s.enable(11), t.normalMap && s.enable(12), t.objectSpaceNormalMap && s.enable(13), t.tangentSpaceNormalMap && s.enable(14), t.clearcoat && s.enable(15), t.clearcoatMap && s.enable(16), t.clearcoatRoughnessMap && s.enable(17), t.clearcoatNormalMap && s.enable(18), t.displacementMap && s.enable(19), t.specularMap && s.enable(20), t.roughnessMap && s.enable(21), t.metalnessMap && s.enable(22), t.gradientMap && s.enable(23), t.alphaMap && s.enable(24), t.alphaTest && s.enable(25), t.vertexColors && s.enable(26), t.vertexAlphas && s.enable(27), t.vertexUvs && s.enable(28), t.vertexTangents && s.enable(29), t.uvsVertexOnly && s.enable(30), t.fog && s.enable(31), n.push(s.mask), s.disableAll(), t.useFog && s.enable(0), t.flatShading && s.enable(1), t.logarithmicDepthBuffer && s.enable(2), t.skinning && s.enable(3), t.useVertexTexture && s.enable(4), t.morphTargets && s.enable(5), t.morphNormals && s.enable(6), t.premultipliedAlpha && s.enable(7), t.shadowMapEnabled && s.enable(8), t.physicallyCorrectLights && s.enable(9), t.doubleSided && s.enable(10), t.flipSided && s.enable(11), t.depthPacking && s.enable(12), t.dithering && s.enable(13), t.specularIntensityMap && s.enable(14), t.specularColorMap && s.enable(15), t.transmission && s.enable(16), t.transmissionMap && s.enable(17), t.thicknessMap && s.enable(18), t.sheen && s.enable(19), t.sheenColorMap && s.enable(20), t.sheenRoughnessMap && s.enable(21), n.push(s.mask), n.push(e.outputEncoding)), n.push(t.customProgramCacheKey), n.join()
                    },
                    getUniforms: function(e) {
                        var t, n = v[e.type];
                        if (n) {
                            var r = rh[n];
                            t = n2.clone(r.uniforms)
                        } else t = e.uniforms;
                        return t
                    },
                    acquireProgram: function(t, n) {
                        for (var r, i = 0, o = u.length; i < o; i++) {
                            var s = u[i];
                            if (s.cacheKey === n) {
                                r = s, ++r.usedTimes;
                                break
                            }
                        }
                        return void 0 === r && (r = new ae(e, n, t, a), u.push(r)), r
                    },
                    releaseProgram: function(e) {
                        if (0 == --e.usedTimes) {
                            var t = u.indexOf(e);
                            u[t] = u[u.length - 1], u.pop(), e.destroy()
                        }
                    },
                    releaseShaderCache: function(e) {
                        l.remove(e)
                    },
                    programs: u,
                    dispose: function() {
                        l.dispose()
                    }
                }
            }

            function aa() {
                var e = new WeakMap;
                return {
                    get: function(t) {
                        var n = e.get(t);
                        return void 0 === n && (n = {}, e.set(t, n)), n
                    },
                    remove: function(t) {
                        e.delete(t)
                    },
                    update: function(t, n, r) {
                        e.get(t)[n] = r
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function ao(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }

            function as(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }

            function al() {
                var e = [],
                    t = 0,
                    n = [],
                    r = [],
                    i = [];

                function a(n, r, i, a, o, s) {
                    var l = e[t];
                    return void 0 === l ? (l = {
                        id: n.id,
                        object: n,
                        geometry: r,
                        material: i,
                        groupOrder: a,
                        renderOrder: n.renderOrder,
                        z: o,
                        group: s
                    }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = r, l.material = i, l.groupOrder = a, l.renderOrder = n.renderOrder, l.z = o, l.group = s), t++, l
                }
                return {
                    opaque: n,
                    transmissive: r,
                    transparent: i,
                    init: function() {
                        t = 0, n.length = 0, r.length = 0, i.length = 0
                    },
                    push: function(e, t, o, s, l, u) {
                        var c = a(e, t, o, s, l, u);
                        o.transmission > 0 ? r.push(c) : !0 === o.transparent ? i.push(c) : n.push(c)
                    },
                    unshift: function(e, t, o, s, l, u) {
                        var c = a(e, t, o, s, l, u);
                        o.transmission > 0 ? r.unshift(c) : !0 === o.transparent ? i.unshift(c) : n.unshift(c)
                    },
                    finish: function() {
                        for (var n = t, r = e.length; n < r; n++) {
                            var i = e[n];
                            if (null === i.id) break;
                            i.id = null, i.object = null, i.geometry = null, i.material = null, i.group = null
                        }
                    },
                    sort: function(e, t) {
                        n.length > 1 && n.sort(e || ao), r.length > 1 && r.sort(t || as), i.length > 1 && i.sort(t || as)
                    }
                }
            }

            function au() {
                var e = new WeakMap;
                return {
                    get: function(t, n) {
                        var r;
                        return !1 === e.has(t) ? (r = new al, e.set(t, [r])) : n >= e.get(t).length ? (r = new al, e.get(t).push(r)) : r = e.get(t)[n], r
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function ac() {
                var e = {};
                return {
                    get: function(t) {
                        var n;
                        if (void 0 !== e[t.id]) return e[t.id];
                        switch (t.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new to,
                                    color: new ny
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new to,
                                    direction: new to,
                                    color: new ny,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new to,
                                    color: new ny,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new to,
                                    skyColor: new ny,
                                    groundColor: new ny
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new ny,
                                    position: new to,
                                    halfWidth: new to,
                                    halfHeight: new to
                                }
                        }
                        return e[t.id] = n, n
                    }
                }
            }
            var ah = 0;

            function ad(e, t) {
                return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
            }

            function af(e, t) {
                for (var n, r = new ac, i = (n = {}, {
                        get: function(e) {
                            var t;
                            if (void 0 !== n[e.id]) return n[e.id];
                            switch (e.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    t = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new e4
                                    };
                                    break;
                                case "PointLight":
                                    t = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new e4,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                            }
                            return n[e.id] = t, t
                        }
                    }), a = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    }, o = 0; o < 9; o++) a.probe.push(new to);
                var s = new to,
                    l = new tF,
                    u = new tF;
                return {
                    setup: function(n, o) {
                        for (var s = 0, l = 0, u = 0, c = 0; c < 9; c++) a.probe[c].set(0, 0, 0);
                        var h = 0,
                            d = 0,
                            f = 0,
                            p = 0,
                            m = 0,
                            v = 0,
                            g = 0,
                            y = 0;
                        n.sort(ad);
                        for (var _ = !0 !== o ? Math.PI : 1, x = 0, b = n.length; x < b; x++) {
                            var w = n[x],
                                M = w.color,
                                S = w.intensity,
                                T = w.distance,
                                E = w.shadow && w.shadow.map ? w.shadow.map.texture : null;
                            if (w.isAmbientLight) s += M.r * S * _, l += M.g * S * _, u += M.b * S * _;
                            else if (w.isLightProbe)
                                for (var k = 0; k < 9; k++) a.probe[k].addScaledVector(w.sh.coefficients[k], S);
                            else if (w.isDirectionalLight) {
                                var A = r.get(w);
                                if (A.color.copy(w.color).multiplyScalar(w.intensity * _), w.castShadow) {
                                    var R = w.shadow,
                                        C = i.get(w);
                                    C.shadowBias = R.bias, C.shadowNormalBias = R.normalBias, C.shadowRadius = R.radius, C.shadowMapSize = R.mapSize, a.directionalShadow[h] = C, a.directionalShadowMap[h] = E, a.directionalShadowMatrix[h] = w.shadow.matrix, v++
                                }
                                a.directional[h] = A, h++
                            } else if (w.isSpotLight) {
                                var L = r.get(w);
                                if (L.position.setFromMatrixPosition(w.matrixWorld), L.color.copy(M).multiplyScalar(S * _), L.distance = T, L.coneCos = Math.cos(w.angle), L.penumbraCos = Math.cos(w.angle * (1 - w.penumbra)), L.decay = w.decay, w.castShadow) {
                                    var P = w.shadow,
                                        I = i.get(w);
                                    I.shadowBias = P.bias, I.shadowNormalBias = P.normalBias, I.shadowRadius = P.radius, I.shadowMapSize = P.mapSize, a.spotShadow[f] = I, a.spotShadowMap[f] = E, a.spotShadowMatrix[f] = w.shadow.matrix, y++
                                }
                                a.spot[f] = L, f++
                            } else if (w.isRectAreaLight) {
                                var D = r.get(w);
                                D.color.copy(M).multiplyScalar(S), D.halfWidth.set(.5 * w.width, 0, 0), D.halfHeight.set(0, .5 * w.height, 0), a.rectArea[p] = D, p++
                            } else if (w.isPointLight) {
                                var O = r.get(w);
                                if (O.color.copy(w.color).multiplyScalar(w.intensity * _), O.distance = w.distance, O.decay = w.decay, w.castShadow) {
                                    var N = w.shadow,
                                        F = i.get(w);
                                    F.shadowBias = N.bias, F.shadowNormalBias = N.normalBias, F.shadowRadius = N.radius, F.shadowMapSize = N.mapSize, F.shadowCameraNear = N.camera.near, F.shadowCameraFar = N.camera.far, a.pointShadow[d] = F, a.pointShadowMap[d] = E, a.pointShadowMatrix[d] = w.shadow.matrix, g++
                                }
                                a.point[d] = O, d++
                            } else if (w.isHemisphereLight) {
                                var U = r.get(w);
                                U.skyColor.copy(w.color).multiplyScalar(S * _), U.groundColor.copy(w.groundColor).multiplyScalar(S * _), a.hemi[m] = U, m++
                            }
                        }
                        p > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (a.rectAreaLTC1 = rc.LTC_FLOAT_1, a.rectAreaLTC2 = rc.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (a.rectAreaLTC1 = rc.LTC_HALF_1, a.rectAreaLTC2 = rc.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), a.ambient[0] = s, a.ambient[1] = l, a.ambient[2] = u;
                        var B = a.hash;
                        B.directionalLength === h && B.pointLength === d && B.spotLength === f && B.rectAreaLength === p && B.hemiLength === m && B.numDirectionalShadows === v && B.numPointShadows === g && B.numSpotShadows === y || (a.directional.length = h, a.spot.length = f, a.rectArea.length = p, a.point.length = d, a.hemi.length = m, a.directionalShadow.length = v, a.directionalShadowMap.length = v, a.pointShadow.length = g, a.pointShadowMap.length = g, a.spotShadow.length = y, a.spotShadowMap.length = y, a.directionalShadowMatrix.length = v, a.pointShadowMatrix.length = g, a.spotShadowMatrix.length = y, B.directionalLength = h, B.pointLength = d, B.spotLength = f, B.rectAreaLength = p, B.hemiLength = m, B.numDirectionalShadows = v, B.numPointShadows = g, B.numSpotShadows = y, a.version = ah++)
                    },
                    setupView: function(e, t) {
                        for (var n = 0, r = 0, i = 0, o = 0, c = 0, h = t.matrixWorldInverse, d = 0, f = e.length; d < f; d++) {
                            var p = e[d];
                            if (p.isDirectionalLight) {
                                var m = a.directional[n];
                                m.direction.setFromMatrixPosition(p.matrixWorld), s.setFromMatrixPosition(p.target.matrixWorld), m.direction.sub(s), m.direction.transformDirection(h), n++
                            } else if (p.isSpotLight) {
                                var v = a.spot[i];
                                v.position.setFromMatrixPosition(p.matrixWorld), v.position.applyMatrix4(h), v.direction.setFromMatrixPosition(p.matrixWorld), s.setFromMatrixPosition(p.target.matrixWorld), v.direction.sub(s), v.direction.transformDirection(h), i++
                            } else if (p.isRectAreaLight) {
                                var g = a.rectArea[o];
                                g.position.setFromMatrixPosition(p.matrixWorld), g.position.applyMatrix4(h), u.identity(), l.copy(p.matrixWorld), l.premultiply(h), u.extractRotation(l), g.halfWidth.set(.5 * p.width, 0, 0), g.halfHeight.set(0, .5 * p.height, 0), g.halfWidth.applyMatrix4(u), g.halfHeight.applyMatrix4(u), o++
                            } else if (p.isPointLight) {
                                var y = a.point[r];
                                y.position.setFromMatrixPosition(p.matrixWorld), y.position.applyMatrix4(h), r++
                            } else if (p.isHemisphereLight) {
                                var _ = a.hemi[c];
                                _.direction.setFromMatrixPosition(p.matrixWorld), _.direction.transformDirection(h), _.direction.normalize(), c++
                            }
                        }
                    },
                    state: a
                }
            }

            function ap(e, t) {
                var n = new af(e, t),
                    r = [],
                    i = [];
                return {
                    init: function() {
                        r.length = 0, i.length = 0
                    },
                    state: {
                        lightsArray: r,
                        shadowsArray: i,
                        lights: n
                    },
                    setupLights: function(e) {
                        n.setup(r, e)
                    },
                    setupLightsView: function(e) {
                        n.setupView(r, e)
                    },
                    pushLight: function(e) {
                        r.push(e)
                    },
                    pushShadow: function(e) {
                        i.push(e)
                    }
                }
            }

            function am(e, t) {
                var n = new WeakMap;
                return {
                    get: function(r) {
                        var i, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return !1 === n.has(r) ? (i = new ap(e, t), n.set(r, [i])) : a >= n.get(r).length ? (i = new ap(e, t), n.get(r).push(i)) : i = n.get(r)[a], i
                    },
                    dispose: function() {
                        n = new WeakMap
                    }
                }
            }
            var av = function(e) {
                function t(e) {
                    var n;
                    return (0, k._)(this, t), (n = (0, E._)(this, t)).type = "MeshDepthMaterial", n.depthPacking = 3200, n.map = null, n.alphaMap = null, n.displacementMap = null, n.displacementScale = 1, n.displacementBias = 0, n.wireframe = !1, n.wireframeLinewidth = 1, n.fog = !1, n.setValues(e), n
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
                    }
                }]), t
            }(nh);
            av.prototype.isMeshDepthMaterial = !0;
            var ag = function(e) {
                function t(e) {
                    var n;
                    return (0, k._)(this, t), (n = (0, E._)(this, t)).type = "MeshDistanceMaterial", n.referencePosition = new to, n.nearDistance = 1, n.farDistance = 1e3, n.map = null, n.alphaMap = null, n.displacementMap = null, n.displacementScale = 1, n.displacementBias = 0, n.fog = !1, n.setValues(e), n
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
                    }
                }]), t
            }(nh);

            function ay(e, t, n) {
                var r = new ra,
                    i = new e4,
                    a = new e4,
                    o = new tn,
                    s = new av({
                        depthPacking: 3201
                    }),
                    l = new ag,
                    u = {},
                    c = n.maxTextureSize,
                    h = {
                        0: 1,
                        1: 0,
                        2: 2
                    },
                    d = new n3({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new e4
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}",
                        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                    }),
                    f = d.clone();
                f.defines.HORIZONTAL_PASS = 1;
                var p = new nI;
                p.setAttribute("position", new nw(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                var m = new nK(p, d),
                    v = this;

                function g(t, n, r, i, a, o, c) {
                    var d = null,
                        f = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                    if (d = void 0 !== f ? f : !0 === i.isPointLight ? l : s, e.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length || r.displacementMap && 0 !== r.displacementScale || r.alphaMap && r.alphaTest > 0) {
                        var p = d.uuid,
                            m = r.uuid,
                            v = u[p];
                        void 0 === v && (v = {}, u[p] = v);
                        var g = v[m];
                        void 0 === g && (g = d.clone(), v[m] = g), d = g
                    }
                    return d.visible = r.visible, d.wireframe = r.wireframe, d.side = 3 === c ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : h[r.side], d.alphaMap = r.alphaMap, d.alphaTest = r.alphaTest, d.clipShadows = r.clipShadows, d.clippingPlanes = r.clippingPlanes, d.clipIntersection = r.clipIntersection, d.displacementMap = r.displacementMap, d.displacementScale = r.displacementScale, d.displacementBias = r.displacementBias, d.wireframeLinewidth = r.wireframeLinewidth, d.linewidth = r.linewidth, !0 === i.isPointLight && !0 === d.isMeshDistanceMaterial && (d.referencePosition.setFromMatrixPosition(i.matrixWorld), d.nearDistance = a, d.farDistance = o), d
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(n, s, l) {
                    if (!1 !== v.enabled && (!1 !== v.autoUpdate || !1 !== v.needsUpdate) && 0 !== n.length) {
                        var u = e.getRenderTarget(),
                            h = e.getActiveCubeFace(),
                            p = e.getActiveMipmapLevel(),
                            y = e.state;
                        y.setBlending(0), y.buffers.color.setClear(1, 1, 1, 1), y.buffers.depth.setTest(!0), y.setScissorTest(!1);
                        for (var _ = 0, x = n.length; _ < x; _++) {
                            var b = n[_],
                                w = b.shadow;
                            if (void 0 === w) {
                                console.warn("THREE.WebGLShadowMap:", b, "has no shadow.");
                                continue
                            }
                            if (!1 !== w.autoUpdate || !1 !== w.needsUpdate) {
                                i.copy(w.mapSize);
                                var M = w.getFrameExtents();
                                if (i.multiply(M), a.copy(w.mapSize), (i.x > c || i.y > c) && (i.x > c && (a.x = Math.floor(c / M.x), i.x = a.x * M.x, w.mapSize.x = a.x), i.y > c && (a.y = Math.floor(c / M.y), i.y = a.y * M.y, w.mapSize.y = a.y)), null === w.map && !w.isPointLightShadow && 3 === this.type) {
                                    var S = {
                                        minFilter: 1006,
                                        magFilter: 1006,
                                        format: 1023
                                    };
                                    w.map = new tr(i.x, i.y, S), w.map.texture.name = b.name + ".shadowMap", w.mapPass = new tr(i.x, i.y, S), w.camera.updateProjectionMatrix()
                                }
                                if (null === w.map) {
                                    var T = {
                                        minFilter: 1003,
                                        magFilter: 1003,
                                        format: 1023
                                    };
                                    w.map = new tr(i.x, i.y, T), w.map.texture.name = b.name + ".shadowMap", w.camera.updateProjectionMatrix()
                                }
                                e.setRenderTarget(w.map), e.clear();
                                for (var E = w.getViewportCount(), k = 0; k < E; k++) {
                                    var A = w.getViewport(k);
                                    o.set(a.x * A.x, a.y * A.y, a.x * A.z, a.y * A.w), y.viewport(o), w.updateMatrices(b, k), r = w.getFrustum(),
                                        function n(i, a, o, s, l) {
                                            if (!1 !== i.visible) {
                                                if (i.layers.test(a.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && 3 === l) && (!i.frustumCulled || r.intersectsObject(i))) {
                                                    i.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, i.matrixWorld);
                                                    var u = t.update(i),
                                                        c = i.material;
                                                    if (Array.isArray(c))
                                                        for (var h = u.groups, d = 0, f = h.length; d < f; d++) {
                                                            var p = h[d],
                                                                m = c[p.materialIndex];
                                                            if (m && m.visible) {
                                                                var v = g(i, 0, m, s, o.near, o.far, l);
                                                                e.renderBufferDirect(o, null, u, v, i, p)
                                                            }
                                                        } else if (c.visible) {
                                                            var y = g(i, 0, c, s, o.near, o.far, l);
                                                            e.renderBufferDirect(o, null, u, y, i, null)
                                                        }
                                                }
                                                for (var _ = i.children, x = 0, b = _.length; x < b; x++) n(_[x], a, o, s, l)
                                            }
                                        }(s, l, w.camera, b, this.type)
                                }
                                w.isPointLightShadow || 3 !== this.type || function(n, r) {
                                    var i = t.update(m);
                                    d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples, f.defines.VSM_SAMPLES = n.blurSamples, d.needsUpdate = !0, f.needsUpdate = !0), d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(r, null, i, d, m, null), f.uniforms.shadow_pass.value = n.mapPass.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(r, null, i, f, m, null)
                                }(w, l), w.needsUpdate = !1
                            }
                        }
                        v.needsUpdate = !1, e.setRenderTarget(u, h, p)
                    }
                }
            }

            function a_(e, t, n) {
                var r = n.isWebGL2,
                    i = new function() {
                        var t = !1,
                            n = new tn,
                            r = null,
                            i = new tn(0, 0, 0, 0);
                        return {
                            setMask: function(n) {
                                r === n || t || (e.colorMask(n, n, n, n), r = n)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t, r, a, o, s) {
                                !0 === s && (t *= o, r *= o, a *= o), n.set(t, r, a, o), !1 === i.equals(n) && (e.clearColor(t, r, a, o), i.copy(n))
                            },
                            reset: function() {
                                t = !1, r = null, i.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    a = new function() {
                        var t = !1,
                            n = null,
                            r = null,
                            i = null;
                        return {
                            setTest: function(e) {
                                e ? O(2929) : N(2929)
                            },
                            setMask: function(r) {
                                n === r || t || (e.depthMask(r), n = r)
                            },
                            setFunc: function(t) {
                                if (r !== t) {
                                    if (t) switch (t) {
                                        case 0:
                                            e.depthFunc(512);
                                            break;
                                        case 1:
                                            e.depthFunc(519);
                                            break;
                                        case 2:
                                            e.depthFunc(513);
                                            break;
                                        case 3:
                                        default:
                                            e.depthFunc(515);
                                            break;
                                        case 4:
                                            e.depthFunc(514);
                                            break;
                                        case 5:
                                            e.depthFunc(518);
                                            break;
                                        case 6:
                                            e.depthFunc(516);
                                            break;
                                        case 7:
                                            e.depthFunc(517)
                                    } else e.depthFunc(515);
                                    r = t
                                }
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                i !== t && (e.clearDepth(t), i = t)
                            },
                            reset: function() {
                                t = !1, n = null, r = null, i = null
                            }
                        }
                    },
                    o = new function() {
                        var t = !1,
                            n = null,
                            r = null,
                            i = null,
                            a = null,
                            o = null,
                            s = null,
                            l = null,
                            u = null;
                        return {
                            setTest: function(e) {
                                t || (e ? O(2960) : N(2960))
                            },
                            setMask: function(r) {
                                n === r || t || (e.stencilMask(r), n = r)
                            },
                            setFunc: function(t, n, o) {
                                r === t && i === n && a === o || (e.stencilFunc(t, n, o), r = t, i = n, a = o)
                            },
                            setOp: function(t, n, r) {
                                o === t && s === n && l === r || (e.stencilOp(t, n, r), o = t, s = n, l = r)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                u !== t && (e.clearStencil(t), u = t)
                            },
                            reset: function() {
                                t = !1, n = null, r = null, i = null, a = null, o = null, s = null, l = null, u = null
                            }
                        }
                    },
                    s = {},
                    l = {},
                    u = null,
                    c = !1,
                    h = null,
                    d = null,
                    f = null,
                    p = null,
                    m = null,
                    v = null,
                    g = null,
                    y = !1,
                    _ = null,
                    x = null,
                    b = null,
                    w = null,
                    M = null,
                    S = e.getParameter(35661),
                    T = !1,
                    E = e.getParameter(7938); - 1 !== E.indexOf("WebGL") ? T = parseFloat(/^WebGL (\d)/.exec(E)[1]) >= 1 : -1 !== E.indexOf("OpenGL ES") && (T = parseFloat(/^OpenGL ES (\d)/.exec(E)[1]) >= 2);
                var k = null,
                    A = {},
                    R = e.getParameter(3088),
                    C = e.getParameter(2978),
                    L = (new tn).fromArray(R),
                    P = (new tn).fromArray(C);

                function I(t, n, r) {
                    var i = new Uint8Array(4),
                        a = e.createTexture();
                    e.bindTexture(t, a), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
                    for (var o = 0; o < r; o++) e.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, i);
                    return a
                }
                var D = {};

                function O(t) {
                    !0 !== s[t] && (e.enable(t), s[t] = !0)
                }

                function N(t) {
                    !1 !== s[t] && (e.disable(t), s[t] = !1)
                }
                D[3553] = I(3553, 3553, 1), D[34067] = I(34067, 34069, 6), i.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), O(2929), a.setFunc(3), H(!1), V(1), O(2884), z(0);
                var F = {
                    100: 32774,
                    101: 32778,
                    102: 32779
                };
                if (r) F[103] = 32775, F[104] = 32776;
                else {
                    var U = t.get("EXT_blend_minmax");
                    null !== U && (F[103] = U.MIN_EXT, F[104] = U.MAX_EXT)
                }
                var B = {
                    200: 0,
                    201: 1,
                    202: 768,
                    204: 770,
                    210: 776,
                    208: 774,
                    206: 772,
                    203: 769,
                    205: 771,
                    209: 775,
                    207: 773
                };

                function z(t, n, r, i, a, o, s, l) {
                    if (0 !== t) {
                        if (!1 === c && (O(3042), c = !0), 5 === t) a = a || n, o = o || r, s = s || i, n === d && a === m || (e.blendEquationSeparate(F[n], F[a]), d = n, m = a), r === f && i === p && o === v && s === g || (e.blendFuncSeparate(B[r], B[i], B[o], B[s]), f = r, p = i, v = o, g = s), h = t, y = null;
                        else if (t !== h || l !== y) {
                            if (100 === d && 100 === m || (e.blendEquation(32774), d = 100, m = 100), l) switch (t) {
                                case 1:
                                    e.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case 2:
                                    e.blendFunc(1, 1);
                                    break;
                                case 3:
                                    e.blendFuncSeparate(0, 0, 769, 771);
                                    break;
                                case 4:
                                    e.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                            } else switch (t) {
                                case 1:
                                    e.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case 2:
                                    e.blendFunc(770, 1);
                                    break;
                                case 3:
                                    e.blendFunc(0, 769);
                                    break;
                                case 4:
                                    e.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                            f = null, p = null, v = null, g = null, h = t, y = l
                        }
                    } else !0 === c && (N(3042), c = !1)
                }

                function H(t) {
                    _ !== t && (t ? e.frontFace(2304) : e.frontFace(2305), _ = t)
                }

                function V(t) {
                    0 !== t ? (O(2884), t !== x && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : N(2884), x = t
                }

                function G(t, n, r) {
                    t ? (O(32823), w === n && M === r || (e.polygonOffset(n, r), w = n, M = r)) : N(32823)
                }

                function W(t) {
                    void 0 === t && (t = 33984 + S - 1), k !== t && (e.activeTexture(t), k = t)
                }
                return {
                    buffers: {
                        color: i,
                        depth: a,
                        stencil: o
                    },
                    enable: O,
                    disable: N,
                    bindFramebuffer: function(t, n) {
                        return l[t] !== n && (e.bindFramebuffer(t, n), l[t] = n, r && (36009 === t && (l[36160] = n), 36160 === t && (l[36009] = n)), !0)
                    },
                    useProgram: function(t) {
                        return u !== t && (e.useProgram(t), u = t, !0)
                    },
                    setBlending: z,
                    setMaterial: function(e, t) {
                        2 === e.side ? N(2884) : O(2884);
                        var n = 1 === e.side;
                        t && (n = !n), H(n), 1 === e.blending && !1 === e.transparent ? z(0) : z(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), a.setFunc(e.depthFunc), a.setTest(e.depthTest), a.setMask(e.depthWrite), i.setMask(e.colorWrite);
                        var r = e.stencilWrite;
                        o.setTest(r), r && (o.setMask(e.stencilWriteMask), o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), G(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? O(32926) : N(32926)
                    },
                    setFlipSided: H,
                    setCullFace: V,
                    setLineWidth: function(t) {
                        t !== b && (T && e.lineWidth(t), b = t)
                    },
                    setPolygonOffset: G,
                    setScissorTest: function(e) {
                        e ? O(3089) : N(3089)
                    },
                    activeTexture: W,
                    bindTexture: function(t, n) {
                        null === k && W();
                        var r = A[k];
                        void 0 === r && (r = {
                            type: void 0,
                            texture: void 0
                        }, A[k] = r), r.type === t && r.texture === n || (e.bindTexture(t, n || D[t]), r.type = t, r.texture = n)
                    },
                    unbindTexture: function() {
                        var t = A[k];
                        void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                    },
                    compressedTexImage2D: function() {
                        try {
                            e.compressedTexImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage2D: function() {
                        try {
                            e.texImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage3D: function() {
                        try {
                            e.texImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texStorage2D: function() {
                        try {
                            e.texStorage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texStorage3D: function() {
                        try {
                            e.texStorage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texSubImage2D: function() {
                        try {
                            e.texSubImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texSubImage3D: function() {
                        try {
                            e.texSubImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    compressedTexSubImage2D: function() {
                        try {
                            e.compressedTexSubImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    scissor: function(t) {
                        !1 === L.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), L.copy(t))
                    },
                    viewport: function(t) {
                        !1 === P.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), P.copy(t))
                    },
                    reset: function() {
                        e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513), e.clearDepth(1), e.stencilMask(0xffffffff), e.stencilFunc(519, 0, 0xffffffff), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), !0 === r && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), s = {}, k = null, A = {}, l = {}, u = null, c = !1, h = null, d = null, f = null, p = null, m = null, v = null, g = null, y = !1, _ = null, x = null, b = null, w = null, M = null, L.set(0, 0, e.canvas.width, e.canvas.height), P.set(0, 0, e.canvas.width, e.canvas.height), i.reset(), a.reset(), o.reset()
                    }
                }
            }

            function ax(e, t, n, r, i, a, o) {
                var s, l = i.isWebGL2,
                    u = i.maxTextures,
                    c = i.maxCubemapSize,
                    h = i.maxTextureSize,
                    d = i.maxSamples,
                    f = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : void 0,
                    p = new WeakMap,
                    m = !1;
                try {
                    m = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (e) {}

                function v(e, t) {
                    return m ? new OffscreenCanvas(e, t) : e8("canvas")
                }

                function g(e, t, n, r) {
                    var i = 1;
                    if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)), i < 1 || !0 === t) {
                        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                            var a = t ? e2 : Math.floor,
                                o = a(i * e.width),
                                l = a(i * e.height);
                            void 0 === s && (s = v(o, l));
                            var u = n ? v(o, l) : s;
                            return u.width = o, u.height = l, u.getContext("2d").drawImage(e, 0, 0, o, l), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + o + "x" + l + ")."), u
                        }
                        return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
                    }
                    return e
                }

                function y(e) {
                    return e0(e.width) && e0(e.height)
                }

                function _(e, t) {
                    return e.generateMipmaps && t && 1003 !== e.minFilter && 1006 !== e.minFilter
                }

                function x(t) {
                    e.generateMipmap(t)
                }

                function b(n, r, i, a) {
                    if (!1 === l) return r;
                    if (null !== n) {
                        if (void 0 !== e[n]) return e[n];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                    }
                    var o = r;
                    return 6403 === r && (5126 === i && (o = 33326), 5131 === i && (o = 33325), 5121 === i && (o = 33321)), 6407 === r && (5126 === i && (o = 34837), 5131 === i && (o = 34843), 5121 === i && (o = 32849)), 6408 === r && (5126 === i && (o = 34836), 5131 === i && (o = 34842), 5121 === i && (o = 3001 === a ? 35907 : 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || t.get("EXT_color_buffer_float"), o
                }

                function w(e, t, n) {
                    return !0 === _(e, n) || e.isFramebufferTexture && 1003 !== e.minFilter && 1006 !== e.minFilter ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
                }

                function M(e) {
                    return 1003 === e || 1004 === e || 1005 === e ? 9728 : 9729
                }

                function S(t) {
                    var n, i = t.target;
                    i.removeEventListener("dispose", S), void 0 !== (n = r.get(i)).__webglInit && (e.deleteTexture(n.__webglTexture), r.remove(i)), i.isVideoTexture && p.delete(i), o.memory.textures--
                }

                function T(t) {
                    var n = t.target;
                    n.removeEventListener("dispose", T),
                        function(t) {
                            var n = t.texture,
                                i = r.get(t),
                                a = r.get(n);
                            if (t) {
                                if (void 0 !== a.__webglTexture && (e.deleteTexture(a.__webglTexture), o.memory.textures--), t.depthTexture && t.depthTexture.dispose(), t.isWebGLCubeRenderTarget)
                                    for (var s = 0; s < 6; s++) e.deleteFramebuffer(i.__webglFramebuffer[s]), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[s]);
                                else e.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && e.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer && e.deleteRenderbuffer(i.__webglColorRenderbuffer), i.__webglDepthRenderbuffer && e.deleteRenderbuffer(i.__webglDepthRenderbuffer);
                                if (t.isWebGLMultipleRenderTargets)
                                    for (var l = 0, u = n.length; l < u; l++) {
                                        var c = r.get(n[l]);
                                        c.__webglTexture && (e.deleteTexture(c.__webglTexture), o.memory.textures--), r.remove(n[l])
                                    }
                                r.remove(n), r.remove(t)
                            }
                        }(n)
                }
                var E = 0;

                function k(e, t) {
                    var i, a = r.get(e);
                    if (e.isVideoTexture && (i = o.render.frame, p.get(e) !== i && (p.set(e, i), e.update())), e.version > 0 && a.__version !== e.version) {
                        var s = e.image;
                        if (void 0 === s) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (!1 !== s.complete) return void I(a, e, t);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    n.activeTexture(33984 + t), n.bindTexture(3553, a.__webglTexture)
                }

                function A(t, i) {
                    var o = r.get(t);
                    t.version > 0 && o.__version !== t.version ? function(t, r, i) {
                        if (6 === r.image.length) {
                            P(t, r), n.activeTexture(33984 + i), n.bindTexture(34067, t.__webglTexture), e.pixelStorei(37440, r.flipY), e.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(3317, r.unpackAlignment), e.pixelStorei(37443, 0);
                            for (var o = r && (r.isCompressedTexture || r.image[0].isCompressedTexture), s = r.image[0] && r.image[0].isDataTexture, u = [], h = 0; h < 6; h++) u[h] = o || s ? s ? r.image[h].image : r.image[h] : g(r.image[h], !1, !0, c);
                            var d, f = u[0],
                                p = y(f) || l,
                                m = a.convert(r.format),
                                v = a.convert(r.type),
                                M = b(r.internalFormat, m, v, r.encoding),
                                S = l && !0 !== r.isVideoTexture,
                                T = void 0 === t.__version,
                                E = w(r, f, p);
                            if (L(34067, r, p), o) {
                                S && T && n.texStorage2D(34067, E, M, f.width, f.height);
                                for (var k = 0; k < 6; k++) {
                                    d = u[k].mipmaps;
                                    for (var A = 0; A < d.length; A++) {
                                        var R = d[A];
                                        1023 !== r.format && 1022 !== r.format ? null !== m ? S ? n.compressedTexSubImage2D(34069 + k, A, 0, 0, R.width, R.height, m, R.data) : n.compressedTexImage2D(34069 + k, A, M, R.width, R.height, 0, R.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : S ? n.texSubImage2D(34069 + k, A, 0, 0, R.width, R.height, m, v, R.data) : n.texImage2D(34069 + k, A, M, R.width, R.height, 0, m, v, R.data)
                                    }
                                }
                            } else {
                                d = r.mipmaps, S && T && (d.length > 0 && E++, n.texStorage2D(34067, E, M, u[0].width, u[0].height));
                                for (var C = 0; C < 6; C++)
                                    if (s) {
                                        S ? n.texSubImage2D(34069 + C, 0, 0, 0, u[C].width, u[C].height, m, v, u[C].data) : n.texImage2D(34069 + C, 0, M, u[C].width, u[C].height, 0, m, v, u[C].data);
                                        for (var I = 0; I < d.length; I++) {
                                            var D = d[I].image[C].image;
                                            S ? n.texSubImage2D(34069 + C, I + 1, 0, 0, D.width, D.height, m, v, D.data) : n.texImage2D(34069 + C, I + 1, M, D.width, D.height, 0, m, v, D.data)
                                        }
                                    } else {
                                        S ? n.texSubImage2D(34069 + C, 0, 0, 0, m, v, u[C]) : n.texImage2D(34069 + C, 0, M, m, v, u[C]);
                                        for (var O = 0; O < d.length; O++) {
                                            var N = d[O];
                                            S ? n.texSubImage2D(34069 + C, O + 1, 0, 0, m, v, N.image[C]) : n.texImage2D(34069 + C, O + 1, M, m, v, N.image[C])
                                        }
                                    }
                            }
                            _(r, p) && x(34067), t.__version = r.version, r.onUpdate && r.onUpdate(r)
                        }
                    }(o, t, i) : (n.activeTexture(33984 + i), n.bindTexture(34067, o.__webglTexture))
                }
                var R = {
                        1e3: 10497,
                        1001: 33071,
                        1002: 33648
                    },
                    C = {
                        1003: 9728,
                        1004: 9984,
                        1005: 9986,
                        1006: 9729,
                        1007: 9985,
                        1008: 9987
                    };

                function L(n, a, o) {
                    if (o ? (e.texParameteri(n, 10242, R[a.wrapS]), e.texParameteri(n, 10243, R[a.wrapT]), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, R[a.wrapR]), e.texParameteri(n, 10240, C[a.magFilter]), e.texParameteri(n, 10241, C[a.minFilter])) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), 1001 === a.wrapS && 1001 === a.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, M(a.magFilter)), e.texParameteri(n, 10241, M(a.minFilter)), 1003 !== a.minFilter && 1006 !== a.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) {
                        var s = t.get("EXT_texture_filter_anisotropic");
                        (1015 !== a.type || !1 !== t.has("OES_texture_float_linear")) && (!1 !== l || 1016 !== a.type || !1 !== t.has("OES_texture_half_float_linear")) && (a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (e.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())), r.get(a).__currentAnisotropy = a.anisotropy)
                    }
                }

                function P(t, n) {
                    void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", S), t.__webglTexture = e.createTexture(), o.memory.textures++)
                }

                function I(t, r, i) {
                    var o = 3553;
                    r.isDataTexture2DArray && (o = 35866), r.isDataTexture3D && (o = 32879), P(t, r), n.activeTexture(33984 + i), n.bindTexture(o, t.__webglTexture), e.pixelStorei(37440, r.flipY), e.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(3317, r.unpackAlignment), e.pixelStorei(37443, 0);
                    var s, u = !l && (1001 !== r.wrapS || 1001 !== r.wrapT || 1003 !== r.minFilter && 1006 !== r.minFilter) && !1 === y(r.image),
                        c = g(r.image, u, !1, h),
                        d = y(c) || l,
                        f = a.convert(r.format),
                        p = a.convert(r.type),
                        m = b(r.internalFormat, f, p, r.encoding);
                    L(o, r, d);
                    var v = r.mipmaps,
                        M = l && !0 !== r.isVideoTexture,
                        S = void 0 === t.__version,
                        T = w(r, c, d);
                    if (r.isDepthTexture) m = 6402, l ? m = 1015 === r.type ? 36012 : 1014 === r.type ? 33190 : 1020 === r.type ? 35056 : 33189 : 1015 === r.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === r.format && 6402 === m && 1012 !== r.type && 1014 !== r.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = 1012, p = a.convert(r.type)), 1027 === r.format && 6402 === m && (m = 34041, 1020 !== r.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = 1020, p = a.convert(r.type))), M && S ? n.texStorage2D(3553, 1, m, c.width, c.height) : n.texImage2D(3553, 0, m, c.width, c.height, 0, f, p, null);
                    else if (r.isDataTexture) {
                        if (v.length > 0 && d) {
                            M && S && n.texStorage2D(3553, T, m, v[0].width, v[0].height);
                            for (var E = 0, k = v.length; E < k; E++) s = v[E], M ? n.texSubImage2D(3553, 0, 0, 0, s.width, s.height, f, p, s.data) : n.texImage2D(3553, E, m, s.width, s.height, 0, f, p, s.data);
                            r.generateMipmaps = !1
                        } else M ? (S && n.texStorage2D(3553, T, m, c.width, c.height), n.texSubImage2D(3553, 0, 0, 0, c.width, c.height, f, p, c.data)) : n.texImage2D(3553, 0, m, c.width, c.height, 0, f, p, c.data)
                    } else if (r.isCompressedTexture) {
                        M && S && n.texStorage2D(3553, T, m, v[0].width, v[0].height);
                        for (var A = 0, R = v.length; A < R; A++) s = v[A], 1023 !== r.format && 1022 !== r.format ? null !== f ? M ? n.compressedTexSubImage2D(3553, A, 0, 0, s.width, s.height, f, s.data) : n.compressedTexImage2D(3553, A, m, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M ? n.texSubImage2D(3553, A, 0, 0, s.width, s.height, f, p, s.data) : n.texImage2D(3553, A, m, s.width, s.height, 0, f, p, s.data)
                    } else if (r.isDataTexture2DArray) M ? (S && n.texStorage3D(35866, T, m, c.width, c.height, c.depth), n.texSubImage3D(35866, 0, 0, 0, 0, c.width, c.height, c.depth, f, p, c.data)) : n.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, f, p, c.data);
                    else if (r.isDataTexture3D) M ? (S && n.texStorage3D(32879, T, m, c.width, c.height, c.depth), n.texSubImage3D(32879, 0, 0, 0, 0, c.width, c.height, c.depth, f, p, c.data)) : n.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, f, p, c.data);
                    else if (r.isFramebufferTexture) M && S ? n.texStorage2D(3553, T, m, c.width, c.height) : n.texImage2D(3553, 0, m, c.width, c.height, 0, f, p, null);
                    else if (v.length > 0 && d) {
                        M && S && n.texStorage2D(3553, T, m, v[0].width, v[0].height);
                        for (var C = 0, I = v.length; C < I; C++) s = v[C], M ? n.texSubImage2D(3553, C, 0, 0, f, p, s) : n.texImage2D(3553, C, m, f, p, s);
                        r.generateMipmaps = !1
                    } else M ? (S && n.texStorage2D(3553, T, m, c.width, c.height), n.texSubImage2D(3553, 0, 0, 0, f, p, c)) : n.texImage2D(3553, 0, m, f, p, c);
                    _(r, d) && x(o), t.__version = r.version, r.onUpdate && r.onUpdate(r)
                }

                function D(t, i, o, s, l) {
                    var u = a.convert(o.format),
                        c = a.convert(o.type),
                        h = b(o.internalFormat, u, c, o.encoding);
                    r.get(i).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, h, i.width, i.height, i.depth, 0, u, c, null) : n.texImage2D(l, 0, h, i.width, i.height, 0, u, c, null)), n.bindFramebuffer(36160, t), i.useRenderToTexture ? f.framebufferTexture2DMultisampleEXT(36160, s, l, r.get(o).__webglTexture, 0, F(i)) : e.framebufferTexture2D(36160, s, l, r.get(o).__webglTexture, 0), n.bindFramebuffer(36160, null)
                }

                function O(t, n, r) {
                    if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) {
                        var i = 33189;
                        if (r || n.useRenderToTexture) {
                            var o = n.depthTexture;
                            o && o.isDepthTexture && (1015 === o.type ? i = 36012 : 1014 === o.type && (i = 33190));
                            var s = F(n);
                            n.useRenderToTexture ? f.renderbufferStorageMultisampleEXT(36161, s, i, n.width, n.height) : e.renderbufferStorageMultisample(36161, s, i, n.width, n.height)
                        } else e.renderbufferStorage(36161, i, n.width, n.height);
                        e.framebufferRenderbuffer(36160, 36096, 36161, t)
                    } else if (n.depthBuffer && n.stencilBuffer) {
                        var l = F(n);
                        r && n.useRenderbuffer ? e.renderbufferStorageMultisample(36161, l, 35056, n.width, n.height) : n.useRenderToTexture ? f.renderbufferStorageMultisampleEXT(36161, l, 35056, n.width, n.height) : e.renderbufferStorage(36161, 34041, n.width, n.height), e.framebufferRenderbuffer(36160, 33306, 36161, t)
                    } else {
                        var u = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
                            c = a.convert(u.format),
                            h = a.convert(u.type),
                            d = b(u.internalFormat, c, h, u.encoding),
                            p = F(n);
                        r && n.useRenderbuffer ? e.renderbufferStorageMultisample(36161, p, d, n.width, n.height) : n.useRenderToTexture ? f.renderbufferStorageMultisampleEXT(36161, p, d, n.width, n.height) : e.renderbufferStorage(36161, d, n.width, n.height)
                    }
                    e.bindRenderbuffer(36161, null)
                }

                function N(t) {
                    var i = r.get(t),
                        a = !0 === t.isWebGLCubeRenderTarget;
                    if (t.depthTexture && !i.__autoAllocateDepthBuffer) {
                        if (a) throw Error("target.depthTexture not supported in Cube render targets");
                        ! function(t, i) {
                            if (i && i.isWebGLCubeRenderTarget) throw Error("Depth Texture with cube render targets is not supported");
                            if (n.bindFramebuffer(36160, t), !i.depthTexture || !i.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), k(i.depthTexture, 0);
                            var a = r.get(i.depthTexture).__webglTexture,
                                o = F(i);
                            if (1026 === i.depthTexture.format) i.useRenderToTexture ? f.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, a, 0, o) : e.framebufferTexture2D(36160, 36096, 3553, a, 0);
                            else {
                                if (1027 !== i.depthTexture.format) throw Error("Unknown depthTexture format");
                                i.useRenderToTexture ? f.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, a, 0, o) : e.framebufferTexture2D(36160, 33306, 3553, a, 0)
                            }
                        }(i.__webglFramebuffer, t)
                    } else if (a) {
                        i.__webglDepthbuffer = [];
                        for (var o = 0; o < 6; o++) n.bindFramebuffer(36160, i.__webglFramebuffer[o]), i.__webglDepthbuffer[o] = e.createRenderbuffer(), O(i.__webglDepthbuffer[o], t, !1)
                    } else n.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = e.createRenderbuffer(), O(i.__webglDepthbuffer, t, !1);
                    n.bindFramebuffer(36160, null)
                }

                function F(e) {
                    return l && (e.useRenderbuffer || e.useRenderToTexture) ? Math.min(d, e.samples) : 0
                }
                var U = !1,
                    B = !1;
                this.allocateTextureUnit = function() {
                    var e = E;
                    return e >= u && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + u), E += 1, e
                }, this.resetTextureUnits = function() {
                    E = 0
                }, this.setTexture2D = k, this.setTexture2DArray = function(e, t) {
                    var i = r.get(e);
                    e.version > 0 && i.__version !== e.version ? I(i, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, i.__webglTexture))
                }, this.setTexture3D = function(e, t) {
                    var i = r.get(e);
                    e.version > 0 && i.__version !== e.version ? I(i, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, i.__webglTexture))
                }, this.setTextureCube = A, this.rebindTextures = function(e, t, n) {
                    var i = r.get(e);
                    void 0 !== t && D(i.__webglFramebuffer, e, e.texture, 36064, 3553), void 0 !== n && N(e)
                }, this.setupRenderTarget = function(t) {
                    var s = t.texture,
                        u = r.get(t),
                        c = r.get(s);
                    t.addEventListener("dispose", T), !0 !== t.isWebGLMultipleRenderTargets && (void 0 === c.__webglTexture && (c.__webglTexture = e.createTexture()), c.__version = s.version, o.memory.textures++);
                    var h = !0 === t.isWebGLCubeRenderTarget,
                        d = !0 === t.isWebGLMultipleRenderTargets,
                        f = s.isDataTexture3D || s.isDataTexture2DArray,
                        p = y(t) || l;
                    if (l && 1022 === s.format && (1015 === s.type || 1016 === s.type) && (s.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), h) {
                        u.__webglFramebuffer = [];
                        for (var m = 0; m < 6; m++) u.__webglFramebuffer[m] = e.createFramebuffer()
                    } else if (u.__webglFramebuffer = e.createFramebuffer(), d) {
                        if (i.drawBuffers)
                            for (var v = t.texture, g = 0, w = v.length; g < w; g++) {
                                var M = r.get(v[g]);
                                void 0 === M.__webglTexture && (M.__webglTexture = e.createTexture(), o.memory.textures++)
                            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.")
                    } else if (t.useRenderbuffer) {
                        if (l) {
                            u.__webglMultisampledFramebuffer = e.createFramebuffer(), u.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, u.__webglColorRenderbuffer);
                            var S = a.convert(s.format),
                                E = a.convert(s.type),
                                k = b(s.internalFormat, S, E, s.encoding),
                                A = F(t);
                            e.renderbufferStorageMultisample(36161, A, k, t.width, t.height), n.bindFramebuffer(36160, u.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, u.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (u.__webglDepthRenderbuffer = e.createRenderbuffer(), O(u.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(36160, null)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                    }
                    if (h) {
                        n.bindTexture(34067, c.__webglTexture), L(34067, s, p);
                        for (var R = 0; R < 6; R++) D(u.__webglFramebuffer[R], t, s, 36064, 34069 + R);
                        _(s, p) && x(34067), n.unbindTexture()
                    } else if (d) {
                        for (var C = t.texture, P = 0, I = C.length; P < I; P++) {
                            var U = C[P],
                                B = r.get(U);
                            n.bindTexture(3553, B.__webglTexture), L(3553, U, p), D(u.__webglFramebuffer, t, U, 36064 + P, 3553), _(U, p) && x(3553)
                        }
                        n.unbindTexture()
                    } else {
                        var z = 3553;
                        f && (l ? z = s.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(z, c.__webglTexture), L(z, s, p), D(u.__webglFramebuffer, t, s, 36064, z), _(s, p) && x(z), n.unbindTexture()
                    }
                    t.depthBuffer && N(t)
                }, this.updateRenderTargetMipmap = function(e) {
                    for (var t = y(e) || l, i = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture], a = 0, o = i.length; a < o; a++) {
                        var s = i[a];
                        if (_(s, t)) {
                            var u = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                                c = r.get(s).__webglTexture;
                            n.bindTexture(u, c), x(u), n.unbindTexture()
                        }
                    }
                }, this.updateMultisampleRenderTarget = function(t) {
                    if (t.useRenderbuffer) {
                        if (l) {
                            var i = t.width,
                                a = t.height,
                                o = 16384,
                                s = [36064],
                                u = t.stencilBuffer ? 33306 : 36096;
                            t.depthBuffer && s.push(u), t.ignoreDepthForMultisampleCopy || (t.depthBuffer && (o |= 256), t.stencilBuffer && (o |= 1024));
                            var c = r.get(t);
                            n.bindFramebuffer(36008, c.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, c.__webglFramebuffer), t.ignoreDepthForMultisampleCopy && (e.invalidateFramebuffer(36008, [u]), e.invalidateFramebuffer(36009, [u])), e.blitFramebuffer(0, 0, i, a, 0, 0, i, a, o, 9728), e.invalidateFramebuffer(36008, s), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, c.__webglMultisampledFramebuffer)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                    }
                }, this.setupDepthRenderbuffer = N, this.setupFrameBufferTexture = D, this.safeSetTexture2D = function(e, t) {
                    e && e.isWebGLRenderTarget && (!1 === U && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), U = !0), e = e.texture), k(e, t)
                }, this.safeSetTextureCube = function(e, t) {
                    e && e.isWebGLCubeRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), B = !0), e = e.texture), A(e, t)
                }
            }

            function ab(e, t, n) {
                var r = n.isWebGL2;
                return {
                    convert: function(e) {
                        var n;
                        if (1009 === e) return 5121;
                        if (1017 === e) return 32819;
                        if (1018 === e) return 32820;
                        if (1019 === e) return 33635;
                        if (1010 === e) return 5120;
                        if (1011 === e) return 5122;
                        if (1012 === e) return 5123;
                        if (1013 === e) return 5124;
                        if (1014 === e) return 5125;
                        if (1015 === e) return 5126;
                        if (1016 === e) return r ? 5131 : null !== (n = t.get("OES_texture_half_float")) ? n.HALF_FLOAT_OES : null;
                        if (1021 === e) return 6406;
                        if (1022 === e) return 6407;
                        if (1023 === e) return 6408;
                        if (1024 === e) return 6409;
                        if (1025 === e) return 6410;
                        if (1026 === e) return 6402;
                        if (1027 === e) return 34041;
                        if (1028 === e) return 6403;
                        if (1029 === e) return 36244;
                        if (1030 === e) return 33319;
                        if (1031 === e) return 33320;
                        if (1032 === e) return 36248;
                        if (1033 === e) return 36249;
                        if (33776 === e || 33777 === e || 33778 === e || 33779 === e) {
                            if (null === (n = t.get("WEBGL_compressed_texture_s3tc"))) return null;
                            if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if (35840 === e || 35841 === e || 35842 === e || 35843 === e) {
                            if (null === (n = t.get("WEBGL_compressed_texture_pvrtc"))) return null;
                            if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (36196 === e) return null !== (n = t.get("WEBGL_compressed_texture_etc1")) ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if ((37492 === e || 37496 === e) && null !== (n = t.get("WEBGL_compressed_texture_etc"))) {
                            if (37492 === e) return n.COMPRESSED_RGB8_ETC2;
                            if (37496 === e) return n.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        return 37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e || 37840 === e || 37841 === e || 37842 === e || 37843 === e || 37844 === e || 37845 === e || 37846 === e || 37847 === e || 37848 === e || 37849 === e || 37850 === e || 37851 === e || 37852 === e || 37853 === e ? null !== (n = t.get("WEBGL_compressed_texture_astc")) ? e : null : 36492 === e ? null !== (n = t.get("EXT_texture_compression_bptc")) ? e : null : 1020 === e ? r ? 34042 : null !== (n = t.get("WEBGL_depth_texture")) ? n.UNSIGNED_INT_24_8_WEBGL : null : void 0
                    }
                }
            }
            ag.prototype.isMeshDistanceMaterial = !0;
            var aw = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                    return (0, k._)(this, t), (e = (0, E._)(this, t)).cameras = n, e
                }
                return (0, P._)(t, e), t
            }(n5);
            aw.prototype.isArrayCamera = !0;
            var aM = function(e) {
                function t() {
                    var e;
                    return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "Group", e
                }
                return (0, P._)(t, e), t
            }(t7);
            aM.prototype.isGroup = !0;
            var aS = {
                    type: "move"
                },
                aT = function() {
                    function e() {
                        (0, k._)(this, e), this._targetRay = null, this._grip = null, this._hand = null
                    }
                    return (0, A._)(e, [{
                        key: "getHandSpace",
                        value: function() {
                            return null === this._hand && (this._hand = new aM, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                                pinching: !1
                            }), this._hand
                        }
                    }, {
                        key: "getTargetRaySpace",
                        value: function() {
                            return null === this._targetRay && (this._targetRay = new aM, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new to, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new to), this._targetRay
                        }
                    }, {
                        key: "getGripSpace",
                        value: function() {
                            return null === this._grip && (this._grip = new aM, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new to, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new to), this._grip
                        }
                    }, {
                        key: "dispatchEvent",
                        value: function(e) {
                            return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
                        }
                    }, {
                        key: "disconnect",
                        value: function(e) {
                            return this.dispatchEvent({
                                type: "disconnected",
                                data: e
                            }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                        }
                    }, {
                        key: "update",
                        value: function(e, t, n) {
                            var r = null,
                                i = null,
                                a = null,
                                o = this._targetRay,
                                s = this._grip,
                                l = this._hand;
                            if (e && "visible-blurred" !== t.session.visibilityState) {
                                if (null !== o && null !== (r = t.getPose(e.targetRaySpace, n)) && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(aS)), l && e.hand) {
                                    a = !0;
                                    var u = !0,
                                        c = !1,
                                        h = void 0;
                                    try {
                                        for (var d, f = e.hand.values()[Symbol.iterator](); !(u = (d = f.next()).done); u = !0) {
                                            var p = d.value,
                                                m = t.getJointPose(p, n);
                                            if (void 0 === l.joints[p.jointName]) {
                                                var v = new aM;
                                                v.matrixAutoUpdate = !1, v.visible = !1, l.joints[p.jointName] = v, l.add(v)
                                            }
                                            var g = l.joints[p.jointName];
                                            null !== m && (g.matrix.fromArray(m.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), g.jointRadius = m.radius), g.visible = null !== m
                                        }
                                    } catch (e) {
                                        c = !0, h = e
                                    } finally {
                                        try {
                                            u || null == f.return || f.return()
                                        } finally {
                                            if (c) throw h
                                        }
                                    }
                                    var y = l.joints["index-finger-tip"],
                                        _ = l.joints["thumb-tip"],
                                        x = y.position.distanceTo(_.position);
                                    l.inputState.pinching && x > .025 ? (l.inputState.pinching = !1, this.dispatchEvent({
                                        type: "pinchend",
                                        handedness: e.handedness,
                                        target: this
                                    })) : !l.inputState.pinching && x <= .015 && (l.inputState.pinching = !0, this.dispatchEvent({
                                        type: "pinchstart",
                                        handedness: e.handedness,
                                        target: this
                                    }))
                                } else null !== s && e.gripSpace && null !== (i = t.getPose(e.gripSpace, n)) && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1)
                            }
                            return null !== o && (o.visible = null !== r), null !== s && (s.visible = null !== i), null !== l && (l.visible = null !== a), this
                        }
                    }]), e
                }(),
                aE = function(e) {
                    function t(e, n, r, i, a, o, s, l, u, c) {
                        var h;
                        if ((0, k._)(this, t), 1026 !== (c = void 0 !== c ? c : 1026) && 1027 !== c) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                        return void 0 === r && 1026 === c && (r = 1012), void 0 === r && 1027 === c && (r = 1020), (h = (0, E._)(this, t, [null, i, a, o, s, l, c, r, u])).image = {
                            width: e,
                            height: n
                        }, h.magFilter = void 0 !== s ? s : 1003, h.minFilter = void 0 !== l ? l : 1003, h.flipY = !1, h.generateMipmaps = !1, h
                    }
                    return (0, P._)(t, e), t
                }(te);
            aE.prototype.isDepthTexture = !0;
            var ak = function(e) {
                function t(e, n) {
                    (0, k._)(this, t), r = (0, E._)(this, t);
                    var r, i, a = null,
                        o = 1,
                        s = null,
                        l = "local-floor",
                        u = e.extensions.has("WEBGL_multisampled_render_to_texture"),
                        c = null,
                        h = null,
                        d = null,
                        f = null,
                        p = !1,
                        m = null,
                        v = n.getContextAttributes(),
                        g = null,
                        y = null,
                        _ = [],
                        x = new Map,
                        b = new n5;
                    b.layers.enable(1), b.viewport = new tn;
                    var w = new n5;
                    w.layers.enable(2), w.viewport = new tn;
                    var M = [b, w],
                        S = new aw;
                    S.layers.enable(1), S.layers.enable(2);
                    var A = null,
                        R = null;

                    function C(e) {
                        var t = x.get(e.inputSource);
                        t && t.dispatchEvent({
                            type: e.type,
                            data: e.inputSource
                        })
                    }

                    function L() {
                        x.forEach(function(e, t) {
                            e.disconnect(t)
                        }), x.clear(), A = null, R = null, e.setRenderTarget(g), f = null, d = null, h = null, a = null, y = null, F.stop(), r.isPresenting = !1, r.dispatchEvent({
                            type: "sessionend"
                        })
                    }

                    function P(e) {
                        for (var t = a.inputSources, n = 0; n < _.length; n++) x.set(t[n], _[n]);
                        for (var r = 0; r < e.removed.length; r++) {
                            var i = e.removed[r],
                                o = x.get(i);
                            o && (o.dispatchEvent({
                                type: "disconnected",
                                data: i
                            }), x.delete(i))
                        }
                        for (var s = 0; s < e.added.length; s++) {
                            var l = e.added[s],
                                u = x.get(l);
                            u && u.dispatchEvent({
                                type: "connected",
                                data: l
                            })
                        }
                    }
                    r.cameraAutoUpdate = !0, r.enabled = !1, r.isPresenting = !1, r.getController = function(e) {
                        var t = _[e];
                        return void 0 === t && (t = new aT, _[e] = t), t.getTargetRaySpace()
                    }, r.getControllerGrip = function(e) {
                        var t = _[e];
                        return void 0 === t && (t = new aT, _[e] = t), t.getGripSpace()
                    }, r.getHand = function(e) {
                        var t = _[e];
                        return void 0 === t && (t = new aT, _[e] = t), t.getHandSpace()
                    }, r.setFramebufferScaleFactor = function(e) {
                        o = e, !0 === r.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                    }, r.setReferenceSpaceType = function(e) {
                        l = e, !0 === r.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                    }, r.getReferenceSpace = function() {
                        return s
                    }, r.getBaseLayer = function() {
                        return null !== d ? d : f
                    }, r.getBinding = function() {
                        return h
                    }, r.getFrame = function() {
                        return m
                    }, r.getSession = function() {
                        return a
                    }, r.setSession = (i = (0, T._)(function(t) {
                        var i, c, m, _, x;
                        return (0, z.YH)(this, function(b) {
                            switch (b.label) {
                                case 0:
                                    if (null === (a = t)) return [3, 4];
                                    if (g = e.getRenderTarget(), a.addEventListener("select", C), a.addEventListener("selectstart", C), a.addEventListener("selectend", C), a.addEventListener("squeeze", C), a.addEventListener("squeezestart", C), a.addEventListener("squeezeend", C), a.addEventListener("end", L), a.addEventListener("inputsourceschange", P), !(!0 !== v.xrCompatible)) return [3, 2];
                                    return [4, n.makeXRCompatible()];
                                case 1:
                                    b.sent(), b.label = 2;
                                case 2:
                                    return void 0 === a.renderState.layers || !1 === e.capabilities.isWebGL2 ? (i = {
                                        antialias: void 0 !== a.renderState.layers || v.antialias,
                                        alpha: v.alpha,
                                        depth: v.depth,
                                        stencil: v.stencil,
                                        framebufferScaleFactor: o
                                    }, f = new XRWebGLLayer(a, n, i), a.updateRenderState({
                                        baseLayer: f
                                    }), y = new tr(f.framebufferWidth, f.framebufferHeight, {
                                        format: 1023,
                                        type: 1009,
                                        encoding: e.outputEncoding
                                    })) : (p = v.antialias, c = null, m = null, _ = null, v.depth && (_ = v.stencil ? 35056 : 33190, c = v.stencil ? 1027 : 1026, m = v.stencil ? 1020 : 1012), x = {
                                        colorFormat: v.alpha || p ? 32856 : 32849,
                                        depthFormat: _,
                                        scaleFactor: o
                                    }, d = (h = new XRWebGLBinding(a, n)).createProjectionLayer(x), a.updateRenderState({
                                        layers: [d]
                                    }), y = p ? new ti(d.textureWidth, d.textureHeight, {
                                        format: 1023,
                                        type: 1009,
                                        depthTexture: new aE(d.textureWidth, d.textureHeight, m, void 0, void 0, void 0, void 0, void 0, void 0, c),
                                        stencilBuffer: v.stencil,
                                        ignoreDepth: d.ignoreDepthValues,
                                        useRenderToTexture: u,
                                        encoding: e.outputEncoding
                                    }) : new tr(d.textureWidth, d.textureHeight, {
                                        format: v.alpha ? 1023 : 1022,
                                        type: 1009,
                                        depthTexture: new aE(d.textureWidth, d.textureHeight, m, void 0, void 0, void 0, void 0, void 0, void 0, c),
                                        stencilBuffer: v.stencil,
                                        ignoreDepth: d.ignoreDepthValues,
                                        encoding: e.outputEncoding
                                    })), this.setFoveation(1), [4, a.requestReferenceSpace(l)];
                                case 3:
                                    s = b.sent(), F.setContext(a), F.start(), r.isPresenting = !0, r.dispatchEvent({
                                        type: "sessionstart"
                                    }), b.label = 4;
                                case 4:
                                    return [2]
                            }
                        })
                    }), function(e) {
                        return i.apply(this, arguments)
                    });
                    var I = new to,
                        D = new to;

                    function O(e, t) {
                        null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
                    }
                    r.updateCamera = function(e) {
                        if (null !== a) {
                            S.near = w.near = b.near = e.near, S.far = w.far = b.far = e.far, A === S.near && R === S.far || (a.updateRenderState({
                                depthNear: S.near,
                                depthFar: S.far
                            }), A = S.near, R = S.far);
                            var t = e.parent,
                                n = S.cameras;
                            O(S, t);
                            for (var r = 0; r < n.length; r++) O(n[r], t);
                            S.matrixWorld.decompose(S.position, S.quaternion, S.scale), e.position.copy(S.position), e.quaternion.copy(S.quaternion), e.scale.copy(S.scale), e.matrix.copy(S.matrix), e.matrixWorld.copy(S.matrixWorld);
                            for (var i = e.children, o = 0, s = i.length; o < s; o++) i[o].updateMatrixWorld(!0);
                            2 === n.length ? function(e, t, n) {
                                I.setFromMatrixPosition(t.matrixWorld), D.setFromMatrixPosition(n.matrixWorld);
                                var r = I.distanceTo(D),
                                    i = t.projectionMatrix.elements,
                                    a = n.projectionMatrix.elements,
                                    o = i[14] / (i[10] - 1),
                                    s = i[14] / (i[10] + 1),
                                    l = (i[9] + 1) / i[5],
                                    u = (i[9] - 1) / i[5],
                                    c = (i[8] - 1) / i[0],
                                    h = (a[8] + 1) / a[0],
                                    d = r / (-c + h),
                                    f = -(d * c);
                                t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(f), e.translateZ(d), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
                                var p = o + d,
                                    m = s + d;
                                e.projectionMatrix.makePerspective(o * c - f, o * h + (r - f), l * s / m * p, u * s / m * p, p, m)
                            }(S, b, w) : S.projectionMatrix.copy(b.projectionMatrix)
                        }
                    }, r.getCamera = function() {
                        return S
                    }, r.getFoveation = function() {
                        return null !== d ? d.fixedFoveation : null !== f ? f.fixedFoveation : void 0
                    }, r.setFoveation = function(e) {
                        null !== d && (d.fixedFoveation = e), null !== f && void 0 !== f.fixedFoveation && (f.fixedFoveation = e)
                    };
                    var N = null,
                        F = new ro;
                    return F.setAnimationLoop(function(t, n) {
                        if (c = n.getViewerPose(s), m = n, null !== c) {
                            var r = c.views;
                            null !== f && (e.setRenderTargetFramebuffer(y, f.framebuffer), e.setRenderTarget(y));
                            var i = !1;
                            r.length !== S.cameras.length && (S.cameras.length = 0, i = !0);
                            for (var o = 0; o < r.length; o++) {
                                var l = r[o],
                                    u = null;
                                if (null !== f) u = f.getViewport(l);
                                else {
                                    var p = h.getViewSubImage(d, l);
                                    u = p.viewport, 0 === o && (e.setRenderTargetTextures(y, p.colorTexture, d.ignoreDepthValues ? void 0 : p.depthStencilTexture), e.setRenderTarget(y))
                                }
                                var v = M[o];
                                v.matrix.fromArray(l.transform.matrix), v.projectionMatrix.fromArray(l.projectionMatrix), v.viewport.set(u.x, u.y, u.width, u.height), 0 === o && S.matrix.copy(v.matrix), !0 === i && S.cameras.push(v)
                            }
                        }
                        for (var g = a.inputSources, x = 0; x < _.length; x++) {
                            var b = _[x],
                                w = g[x];
                            b.update(w, n, s)
                        }
                        N && N(t, n), m = null
                    }), r.setAnimationLoop = function(e) {
                        N = e
                    }, r.dispose = function() {}, r
                }
                return (0, P._)(t, e), t
            }(eW);

            function aA(e) {
                function t(t, n) {
                    t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (t.map.value = n.map), n.alphaMap && (t.alphaMap.value = n.alphaMap), n.specularMap && (t.specularMap.value = n.specularMap), n.alphaTest > 0 && (t.alphaTest.value = n.alphaTest);
                    var r, i, a = e.get(n).envMap;
                    a && (t.envMap.value = a, t.flipEnvMap.value = a.isCubeTexture && !1 === a.isRenderTargetTexture ? -1 : 1, t.reflectivity.value = n.reflectivity, t.ior.value = n.ior, t.refractionRatio.value = n.refractionRatio), n.lightMap && (t.lightMap.value = n.lightMap, t.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (t.aoMap.value = n.aoMap, t.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? r = n.clearcoatRoughnessMap : n.specularIntensityMap ? r = n.specularIntensityMap : n.specularColorMap ? r = n.specularColorMap : n.transmissionMap ? r = n.transmissionMap : n.thicknessMap ? r = n.thicknessMap : n.sheenColorMap ? r = n.sheenColorMap : n.sheenRoughnessMap && (r = n.sheenRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)), n.aoMap ? i = n.aoMap : n.lightMap && (i = n.lightMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uv2Transform.value.copy(i.matrix))
                }

                function n(t, n) {
                    t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n.metalnessMap && (t.metalnessMap.value = n.metalnessMap), n.emissiveMap && (t.emissiveMap.value = n.emissiveMap), n.bumpMap && (t.bumpMap.value = n.bumpMap, t.bumpScale.value = n.bumpScale, 1 === n.side && (t.bumpScale.value *= -1)), n.normalMap && (t.normalMap.value = n.normalMap, t.normalScale.value.copy(n.normalScale), 1 === n.side && t.normalScale.value.negate()), n.displacementMap && (t.displacementMap.value = n.displacementMap, t.displacementScale.value = n.displacementScale, t.displacementBias.value = n.displacementBias), e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity)
                }
                return {
                    refreshFogUniforms: function(e, t) {
                        e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
                    },
                    refreshMaterialUniforms: function(e, r, i, a, o) {
                        var s, l;
                        r.isMeshBasicMaterial ? t(e, r) : r.isMeshLambertMaterial ? (t(e, r), r.emissiveMap && (e.emissiveMap.value = r.emissiveMap)) : r.isMeshToonMaterial ? (t(e, r), r.gradientMap && (e.gradientMap.value = r.gradientMap), r.emissiveMap && (e.emissiveMap.value = r.emissiveMap), r.bumpMap && (e.bumpMap.value = r.bumpMap, e.bumpScale.value = r.bumpScale, 1 === r.side && (e.bumpScale.value *= -1)), r.normalMap && (e.normalMap.value = r.normalMap, e.normalScale.value.copy(r.normalScale), 1 === r.side && e.normalScale.value.negate()), r.displacementMap && (e.displacementMap.value = r.displacementMap, e.displacementScale.value = r.displacementScale, e.displacementBias.value = r.displacementBias)) : r.isMeshPhongMaterial ? (t(e, r), e.specular.value.copy(r.specular), e.shininess.value = Math.max(r.shininess, 1e-4), r.emissiveMap && (e.emissiveMap.value = r.emissiveMap), r.bumpMap && (e.bumpMap.value = r.bumpMap, e.bumpScale.value = r.bumpScale, 1 === r.side && (e.bumpScale.value *= -1)), r.normalMap && (e.normalMap.value = r.normalMap, e.normalScale.value.copy(r.normalScale), 1 === r.side && e.normalScale.value.negate()), r.displacementMap && (e.displacementMap.value = r.displacementMap, e.displacementScale.value = r.displacementScale, e.displacementBias.value = r.displacementBias)) : r.isMeshStandardMaterial ? (t(e, r), r.isMeshPhysicalMaterial ? (n(e, r), e.ior.value = r.ior, r.sheen > 0 && (e.sheenColor.value.copy(r.sheenColor).multiplyScalar(r.sheen), e.sheenRoughness.value = r.sheenRoughness, r.sheenColorMap && (e.sheenColorMap.value = r.sheenColorMap), r.sheenRoughnessMap && (e.sheenRoughnessMap.value = r.sheenRoughnessMap)), r.clearcoat > 0 && (e.clearcoat.value = r.clearcoat, e.clearcoatRoughness.value = r.clearcoatRoughness, r.clearcoatMap && (e.clearcoatMap.value = r.clearcoatMap), r.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = r.clearcoatRoughnessMap), r.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(r.clearcoatNormalScale), e.clearcoatNormalMap.value = r.clearcoatNormalMap, 1 === r.side && e.clearcoatNormalScale.value.negate())), r.transmission > 0 && (e.transmission.value = r.transmission, e.transmissionSamplerMap.value = o.texture, e.transmissionSamplerSize.value.set(o.width, o.height), r.transmissionMap && (e.transmissionMap.value = r.transmissionMap), e.thickness.value = r.thickness, r.thicknessMap && (e.thicknessMap.value = r.thicknessMap), e.attenuationDistance.value = r.attenuationDistance, e.attenuationColor.value.copy(r.attenuationColor)), e.specularIntensity.value = r.specularIntensity, e.specularColor.value.copy(r.specularColor), r.specularIntensityMap && (e.specularIntensityMap.value = r.specularIntensityMap), r.specularColorMap && (e.specularColorMap.value = r.specularColorMap)) : n(e, r)) : r.isMeshMatcapMaterial ? (t(e, r), r.matcap && (e.matcap.value = r.matcap), r.bumpMap && (e.bumpMap.value = r.bumpMap, e.bumpScale.value = r.bumpScale, 1 === r.side && (e.bumpScale.value *= -1)), r.normalMap && (e.normalMap.value = r.normalMap, e.normalScale.value.copy(r.normalScale), 1 === r.side && e.normalScale.value.negate()), r.displacementMap && (e.displacementMap.value = r.displacementMap, e.displacementScale.value = r.displacementScale, e.displacementBias.value = r.displacementBias)) : r.isMeshDepthMaterial ? (t(e, r), r.displacementMap && (e.displacementMap.value = r.displacementMap, e.displacementScale.value = r.displacementScale, e.displacementBias.value = r.displacementBias)) : r.isMeshDistanceMaterial ? (t(e, r), r.displacementMap && (e.displacementMap.value = r.displacementMap, e.displacementScale.value = r.displacementScale, e.displacementBias.value = r.displacementBias), e.referencePosition.value.copy(r.referencePosition), e.nearDistance.value = r.nearDistance, e.farDistance.value = r.farDistance) : r.isMeshNormalMaterial ? (t(e, r), r.bumpMap && (e.bumpMap.value = r.bumpMap, e.bumpScale.value = r.bumpScale, 1 === r.side && (e.bumpScale.value *= -1)), r.normalMap && (e.normalMap.value = r.normalMap, e.normalScale.value.copy(r.normalScale), 1 === r.side && e.normalScale.value.negate()), r.displacementMap && (e.displacementMap.value = r.displacementMap, e.displacementScale.value = r.displacementScale, e.displacementBias.value = r.displacementBias)) : r.isLineBasicMaterial ? (e.diffuse.value.copy(r.color), e.opacity.value = r.opacity, r.isLineDashedMaterial && (e.dashSize.value = r.dashSize, e.totalSize.value = r.dashSize + r.gapSize, e.scale.value = r.scale)) : r.isPointsMaterial ? (e.diffuse.value.copy(r.color), e.opacity.value = r.opacity, e.size.value = r.size * i, e.scale.value = .5 * a, r.map && (e.map.value = r.map), r.alphaMap && (e.alphaMap.value = r.alphaMap), r.alphaTest > 0 && (e.alphaTest.value = r.alphaTest), r.map ? s = r.map : r.alphaMap && (s = r.alphaMap), void 0 !== s && (!0 === s.matrixAutoUpdate && s.updateMatrix(), e.uvTransform.value.copy(s.matrix))) : r.isSpriteMaterial ? (e.diffuse.value.copy(r.color), e.opacity.value = r.opacity, e.rotation.value = r.rotation, r.map && (e.map.value = r.map), r.alphaMap && (e.alphaMap.value = r.alphaMap), r.alphaTest > 0 && (e.alphaTest.value = r.alphaTest), r.map ? l = r.map : r.alphaMap && (l = r.alphaMap), void 0 !== l && (!0 === l.matrixAutoUpdate && l.updateMatrix(), e.uvTransform.value.copy(l.matrix))) : r.isShadowMaterial ? (e.color.value.copy(r.color), e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                    }
                }
            }

            function aR() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    t = void 0 !== e.canvas ? e.canvas : ((V = e8("canvas")).style.display = "block", V),
                    n = void 0 !== e.context ? e.context : null,
                    r = void 0 !== e.alpha && e.alpha,
                    i = void 0 === e.depth || e.depth,
                    a = void 0 === e.stencil || e.stencil,
                    o = void 0 !== e.antialias && e.antialias,
                    s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    u = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    c = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat,
                    h = null,
                    d = null,
                    f = [],
                    p = [];
                this.domElement = t, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
                var m = this,
                    v = !1,
                    g = 0,
                    y = 0,
                    _ = null,
                    x = -1,
                    b = null,
                    w = new tn,
                    M = new tn,
                    S = null,
                    T = t.width,
                    E = t.height,
                    k = 1,
                    A = null,
                    R = null,
                    C = new tn(0, 0, T, E),
                    L = new tn(0, 0, T, E),
                    P = !1,
                    I = [],
                    D = new ra,
                    O = !1,
                    N = !1,
                    F = null,
                    U = new tF,
                    B = new to,
                    z = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function H() {
                    return null === _ ? k : 1
                }
                var V, G, W, j, q, X, Y, J, Z, K, Q, $, ee, et, en, er, ei, ea, eo, es, el, eu, ec, eh, ed = n;

                function ef(e, n) {
                    for (var r = 0; r < e.length; r++) {
                        var i = e[r],
                            a = t.getContext(i, n);
                        if (null !== a) return a
                    }
                    return null
                }
                try {
                    if ("setAttribute" in t && t.setAttribute("data-engine", "three.js r136"), t.addEventListener("webglcontextlost", eg, !1), t.addEventListener("webglcontextrestored", ey, !1), null === ed) {
                        var ep = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === m.isWebGL1Renderer && ep.shift(), ed = ef(ep, {
                                alpha: r,
                                depth: i,
                                stencil: a,
                                antialias: o,
                                premultipliedAlpha: s,
                                preserveDrawingBuffer: l,
                                powerPreference: u,
                                failIfMajorPerformanceCaveat: c
                            }), null === ed) throw ef(ep) ? Error("Error creating WebGL context with your selected attributes.") : Error("Error creating WebGL context.")
                    }
                    void 0 === ed.getShaderPrecisionFormat && (ed.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (e) {
                    throw console.error("THREE.WebGLRenderer: " + e.message), e
                }

                function em() {
                    G = new rH(ed), W = new rm(ed, G, e), G.init(W), ec = new ab(ed, G, W), j = new a_(ed, G, W), I[0] = 1029, q = new rW(ed), X = new aa, Y = new ax(ed, G, j, X, W, ec, q), J = new rg(m), Z = new rz(m), K = new rs(ed, W), eh = new rf(ed, G, K, W), Q = new rV(ed, K, q, eh), $ = new rZ(ed, Q, K, q), es = new rJ(ed, W, Y), ei = new rv(X), ee = new ai(m, J, Z, G, W, eh, ei), et = new aA(X), en = new au, er = new am(G, W), eo = new rd(m, J, j, $, s), ea = new ay(m, $, W), el = new rp(ed, G, q, W), eu = new rG(ed, G, q, W), q.programs = ee.programs, m.capabilities = W, m.extensions = G, m.properties = X, m.renderLists = en, m.shadowMap = ea, m.state = j, m.info = q
                }
                em();
                var ev = new ak(m, ed);

                function eg(e) {
                    e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), v = !0
                }

                function ey() {
                    console.log("THREE.WebGLRenderer: Context Restored."), v = !1;
                    var e = q.autoReset,
                        t = ea.enabled,
                        n = ea.autoUpdate,
                        r = ea.needsUpdate,
                        i = ea.type;
                    em(), q.autoReset = e, ea.enabled = t, ea.autoUpdate = n, ea.needsUpdate = r, ea.type = i
                }

                function e_(e) {
                    var t, n = e.target;
                    n.removeEventListener("dispose", e_), void 0 !== (t = X.get(n).programs) && (t.forEach(function(e) {
                        ee.releaseProgram(e)
                    }), n.isShaderMaterial && ee.releaseShaderCache(n)), X.remove(n)
                }
                this.xr = ev, this.getContext = function() {
                    return ed
                }, this.getContextAttributes = function() {
                    return ed.getContextAttributes()
                }, this.forceContextLoss = function() {
                    var e = G.get("WEBGL_lose_context");
                    e && e.loseContext()
                }, this.forceContextRestore = function() {
                    var e = G.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }, this.getPixelRatio = function() {
                    return k
                }, this.setPixelRatio = function(e) {
                    void 0 !== e && (k = e, this.setSize(T, E, !1))
                }, this.getSize = function(e) {
                    return e.set(T, E)
                }, this.setSize = function(e, n, r) {
                    ev.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = e, E = n, t.width = Math.floor(e * k), t.height = Math.floor(n * k), !1 !== r && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n))
                }, this.getDrawingBufferSize = function(e) {
                    return e.set(T * k, E * k).floor()
                }, this.setDrawingBufferSize = function(e, n, r) {
                    T = e, E = n, k = r, t.width = Math.floor(e * r), t.height = Math.floor(n * r), this.setViewport(0, 0, e, n)
                }, this.getCurrentViewport = function(e) {
                    return e.copy(w)
                }, this.getViewport = function(e) {
                    return e.copy(C)
                }, this.setViewport = function(e, t, n, r) {
                    e.isVector4 ? C.set(e.x, e.y, e.z, e.w) : C.set(e, t, n, r), j.viewport(w.copy(C).multiplyScalar(k).floor())
                }, this.getScissor = function(e) {
                    return e.copy(L)
                }, this.setScissor = function(e, t, n, r) {
                    e.isVector4 ? L.set(e.x, e.y, e.z, e.w) : L.set(e, t, n, r), j.scissor(M.copy(L).multiplyScalar(k).floor())
                }, this.getScissorTest = function() {
                    return P
                }, this.setScissorTest = function(e) {
                    j.setScissorTest(P = e)
                }, this.setOpaqueSort = function(e) {
                    A = e
                }, this.setTransparentSort = function(e) {
                    R = e
                }, this.getClearColor = function(e) {
                    return e.copy(eo.getClearColor())
                }, this.setClearColor = function() {
                    eo.setClearColor.apply(eo, arguments)
                }, this.getClearAlpha = function() {
                    return eo.getClearAlpha()
                }, this.setClearAlpha = function() {
                    eo.setClearAlpha.apply(eo, arguments)
                }, this.clear = function(e, t, n) {
                    var r = 0;
                    (void 0 === e || e) && (r |= 16384), (void 0 === t || t) && (r |= 256), (void 0 === n || n) && (r |= 1024), ed.clear(r)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    t.removeEventListener("webglcontextlost", eg, !1), t.removeEventListener("webglcontextrestored", ey, !1), en.dispose(), er.dispose(), X.dispose(), J.dispose(), Z.dispose(), $.dispose(), eh.dispose(), ee.dispose(), ev.dispose(), ev.removeEventListener("sessionstart", eb), ev.removeEventListener("sessionend", ew), F && (F.dispose(), F = null), eM.stop()
                }, this.renderBufferDirect = function(e, t, n, r, i, a) {
                    null === t && (t = z);
                    var o = i.isMesh && 0 > i.matrixWorld.determinant(),
                        s = function(e, t, n, r, i) {
                            !0 !== t.isScene && (t = z), Y.resetTextureUnits();
                            var a, o = t.fog,
                                s = r.isMeshStandardMaterial ? t.environment : null,
                                l = null === _ ? m.outputEncoding : _.texture.encoding,
                                u = (r.isMeshStandardMaterial ? Z : J).get(r.envMap || s),
                                c = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                h = !!r.normalMap && !!n.attributes.tangent,
                                f = !!n.morphAttributes.position,
                                p = !!n.morphAttributes.normal,
                                v = n.morphAttributes.position ? n.morphAttributes.position.length : 0,
                                g = r.toneMapped ? m.toneMapping : 0,
                                y = X.get(r),
                                w = d.state.lights;
                            if (!0 === O && (!0 === N || e !== b)) {
                                var M = e === b && r.id === x;
                                ei.setState(r, e, M)
                            }
                            var S = !1;
                            r.version === y.__version ? y.needsLights && y.lightsStateVersion !== w.state.version || y.outputEncoding !== l || i.isInstancedMesh && !1 === y.instancing ? S = !0 : i.isInstancedMesh || !0 !== y.instancing ? i.isSkinnedMesh && !1 === y.skinning ? S = !0 : i.isSkinnedMesh || !0 !== y.skinning ? y.envMap !== u || r.fog && y.fog !== o ? S = !0 : void 0 === y.numClippingPlanes || y.numClippingPlanes === ei.numPlanes && y.numIntersection === ei.numIntersection ? (y.vertexAlphas !== c || y.vertexTangents !== h || y.morphTargets !== f || y.morphNormals !== p || y.toneMapping !== g || !0 === W.isWebGL2 && y.morphTargetsCount !== v) && (S = !0) : S = !0 : S = !0 : S = !0 : (S = !0, y.__version = r.version);
                            var T = y.currentProgram;
                            !0 === S && (T = eE(r, t, i));
                            var A = !1,
                                R = !1,
                                C = !1,
                                L = T.getUniforms(),
                                P = y.uniforms;
                            if (j.useProgram(T.program) && (A = !0, R = !0, C = !0), r.id !== x && (x = r.id, R = !0), A || b !== e) {
                                if (L.setValue(ed, "projectionMatrix", e.projectionMatrix), W.logarithmicDepthBuffer && L.setValue(ed, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), b !== e && (b = e, R = !0, C = !0), r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshStandardMaterial || r.envMap) {
                                    var I = L.map.cameraPosition;
                                    void 0 !== I && I.setValue(ed, B.setFromMatrixPosition(e.matrixWorld))
                                }(r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && L.setValue(ed, "isOrthographic", !0 === e.isOrthographicCamera), (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.isShadowMaterial || i.isSkinnedMesh) && L.setValue(ed, "viewMatrix", e.matrixWorldInverse)
                            }
                            if (i.isSkinnedMesh) {
                                L.setOptional(ed, i, "bindMatrix"), L.setOptional(ed, i, "bindMatrixInverse");
                                var D = i.skeleton;
                                D && (W.floatVertexTextures ? (null === D.boneTexture && D.computeBoneTexture(), L.setValue(ed, "boneTexture", D.boneTexture, Y), L.setValue(ed, "boneTextureSize", D.boneTextureSize)) : L.setOptional(ed, D, "boneMatrices"))
                            }
                            return n && (void 0 !== n.morphAttributes.position || void 0 !== n.morphAttributes.normal) && es.update(i, n, r, T), (R || y.receiveShadow !== i.receiveShadow) && (y.receiveShadow = i.receiveShadow, L.setValue(ed, "receiveShadow", i.receiveShadow)), R && (L.setValue(ed, "toneMappingExposure", m.toneMappingExposure), y.needsLights && (a = C, P.ambientLightColor.needsUpdate = a, P.lightProbe.needsUpdate = a, P.directionalLights.needsUpdate = a, P.directionalLightShadows.needsUpdate = a, P.pointLights.needsUpdate = a, P.pointLightShadows.needsUpdate = a, P.spotLights.needsUpdate = a, P.spotLightShadows.needsUpdate = a, P.rectAreaLights.needsUpdate = a, P.hemisphereLights.needsUpdate = a), o && r.fog && et.refreshFogUniforms(P, o), et.refreshMaterialUniforms(P, r, k, E, F), iq.upload(ed, y.uniformsList, P, Y)), r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (iq.upload(ed, y.uniformsList, P, Y), r.uniformsNeedUpdate = !1), r.isSpriteMaterial && L.setValue(ed, "center", i.center), L.setValue(ed, "modelViewMatrix", i.modelViewMatrix), L.setValue(ed, "normalMatrix", i.normalMatrix), L.setValue(ed, "modelMatrix", i.matrixWorld), T
                        }(e, t, n, r, i);
                    j.setMaterial(r, o);
                    var l = n.index,
                        u = n.attributes.position;
                    if (null === l) {
                        if (void 0 === u || 0 === u.count) return
                    } else if (0 === l.count) return;
                    var c, h = 1;
                    !0 === r.wireframe && (l = Q.getWireframeAttribute(n), h = 2), eh.setup(i, r, s, n, l);
                    var f = el;
                    null !== l && (c = K.get(l), (f = eu).setIndex(c));
                    var p = null !== l ? l.count : u.count,
                        v = n.drawRange.start * h,
                        g = n.drawRange.count * h,
                        y = null !== a ? a.start * h : 0,
                        w = null !== a ? a.count * h : 1 / 0,
                        M = Math.max(v, y),
                        S = Math.max(0, Math.min(p, v + g, y + w) - 1 - M + 1);
                    if (0 !== S) {
                        if (i.isMesh) !0 === r.wireframe ? (j.setLineWidth(r.wireframeLinewidth * H()), f.setMode(1)) : f.setMode(4);
                        else if (i.isLine) {
                            var T = r.linewidth;
                            void 0 === T && (T = 1), j.setLineWidth(T * H()), i.isLineSegments ? f.setMode(1) : i.isLineLoop ? f.setMode(2) : f.setMode(3)
                        } else i.isPoints ? f.setMode(0) : i.isSprite && f.setMode(4);
                        if (i.isInstancedMesh) f.renderInstances(M, S, i.count);
                        else if (n.isInstancedBufferGeometry) {
                            var A = Math.min(n.instanceCount, n._maxInstanceCount);
                            f.renderInstances(M, S, A)
                        } else f.render(M, S)
                    }
                }, this.compile = function(e, t) {
                    (d = er.get(e)).init(), p.push(d), e.traverseVisible(function(e) {
                        e.isLight && e.layers.test(t.layers) && (d.pushLight(e), e.castShadow && d.pushShadow(e))
                    }), d.setupLights(m.physicallyCorrectLights), e.traverse(function(t) {
                        var n = t.material;
                        if (n) {
                            if (Array.isArray(n))
                                for (var r = 0; r < n.length; r++) eE(n[r], e, t);
                            else eE(n, e, t)
                        }
                    }), p.pop(), d = null
                };
                var ex = null;

                function eb() {
                    eM.stop()
                }

                function ew() {
                    eM.start()
                }
                var eM = new ro;

                function eS(e, t, n, r) {
                    var i, a, s = e.opaque,
                        l = e.transmissive,
                        u = e.transparent;
                    d.setupLightsView(n), l.length > 0 && (null === F && (F = new(!0 === o && !0 === W.isWebGL2 ? ti : tr)(1024, 1024, {
                        generateMipmaps: !0,
                        type: null !== ec.convert(1016) ? 1016 : 1009,
                        minFilter: 1008,
                        magFilter: 1003,
                        wrapS: 1001,
                        wrapT: 1001,
                        useRenderToTexture: G.has("WEBGL_multisampled_render_to_texture")
                    })), i = m.getRenderTarget(), m.setRenderTarget(F), m.clear(), a = m.toneMapping, m.toneMapping = 0, eT(s, t, n), m.toneMapping = a, Y.updateMultisampleRenderTarget(F), Y.updateRenderTargetMipmap(F), m.setRenderTarget(i)), r && j.viewport(w.copy(r)), s.length > 0 && eT(s, t, n), l.length > 0 && eT(l, t, n), u.length > 0 && eT(u, t, n)
                }

                function eT(e, t, n) {
                    for (var r = !0 === t.isScene ? t.overrideMaterial : null, i = 0, a = e.length; i < a; i++) {
                        var o = e[i],
                            s = o.object,
                            l = o.geometry,
                            u = null === r ? o.material : r,
                            c = o.group;
                        s.layers.test(n.layers) && (s.onBeforeRender(m, t, n, l, u, c), s.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, s.matrixWorld), s.normalMatrix.getNormalMatrix(s.modelViewMatrix), u.onBeforeRender(m, t, n, l, s, c), !0 === u.transparent && 2 === u.side ? (u.side = 1, u.needsUpdate = !0, m.renderBufferDirect(n, t, l, u, s, c), u.side = 0, u.needsUpdate = !0, m.renderBufferDirect(n, t, l, u, s, c), u.side = 2) : m.renderBufferDirect(n, t, l, u, s, c), s.onAfterRender(m, t, n, l, u, c))
                    }
                }

                function eE(e, t, n) {
                    !0 !== t.isScene && (t = z);
                    var r = X.get(e),
                        i = d.state.lights,
                        a = d.state.shadowsArray,
                        o = i.state.version,
                        s = ee.getParameters(e, i.state, a, t, n),
                        l = ee.getProgramCacheKey(s),
                        u = r.programs;
                    r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = (e.isMeshStandardMaterial ? Z : J).get(e.envMap || r.environment), void 0 === u && (e.addEventListener("dispose", e_), u = new Map, r.programs = u);
                    var c = u.get(l);
                    if (void 0 !== c) {
                        if (r.currentProgram === c && r.lightsStateVersion === o) return ek(e, s), c
                    } else s.uniforms = ee.getUniforms(e), e.onBuild(n, s, m), e.onBeforeCompile(s, m), c = ee.acquireProgram(s, l), u.set(l, c), r.uniforms = s.uniforms;
                    var h = r.uniforms;
                    (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (h.clippingPlanes = ei.uniform), ek(e, s), r.needsLights = e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights, r.lightsStateVersion = o, r.needsLights && (h.ambientLightColor.value = i.state.ambient, h.lightProbe.value = i.state.probe, h.directionalLights.value = i.state.directional, h.directionalLightShadows.value = i.state.directionalShadow, h.spotLights.value = i.state.spot, h.spotLightShadows.value = i.state.spotShadow, h.rectAreaLights.value = i.state.rectArea, h.ltc_1.value = i.state.rectAreaLTC1, h.ltc_2.value = i.state.rectAreaLTC2, h.pointLights.value = i.state.point, h.pointLightShadows.value = i.state.pointShadow, h.hemisphereLights.value = i.state.hemi, h.directionalShadowMap.value = i.state.directionalShadowMap, h.directionalShadowMatrix.value = i.state.directionalShadowMatrix, h.spotShadowMap.value = i.state.spotShadowMap, h.spotShadowMatrix.value = i.state.spotShadowMatrix, h.pointShadowMap.value = i.state.pointShadowMap, h.pointShadowMatrix.value = i.state.pointShadowMatrix);
                    var f = c.getUniforms(),
                        p = iq.seqWithValue(f.seq, h);
                    return r.currentProgram = c, r.uniformsList = p, c
                }

                function ek(e, t) {
                    var n = X.get(e);
                    n.outputEncoding = t.outputEncoding, n.instancing = t.instancing, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping
                }
                eM.setAnimationLoop(function(e) {
                    ex && ex(e)
                }), eM.setContext(window), this.setAnimationLoop = function(e) {
                    ex = e, ev.setAnimationLoop(e), null === e ? eM.stop() : eM.start()
                }, ev.addEventListener("sessionstart", eb), ev.addEventListener("sessionend", ew), this.render = function(e, t) {
                    if (void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 !== v) {
                        !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === ev.enabled && !0 === ev.isPresenting && (!0 === ev.cameraAutoUpdate && ev.updateCamera(t), t = ev.getCamera()), !0 === e.isScene && e.onBeforeRender(m, e, t, _), (d = er.get(e, p.length)).init(), p.push(d), U.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), D.setFromProjectionMatrix(U), N = this.localClippingEnabled, O = ei.init(this.clippingPlanes, N, t), (h = en.get(e, f.length)).init(), f.push(h),
                            function e(t, n, r, i) {
                                if (!1 !== t.visible) {
                                    if (t.layers.test(n.layers)) {
                                        if (t.isGroup) r = t.renderOrder;
                                        else if (t.isLOD) !0 === t.autoUpdate && t.update(n);
                                        else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
                                        else if (t.isSprite) {
                                            if (!t.frustumCulled || D.intersectsSprite(t)) {
                                                i && B.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);
                                                var a = $.update(t),
                                                    o = t.material;
                                                o.visible && h.push(t, a, o, r, B.z, null)
                                            }
                                        } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== q.render.frame && (t.skeleton.update(), t.skeleton.frame = q.render.frame), !t.frustumCulled || D.intersectsObject(t))) {
                                            i && B.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);
                                            var s = $.update(t),
                                                l = t.material;
                                            if (Array.isArray(l))
                                                for (var u = s.groups, c = 0, f = u.length; c < f; c++) {
                                                    var p = u[c],
                                                        m = l[p.materialIndex];
                                                    m && m.visible && h.push(t, s, m, r, B.z, p)
                                                } else l.visible && h.push(t, s, l, r, B.z, null)
                                        }
                                    }
                                    for (var v = t.children, g = 0, y = v.length; g < y; g++) e(v[g], n, r, i)
                                }
                            }(e, t, 0, m.sortObjects), h.finish(), !0 === m.sortObjects && h.sort(A, R), !0 === O && ei.beginShadows();
                        var n = d.state.shadowsArray;
                        if (ea.render(n, e, t), !0 === O && ei.endShadows(), !0 === this.info.autoReset && this.info.reset(), eo.render(h, e), d.setupLights(m.physicallyCorrectLights), t.isArrayCamera)
                            for (var r = t.cameras, i = 0, a = r.length; i < a; i++) {
                                var o = r[i];
                                eS(h, e, o, o.viewport)
                            } else eS(h, e, t);
                        null !== _ && (Y.updateMultisampleRenderTarget(_), Y.updateRenderTargetMipmap(_)), !0 === e.isScene && e.onAfterRender(m, e, t), j.buffers.depth.setTest(!0), j.buffers.depth.setMask(!0), j.buffers.color.setMask(!0), j.setPolygonOffset(!1), eh.resetDefaultState(), x = -1, b = null, p.pop(), d = p.length > 0 ? p[p.length - 1] : null, f.pop(), h = f.length > 0 ? f[f.length - 1] : null
                    }
                }, this.getActiveCubeFace = function() {
                    return g
                }, this.getActiveMipmapLevel = function() {
                    return y
                }, this.getRenderTarget = function() {
                    return _
                }, this.setRenderTargetTextures = function(e, t, n) {
                    X.get(e.texture).__webglTexture = t, X.get(e.depthTexture).__webglTexture = n;
                    var r = X.get(e);
                    r.__hasExternalTextures = !0, r.__hasExternalTextures && (r.__autoAllocateDepthBuffer = void 0 === n, r.__autoAllocateDepthBuffer || e.useRenderToTexture && (console.warn("render-to-texture extension was disabled because an external texture was provided"), e.useRenderToTexture = !1, e.useRenderbuffer = !0))
                }, this.setRenderTargetFramebuffer = function(e, t) {
                    var n = X.get(e);
                    n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t
                }, this.setRenderTarget = function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                    _ = e, g = t, y = n;
                    var r = !0;
                    if (e) {
                        var i = X.get(e);
                        void 0 !== i.__useDefaultFramebuffer ? (j.bindFramebuffer(36160, null), r = !1) : void 0 === i.__webglFramebuffer ? Y.setupRenderTarget(e) : i.__hasExternalTextures && Y.rebindTextures(e, X.get(e.texture).__webglTexture, X.get(e.depthTexture).__webglTexture)
                    }
                    var a = null,
                        o = !1,
                        s = !1;
                    if (e) {
                        var l = e.texture;
                        (l.isDataTexture3D || l.isDataTexture2DArray) && (s = !0);
                        var u = X.get(e).__webglFramebuffer;
                        e.isWebGLCubeRenderTarget ? (a = u[t], o = !0) : a = e.useRenderbuffer ? X.get(e).__webglMultisampledFramebuffer : u, w.copy(e.viewport), M.copy(e.scissor), S = e.scissorTest
                    } else w.copy(C).multiplyScalar(k).floor(), M.copy(L).multiplyScalar(k).floor(), S = P;
                    if (j.bindFramebuffer(36160, a) && W.drawBuffers && r) {
                        var c = !1;
                        if (e) {
                            if (e.isWebGLMultipleRenderTargets) {
                                var h = e.texture;
                                if (I.length !== h.length || 36064 !== I[0]) {
                                    for (var d = 0, f = h.length; d < f; d++) I[d] = 36064 + d;
                                    I.length = h.length, c = !0
                                }
                            } else 1 === I.length && 36064 === I[0] || (I[0] = 36064, I.length = 1, c = !0)
                        } else 1 === I.length && 1029 === I[0] || (I[0] = 1029, I.length = 1, c = !0);
                        c && (W.isWebGL2 ? ed.drawBuffers(I) : G.get("WEBGL_draw_buffers").drawBuffersWEBGL(I))
                    }
                    if (j.viewport(w), j.scissor(M), j.setScissorTest(S), o) {
                        var p = X.get(e.texture);
                        ed.framebufferTexture2D(36160, 36064, 34069 + t, p.__webglTexture, n)
                    } else if (s) {
                        var m = X.get(e.texture);
                        ed.framebufferTextureLayer(36160, 36064, m.__webglTexture, n || 0, t || 0)
                    }
                    x = -1
                }, this.readRenderTargetPixels = function(e, t, n, r, i, a, o) {
                    if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    var s = X.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s) {
                        j.bindFramebuffer(36160, s);
                        try {
                            var l = e.texture,
                                u = l.format,
                                c = l.type;
                            if (1023 !== u && ec.convert(u) !== ed.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            var h = 1016 === c && (G.has("EXT_color_buffer_half_float") || W.isWebGL2 && G.has("EXT_color_buffer_float"));
                            if (!(1009 === c || ec.convert(c) === ed.getParameter(35738) || 1015 === c && (W.isWebGL2 || G.has("OES_texture_float") || G.has("WEBGL_color_buffer_float")) || h)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            36053 === ed.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && ed.readPixels(t, n, r, i, ec.convert(u), ec.convert(c), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            var d = null !== _ ? X.get(_).__webglFramebuffer : null;
                            j.bindFramebuffer(36160, d)
                        }
                    }
                }, this.copyFramebufferToTexture = function(e, t) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                    if (!0 !== t.isFramebufferTexture) return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
                    var r = Math.pow(2, -n),
                        i = Math.floor(t.image.width * r),
                        a = Math.floor(t.image.height * r);
                    Y.setTexture2D(t, 0), ed.copyTexSubImage2D(3553, n, 0, 0, e.x, e.y, i, a), j.unbindTexture()
                }, this.copyTextureToTexture = function(e, t, n) {
                    var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                        i = t.image.width,
                        a = t.image.height,
                        o = ec.convert(n.format),
                        s = ec.convert(n.type);
                    Y.setTexture2D(n, 0), ed.pixelStorei(37440, n.flipY), ed.pixelStorei(37441, n.premultiplyAlpha), ed.pixelStorei(3317, n.unpackAlignment), t.isDataTexture ? ed.texSubImage2D(3553, r, e.x, e.y, i, a, o, s, t.image.data) : t.isCompressedTexture ? ed.compressedTexSubImage2D(3553, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : ed.texSubImage2D(3553, r, e.x, e.y, o, s, t.image), 0 === r && n.generateMipmaps && ed.generateMipmap(3553), j.unbindTexture()
                }, this.copyTextureToTexture3D = function(e, t, n, r) {
                    var i, a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                    if (m.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    var o = e.max.x - e.min.x + 1,
                        s = e.max.y - e.min.y + 1,
                        l = e.max.z - e.min.z + 1,
                        u = ec.convert(r.format),
                        c = ec.convert(r.type);
                    if (r.isDataTexture3D) Y.setTexture3D(r, 0), i = 32879;
                    else {
                        if (!r.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        Y.setTexture2DArray(r, 0), i = 35866
                    }
                    ed.pixelStorei(37440, r.flipY), ed.pixelStorei(37441, r.premultiplyAlpha), ed.pixelStorei(3317, r.unpackAlignment);
                    var h = ed.getParameter(3314),
                        d = ed.getParameter(32878),
                        f = ed.getParameter(3316),
                        p = ed.getParameter(3315),
                        v = ed.getParameter(32877),
                        g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                    ed.pixelStorei(3314, g.width), ed.pixelStorei(32878, g.height), ed.pixelStorei(3316, e.min.x), ed.pixelStorei(3315, e.min.y), ed.pixelStorei(32877, e.min.z), n.isDataTexture || n.isDataTexture3D ? ed.texSubImage3D(i, a, t.x, t.y, t.z, o, s, l, u, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ed.compressedTexSubImage3D(i, a, t.x, t.y, t.z, o, s, l, u, g.data)) : ed.texSubImage3D(i, a, t.x, t.y, t.z, o, s, l, u, c, g), ed.pixelStorei(3314, h), ed.pixelStorei(32878, d), ed.pixelStorei(3316, f), ed.pixelStorei(3315, p), ed.pixelStorei(32877, v), 0 === a && r.generateMipmaps && ed.generateMipmap(i), j.unbindTexture()
                }, this.initTexture = function(e) {
                    Y.setTexture2D(e, 0), j.unbindTexture()
                }, this.resetState = function() {
                    g = 0, y = 0, _ = null, j.reset(), eh.reset()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            aR.prototype.isWebGLRenderer = !0,
                function(e) {
                    function t() {
                        return (0, k._)(this, t), (0, E._)(this, t, arguments)
                    }
                    return (0, P._)(t, e), t
                }(aR).prototype.isWebGL1Renderer = !0;
            var aC = function(e) {
                function t() {
                    var e;
                    return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "Scene", e.background = null, e.environment = null, e.fog = null, e.overrideMaterial = null, e.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: e
                    })), e
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e, n) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e, n), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
                    }
                }, {
                    key: "toJSON",
                    value: function(e) {
                        var n = L((0, C._)(t.prototype), "toJSON", this).call(this, e);
                        return null !== this.fog && (n.object.fog = this.fog.toJSON()), n
                    }
                }]), t
            }(t7);
            aC.prototype.isScene = !0;
            var aL = function() {
                function e(t, n) {
                    (0, k._)(this, e), this.array = t, this.stride = n, this.count = void 0 !== t ? t.length / n : 0, this.usage = 35044, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0, this.uuid = eZ()
                }
                return (0, A._)(e, [{
                    key: "onUploadCallback",
                    value: function() {}
                }, {
                    key: "needsUpdate",
                    set: function(e) {
                        !0 === e && this.version++
                    }
                }, {
                    key: "setUsage",
                    value: function(e) {
                        return this.usage = e, this
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
                    }
                }, {
                    key: "copyAt",
                    value: function(e, t, n) {
                        e *= this.stride, n *= t.stride;
                        for (var r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
                        return this
                    }
                }, {
                    key: "set",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return this.array.set(e, t), this
                    }
                }, {
                    key: "clone",
                    value: function(e) {
                        void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = eZ()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                        var t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                            n = new this.constructor(t, this.stride);
                        return n.setUsage(this.usage), n
                    }
                }, {
                    key: "onUpload",
                    value: function(e) {
                        return this.onUploadCallback = e, this
                    }
                }, {
                    key: "toJSON",
                    value: function(e) {
                        return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = eZ()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                            uuid: this.uuid,
                            buffer: this.array.buffer._uuid,
                            type: this.array.constructor.name,
                            stride: this.stride
                        }
                    }
                }]), e
            }();
            aL.prototype.isInterleavedBuffer = !0;
            var aP = new to,
                aI = function() {
                    function e(t, n, r) {
                        var i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                        (0, k._)(this, e), this.name = "", this.data = t, this.itemSize = n, this.offset = r, this.normalized = !0 === i
                    }
                    return (0, A._)(e, [{
                        key: "count",
                        get: function() {
                            return this.data.count
                        }
                    }, {
                        key: "array",
                        get: function() {
                            return this.data.array
                        }
                    }, {
                        key: "needsUpdate",
                        set: function(e) {
                            this.data.needsUpdate = e
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function(e) {
                            for (var t = 0, n = this.data.count; t < n; t++) aP.x = this.getX(t), aP.y = this.getY(t), aP.z = this.getZ(t), aP.applyMatrix4(e), this.setXYZ(t, aP.x, aP.y, aP.z);
                            return this
                        }
                    }, {
                        key: "applyNormalMatrix",
                        value: function(e) {
                            for (var t = 0, n = this.count; t < n; t++) aP.x = this.getX(t), aP.y = this.getY(t), aP.z = this.getZ(t), aP.applyNormalMatrix(e), this.setXYZ(t, aP.x, aP.y, aP.z);
                            return this
                        }
                    }, {
                        key: "transformDirection",
                        value: function(e) {
                            for (var t = 0, n = this.count; t < n; t++) aP.x = this.getX(t), aP.y = this.getY(t), aP.z = this.getZ(t), aP.transformDirection(e), this.setXYZ(t, aP.x, aP.y, aP.z);
                            return this
                        }
                    }, {
                        key: "setX",
                        value: function(e, t) {
                            return this.data.array[e * this.data.stride + this.offset] = t, this
                        }
                    }, {
                        key: "setY",
                        value: function(e, t) {
                            return this.data.array[e * this.data.stride + this.offset + 1] = t, this
                        }
                    }, {
                        key: "setZ",
                        value: function(e, t) {
                            return this.data.array[e * this.data.stride + this.offset + 2] = t, this
                        }
                    }, {
                        key: "setW",
                        value: function(e, t) {
                            return this.data.array[e * this.data.stride + this.offset + 3] = t, this
                        }
                    }, {
                        key: "getX",
                        value: function(e) {
                            return this.data.array[e * this.data.stride + this.offset]
                        }
                    }, {
                        key: "getY",
                        value: function(e) {
                            return this.data.array[e * this.data.stride + this.offset + 1]
                        }
                    }, {
                        key: "getZ",
                        value: function(e) {
                            return this.data.array[e * this.data.stride + this.offset + 2]
                        }
                    }, {
                        key: "getW",
                        value: function(e) {
                            return this.data.array[e * this.data.stride + this.offset + 3]
                        }
                    }, {
                        key: "setXY",
                        value: function(e, t, n) {
                            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
                        }
                    }, {
                        key: "setXYZ",
                        value: function(e, t, n, r) {
                            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this
                        }
                    }, {
                        key: "setXYZW",
                        value: function(e, t, n, r, i) {
                            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this
                        }
                    }, {
                        key: "clone",
                        value: function(t) {
                            if (void 0 === t) {
                                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                                for (var n = [], r = 0; r < this.count; r++)
                                    for (var i = r * this.data.stride + this.offset, a = 0; a < this.itemSize; a++) n.push(this.data.array[i + a]);
                                return new nw(new this.array.constructor(n), this.itemSize, this.normalized)
                            }
                            return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new e(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                        }
                    }, {
                        key: "toJSON",
                        value: function(e) {
                            if (void 0 === e) {
                                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                                for (var t = [], n = 0; n < this.count; n++)
                                    for (var r = n * this.data.stride + this.offset, i = 0; i < this.itemSize; i++) t.push(this.data.array[r + i]);
                                return {
                                    itemSize: this.itemSize,
                                    type: this.array.constructor.name,
                                    array: t,
                                    normalized: this.normalized
                                }
                            }
                            return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                                isInterleavedBufferAttribute: !0,
                                itemSize: this.itemSize,
                                data: this.data.uuid,
                                offset: this.offset,
                                normalized: this.normalized
                            }
                        }
                    }]), e
                }();
            aI.prototype.isInterleavedBufferAttribute = !0;
            var aD = function(e) {
                function t(e) {
                    var n;
                    return (0, k._)(this, t), (n = (0, E._)(this, t)).type = "SpriteMaterial", n.color = new ny(0xffffff), n.map = null, n.alphaMap = null, n.rotation = 0, n.sizeAttenuation = !0, n.transparent = !0, n.setValues(e), n
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
                    }
                }]), t
            }(nh);
            aD.prototype.isSpriteMaterial = !0;
            var aO = new to,
                aN = new to,
                aF = new to,
                aU = new e4,
                aB = new e4,
                az = new tF,
                aH = new to,
                aV = new to,
                aG = new to,
                aW = new e4,
                aj = new e4,
                aq = new e4;

            function aX(e, t, n, r, i, a) {
                aU.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (aB.x = a * aU.x - i * aU.y, aB.y = i * aU.x + a * aU.y) : aB.copy(aU), e.copy(t), e.x += aB.x, e.y += aB.y, e.applyMatrix4(az)
            }(function(e) {
                function t(e) {
                    if ((0, k._)(this, t), (n = (0, E._)(this, t)).type = "Sprite", void 0 === cT) {
                        cT = new nI;
                        var n, r = new aL(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                        cT.setIndex([0, 1, 2, 0, 2, 3]), cT.setAttribute("position", new aI(r, 3, 0, !1)), cT.setAttribute("uv", new aI(r, 2, 3, !1))
                    }
                    return n.geometry = cT, n.material = void 0 !== e ? e : new aD, n.center = new e4(.5, .5), n
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "raycast",
                    value: function(e, t) {
                        null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), aN.setFromMatrixScale(this.matrixWorld), az.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), aF.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && aN.multiplyScalar(-aF.z);
                        var n, r, i = this.material.rotation;
                        0 !== i && (r = Math.cos(i), n = Math.sin(i));
                        var a = this.center;
                        aX(aH.set(-.5, -.5, 0), aF, a, aN, n, r), aX(aV.set(.5, -.5, 0), aF, a, aN, n, r), aX(aG.set(.5, .5, 0), aF, a, aN, n, r), aW.set(0, 0), aj.set(1, 0), aq.set(1, 1);
                        var o = e.ray.intersectTriangle(aH, aV, aG, !1, aO);
                        if (null !== o || (aX(aV.set(-.5, .5, 0), aF, a, aN, n, r), aj.set(0, 1), null !== (o = e.ray.intersectTriangle(aH, aG, aV, !1, aO)))) {
                            var s = e.ray.origin.distanceTo(aO);
                            s < e.near || s > e.far || t.push({
                                distance: s,
                                point: aO.clone(),
                                uv: nu.getUV(aO, aH, aV, aG, aW, aj, aq, new e4),
                                face: null,
                                object: this
                            })
                        }
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this
                    }
                }]), t
            })(t7).prototype.isSprite = !0;
            var aY = new to,
                aJ = new tn,
                aZ = new tn,
                aK = new to,
                aQ = new tF,
                a$ = function(e) {
                    function t(e, n) {
                        var r;
                        return (0, k._)(this, t), (r = (0, E._)(this, t, [e, n])).type = "SkinnedMesh", r.bindMode = "attached", r.bindMatrix = new tF, r.bindMatrixInverse = new tF, r
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
                        }
                    }, {
                        key: "bind",
                        value: function(e, t) {
                            this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
                        }
                    }, {
                        key: "pose",
                        value: function() {
                            this.skeleton.pose()
                        }
                    }, {
                        key: "normalizeSkinWeights",
                        value: function() {
                            for (var e = new tn, t = this.geometry.attributes.skinWeight, n = 0, r = t.count; n < r; n++) {
                                e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n);
                                var i = 1 / e.manhattanLength();
                                i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                            }
                        }
                    }, {
                        key: "updateMatrixWorld",
                        value: function(e) {
                            L((0, C._)(t.prototype), "updateMatrixWorld", this).call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                        }
                    }, {
                        key: "boneTransform",
                        value: function(e, t) {
                            var n = this.skeleton,
                                r = this.geometry;
                            aJ.fromBufferAttribute(r.attributes.skinIndex, e), aZ.fromBufferAttribute(r.attributes.skinWeight, e), aY.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                            for (var i = 0; i < 4; i++) {
                                var a = aZ.getComponent(i);
                                if (0 !== a) {
                                    var o = aJ.getComponent(i);
                                    aQ.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), t.addScaledVector(aK.copy(aY).applyMatrix4(aQ), a)
                                }
                            }
                            return t.applyMatrix4(this.bindMatrixInverse)
                        }
                    }]), t
                }(nK);
            a$.prototype.isSkinnedMesh = !0;
            var a0 = function(e) {
                function t() {
                    var e;
                    return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "Bone", e
                }
                return (0, P._)(t, e), t
            }(t7);
            a0.prototype.isBone = !0;
            var a1 = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                        a = arguments.length > 3 ? arguments[3] : void 0,
                        o = arguments.length > 4 ? arguments[4] : void 0,
                        s = arguments.length > 5 ? arguments[5] : void 0,
                        l = arguments.length > 6 ? arguments[6] : void 0,
                        u = arguments.length > 7 ? arguments[7] : void 0,
                        c = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1003,
                        h = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 1003,
                        d = arguments.length > 10 ? arguments[10] : void 0,
                        f = arguments.length > 11 ? arguments[11] : void 0;
                    return (0, k._)(this, t), (e = (0, E._)(this, t, [null, s, l, u, c, h, a, o, d, f])).image = {
                        data: n,
                        width: r,
                        height: i
                    }, e.magFilter = c, e.minFilter = h, e.generateMipmaps = !1, e.flipY = !1, e.unpackAlignment = 1, e
                }
                return (0, P._)(t, e), t
            }(te);
            a1.prototype.isDataTexture = !0;
            var a2 = new tF,
                a3 = new tF,
                a4 = function() {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                        (0, k._)(this, e), this.uuid = eZ(), this.bones = t.slice(0), this.boneInverses = n, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
                    }
                    return (0, A._)(e, [{
                        key: "init",
                        value: function() {
                            var e = this.bones,
                                t = this.boneInverses;
                            if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
                            else if (e.length !== t.length) {
                                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                                for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new tF)
                            }
                        }
                    }, {
                        key: "calculateInverses",
                        value: function() {
                            this.boneInverses.length = 0;
                            for (var e = 0, t = this.bones.length; e < t; e++) {
                                var n = new tF;
                                this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n)
                            }
                        }
                    }, {
                        key: "pose",
                        value: function() {
                            for (var e = 0, t = this.bones.length; e < t; e++) {
                                var n = this.bones[e];
                                n && n.matrixWorld.copy(this.boneInverses[e]).invert()
                            }
                            for (var r = 0, i = this.bones.length; r < i; r++) {
                                var a = this.bones[r];
                                a && (a.parent && a.parent.isBone ? (a.matrix.copy(a.parent.matrixWorld).invert(), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale))
                            }
                        }
                    }, {
                        key: "update",
                        value: function() {
                            for (var e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture, i = 0, a = e.length; i < a; i++) {
                                var o = e[i] ? e[i].matrixWorld : a3;
                                a2.multiplyMatrices(o, t[i]), a2.toArray(n, 16 * i)
                            }
                            null !== r && (r.needsUpdate = !0)
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return new e(this.bones, this.boneInverses)
                        }
                    }, {
                        key: "computeBoneTexture",
                        value: function() {
                            var e = Math.sqrt(4 * this.bones.length),
                                t = new Float32Array((e = Math.max(e = e1(e), 4)) * e * 4);
                            t.set(this.boneMatrices);
                            var n = new a1(t, e, e, 1023, 1015);
                            return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this
                        }
                    }, {
                        key: "getBoneByName",
                        value: function(e) {
                            for (var t = 0, n = this.bones.length; t < n; t++) {
                                var r = this.bones[t];
                                if (r.name === e) return r
                            }
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                        }
                    }, {
                        key: "fromJSON",
                        value: function(e, t) {
                            this.uuid = e.uuid;
                            for (var n = 0, r = e.bones.length; n < r; n++) {
                                var i = e.bones[n],
                                    a = t[i];
                                void 0 === a && (console.warn("THREE.Skeleton: No bone found with UUID:", i), a = new a0), this.bones.push(a), this.boneInverses.push((new tF).fromArray(e.boneInverses[n]))
                            }
                            return this.init(), this
                        }
                    }, {
                        key: "toJSON",
                        value: function() {
                            var e = {
                                metadata: {
                                    version: 4.5,
                                    type: "Skeleton",
                                    generator: "Skeleton.toJSON"
                                },
                                bones: [],
                                boneInverses: []
                            };
                            e.uuid = this.uuid;
                            for (var t = this.bones, n = this.boneInverses, r = 0, i = t.length; r < i; r++) {
                                var a = t[r];
                                e.bones.push(a.uuid);
                                var o = n[r];
                                e.boneInverses.push(o.toArray())
                            }
                            return e
                        }
                    }]), e
                }(),
                a5 = function(e) {
                    function t(e, n, r) {
                        var i, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                        return (0, k._)(this, t), "number" == typeof r && (a = r, r = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), (i = (0, E._)(this, t, [e, n, r])).meshPerAttribute = a, i
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
                        }
                    }, {
                        key: "toJSON",
                        value: function() {
                            var e = L((0, C._)(t.prototype), "toJSON", this).call(this);
                            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
                        }
                    }]), t
                }(nw);
            a5.prototype.isInstancedBufferAttribute = !0;
            var a6 = new tF,
                a8 = new tF,
                a7 = [],
                a9 = new nK;
            (function(e) {
                function t(e, n, r) {
                    var i;
                    return (0, k._)(this, t), (i = (0, E._)(this, t, [e, n])).instanceMatrix = new a5(new Float32Array(16 * r), 16), i.instanceColor = null, i.count = r, i.frustumCulled = !1, i
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this
                    }
                }, {
                    key: "getColorAt",
                    value: function(e, t) {
                        t.fromArray(this.instanceColor.array, 3 * e)
                    }
                }, {
                    key: "getMatrixAt",
                    value: function(e, t) {
                        t.fromArray(this.instanceMatrix.array, 16 * e)
                    }
                }, {
                    key: "raycast",
                    value: function(e, t) {
                        var n = this.matrixWorld,
                            r = this.count;
                        if (a9.geometry = this.geometry, a9.material = this.material, void 0 !== a9.material)
                            for (var i = 0; i < r; i++) {
                                this.getMatrixAt(i, a6), a8.multiplyMatrices(n, a6), a9.matrixWorld = a8, a9.raycast(e, a7);
                                for (var a = 0, o = a7.length; a < o; a++) {
                                    var s = a7[a];
                                    s.instanceId = i, s.object = this, t.push(s)
                                }
                                a7.length = 0
                            }
                    }
                }, {
                    key: "setColorAt",
                    value: function(e, t) {
                        null === this.instanceColor && (this.instanceColor = new a5(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e)
                    }
                }, {
                    key: "setMatrixAt",
                    value: function(e, t) {
                        t.toArray(this.instanceMatrix.array, 16 * e)
                    }
                }, {
                    key: "updateMorphTargets",
                    value: function() {}
                }, {
                    key: "dispose",
                    value: function() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }]), t
            })(nK).prototype.isInstancedMesh = !0;
            var oe = function(e) {
                function t(e) {
                    var n;
                    return (0, k._)(this, t), (n = (0, E._)(this, t)).type = "LineBasicMaterial", n.color = new ny(0xffffff), n.linewidth = 1, n.linecap = "round", n.linejoin = "round", n.setValues(e), n
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
                    }
                }]), t
            }(nh);
            oe.prototype.isLineBasicMaterial = !0;
            var ot = new to,
                on = new to,
                or = new tF,
                oi = new tN,
                oa = new tA,
                oo = function(e) {
                    function t() {
                        var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new nI,
                            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new oe;
                        return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "Line", e.geometry = n, e.material = r, e.updateMorphTargets(), e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.material = e.material, this.geometry = e.geometry, this
                        }
                    }, {
                        key: "computeLineDistances",
                        value: function() {
                            var e = this.geometry;
                            if (e.isBufferGeometry) {
                                if (null === e.index) {
                                    for (var t = e.attributes.position, n = [0], r = 1, i = t.count; r < i; r++) ot.fromBufferAttribute(t, r - 1), on.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += ot.distanceTo(on);
                                    e.setAttribute("lineDistance", new nT(n, 1))
                                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.")
                            } else e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                            return this
                        }
                    }, {
                        key: "raycast",
                        value: function(e, t) {
                            var n = this.geometry,
                                r = this.matrixWorld,
                                i = e.params.Line.threshold,
                                a = n.drawRange;
                            if (null === n.boundingSphere && n.computeBoundingSphere(), oa.copy(n.boundingSphere), oa.applyMatrix4(r), oa.radius += i, !1 !== e.ray.intersectsSphere(oa)) {
                                or.copy(r).invert(), oi.copy(e.ray).applyMatrix4(or);
                                var o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                    s = o * o,
                                    l = new to,
                                    u = new to,
                                    c = new to,
                                    h = new to,
                                    d = this.isLineSegments ? 2 : 1;
                                if (n.isBufferGeometry) {
                                    var f = n.index,
                                        p = n.attributes.position;
                                    if (null !== f)
                                        for (var m = Math.max(0, a.start), v = Math.min(f.count, a.start + a.count) - 1; m < v; m += d) {
                                            var g = f.getX(m),
                                                y = f.getX(m + 1);
                                            if (l.fromBufferAttribute(p, g), u.fromBufferAttribute(p, y), !(oi.distanceSqToSegment(l, u, h, c) > s)) {
                                                h.applyMatrix4(this.matrixWorld);
                                                var _ = e.ray.origin.distanceTo(h);
                                                _ < e.near || _ > e.far || t.push({
                                                    distance: _,
                                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                                    index: m,
                                                    face: null,
                                                    faceIndex: null,
                                                    object: this
                                                })
                                            }
                                        } else
                                            for (var x = Math.max(0, a.start), b = Math.min(p.count, a.start + a.count) - 1; x < b; x += d)
                                                if (l.fromBufferAttribute(p, x), u.fromBufferAttribute(p, x + 1), !(oi.distanceSqToSegment(l, u, h, c) > s)) {
                                                    h.applyMatrix4(this.matrixWorld);
                                                    var w = e.ray.origin.distanceTo(h);
                                                    w < e.near || w > e.far || t.push({
                                                        distance: w,
                                                        point: c.clone().applyMatrix4(this.matrixWorld),
                                                        index: x,
                                                        face: null,
                                                        faceIndex: null,
                                                        object: this
                                                    })
                                                }
                                } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                            }
                        }
                    }, {
                        key: "updateMorphTargets",
                        value: function() {
                            var e = this.geometry;
                            if (e.isBufferGeometry) {
                                var t = e.morphAttributes,
                                    n = Object.keys(t);
                                if (n.length > 0) {
                                    var r = t[n[0]];
                                    if (void 0 !== r) {
                                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                        for (var i = 0, a = r.length; i < a; i++) {
                                            var o = r[i].name || String(i);
                                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = i
                                        }
                                    }
                                }
                            } else {
                                var s = e.morphTargets;
                                void 0 !== s && s.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                            }
                        }
                    }]), t
                }(t7);
            oo.prototype.isLine = !0;
            var os = new to,
                ol = new to,
                ou = function(e) {
                    function t(e, n) {
                        var r;
                        return (0, k._)(this, t), (r = (0, E._)(this, t, [e, n])).type = "LineSegments", r
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "computeLineDistances",
                        value: function() {
                            var e = this.geometry;
                            if (e.isBufferGeometry) {
                                if (null === e.index) {
                                    for (var t = e.attributes.position, n = [], r = 0, i = t.count; r < i; r += 2) os.fromBufferAttribute(t, r), ol.fromBufferAttribute(t, r + 1), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + os.distanceTo(ol);
                                    e.setAttribute("lineDistance", new nT(n, 1))
                                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.")
                            } else e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                            return this
                        }
                    }]), t
                }(oo);
            ou.prototype.isLineSegments = !0;
            var oc = function(e) {
                function t(e, n) {
                    var r;
                    return (0, k._)(this, t), (r = (0, E._)(this, t, [e, n])).type = "LineLoop", r
                }
                return (0, P._)(t, e), t
            }(oo);
            oc.prototype.isLineLoop = !0;
            var oh = function(e) {
                function t(e) {
                    var n;
                    return (0, k._)(this, t), (n = (0, E._)(this, t)).type = "PointsMaterial", n.color = new ny(0xffffff), n.map = null, n.alphaMap = null, n.size = 1, n.sizeAttenuation = !0, n.setValues(e), n
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this
                    }
                }]), t
            }(nh);
            oh.prototype.isPointsMaterial = !0;
            var od = new tF,
                of = new tN,
                op = new tA,
                om = new to,
                ov = function(e) {
                    function t() {
                        var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new nI,
                            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new oh;
                        return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "Points", e.geometry = n, e.material = r, e.updateMorphTargets(), e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.material = e.material, this.geometry = e.geometry, this
                        }
                    }, {
                        key: "raycast",
                        value: function(e, t) {
                            var n = this.geometry,
                                r = this.matrixWorld,
                                i = e.params.Points.threshold,
                                a = n.drawRange;
                            if (null === n.boundingSphere && n.computeBoundingSphere(), op.copy(n.boundingSphere), op.applyMatrix4(r), op.radius += i, !1 !== e.ray.intersectsSphere(op)) {
                                od.copy(r).invert(), of .copy(e.ray).applyMatrix4(od);
                                var o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                    s = o * o;
                                if (n.isBufferGeometry) {
                                    var l = n.index,
                                        u = n.attributes.position;
                                    if (null !== l)
                                        for (var c = Math.max(0, a.start), h = Math.min(l.count, a.start + a.count); c < h; c++) {
                                            var d = l.getX(c);
                                            om.fromBufferAttribute(u, d), og(om, d, s, r, e, t, this)
                                        } else
                                            for (var f = Math.max(0, a.start), p = Math.min(u.count, a.start + a.count); f < p; f++) om.fromBufferAttribute(u, f), og(om, f, s, r, e, t, this)
                                } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                            }
                        }
                    }, {
                        key: "updateMorphTargets",
                        value: function() {
                            var e = this.geometry;
                            if (e.isBufferGeometry) {
                                var t = e.morphAttributes,
                                    n = Object.keys(t);
                                if (n.length > 0) {
                                    var r = t[n[0]];
                                    if (void 0 !== r) {
                                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                        for (var i = 0, a = r.length; i < a; i++) {
                                            var o = r[i].name || String(i);
                                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = i
                                        }
                                    }
                                }
                            } else {
                                var s = e.morphTargets;
                                void 0 !== s && s.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                            }
                        }
                    }]), t
                }(t7);

            function og(e, t, n, r, i, a, o) {
                var s = of .distanceSqToPoint(e);
                if (s < n) {
                    var l = new to; of .closestPointToPoint(e, l), l.applyMatrix4(r);
                    var u = i.ray.origin.distanceTo(l);
                    if (u < i.near || u > i.far) return;
                    a.push({
                        distance: u,
                        distanceToRay: Math.sqrt(s),
                        point: l,
                        index: t,
                        face: null,
                        object: o
                    })
                }
            }
            ov.prototype.isPoints = !0,
                function(e) {
                    function t(e, n, r, i, a, o, s, l, u) {
                        var c;
                        return (0, k._)(this, t), (c = (0, E._)(this, t, [e, n, r, i, a, o, s, l, u])).format = void 0 !== s ? s : 1022, c.minFilter = void 0 !== o ? o : 1006, c.magFilter = void 0 !== a ? a : 1006, c.generateMipmaps = !1, "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function t() {
                            c.needsUpdate = !0, e.requestVideoFrameCallback(t)
                        }), c
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "clone",
                        value: function() {
                            return new this.constructor(this.image).copy(this)
                        }
                    }, {
                        key: "update",
                        value: function() {
                            var e = this.image;
                            !1 == "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                        }
                    }]), t
                }(te).prototype.isVideoTexture = !0,
                function(e) {
                    function t(e, n, r) {
                        var i;
                        return (0, k._)(this, t), (i = (0, E._)(this, t, [{
                            width: e,
                            height: n
                        }])).format = r, i.magFilter = 1003, i.minFilter = 1003, i.generateMipmaps = !1, i.needsUpdate = !0, i
                    }
                    return (0, P._)(t, e), t
                }(te).prototype.isFramebufferTexture = !0;
            var oy = function(e) {
                function t(e, n, r, i, a, o, s, l, u, c, h, d) {
                    var f;
                    return (0, k._)(this, t), (f = (0, E._)(this, t, [null, o, s, l, u, c, i, a, h, d])).image = {
                        width: n,
                        height: r
                    }, f.mipmaps = e, f.flipY = !1, f.generateMipmaps = !1, f
                }
                return (0, P._)(t, e), t
            }(te);
            oy.prototype.isCompressedTexture = !0,
                function(e) {
                    function t(e, n, r, i, a, o, s, l, u) {
                        var c;
                        return (0, k._)(this, t), (c = (0, E._)(this, t, [e, n, r, i, a, o, s, l, u])).needsUpdate = !0, c
                    }
                    return (0, P._)(t, e), t
                }(te).prototype.isCanvasTexture = !0, new to, new to, new to, new nu;
            var o_ = function() {
                    function e() {
                        (0, k._)(this, e), this.type = "Curve", this.arcLengthDivisions = 200
                    }
                    return (0, A._)(e, [{
                        key: "getPoint",
                        value: function() {
                            return console.warn("THREE.Curve: .getPoint() not implemented."), null
                        }
                    }, {
                        key: "getPointAt",
                        value: function(e, t) {
                            var n = this.getUtoTmapping(e);
                            return this.getPoint(n, t)
                        }
                    }, {
                        key: "getPoints",
                        value: function() {
                            for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5, t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                            return t
                        }
                    }, {
                        key: "getSpacedPoints",
                        value: function() {
                            for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5, t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                            return t
                        }
                    }, {
                        key: "getLength",
                        value: function() {
                            var e = this.getLengths();
                            return e[e.length - 1]
                        }
                    }, {
                        key: "getLengths",
                        value: function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.arcLengthDivisions;
                            if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                            this.needsUpdate = !1;
                            var t, n = [],
                                r = this.getPoint(0),
                                i = 0;
                            n.push(0);
                            for (var a = 1; a <= e; a++) n.push(i += (t = this.getPoint(a / e)).distanceTo(r)), r = t;
                            return this.cacheArcLengths = n, n
                        }
                    }, {
                        key: "updateArcLengths",
                        value: function() {
                            this.needsUpdate = !0, this.getLengths()
                        }
                    }, {
                        key: "getUtoTmapping",
                        value: function(e, t) {
                            var n = this.getLengths(),
                                r = 0,
                                i = n.length;
                            a = t || e * n[i - 1];
                            for (var a, o, s = 0, l = i - 1; s <= l;)
                                if ((o = n[r = Math.floor(s + (l - s) / 2)] - a) < 0) s = r + 1;
                                else {
                                    if (!(o > 0)) {
                                        l = r;
                                        break
                                    }
                                    l = r - 1
                                }
                            if (n[r = l] === a) return r / (i - 1);
                            var u = n[r];
                            return (r + (a - u) / (n[r + 1] - u)) / (i - 1)
                        }
                    }, {
                        key: "getTangent",
                        value: function(e, t) {
                            var n = e - 1e-4,
                                r = e + 1e-4;
                            n < 0 && (n = 0), r > 1 && (r = 1);
                            var i = this.getPoint(n),
                                a = this.getPoint(r),
                                o = t || (i.isVector2 ? new e4 : new to);
                            return o.copy(a).sub(i).normalize(), o
                        }
                    }, {
                        key: "getTangentAt",
                        value: function(e, t) {
                            var n = this.getUtoTmapping(e);
                            return this.getTangent(n, t)
                        }
                    }, {
                        key: "computeFrenetFrames",
                        value: function(e, t) {
                            for (var n = new to, r = [], i = [], a = [], o = new to, s = new tF, l = 0; l <= e; l++) {
                                var u = l / e;
                                r[l] = this.getTangentAt(u, new to)
                            }
                            i[0] = new to, a[0] = new to;
                            var c = Number.MAX_VALUE,
                                h = Math.abs(r[0].x),
                                d = Math.abs(r[0].y),
                                f = Math.abs(r[0].z);
                            h <= c && (c = h, n.set(1, 0, 0)), d <= c && (c = d, n.set(0, 1, 0)), f <= c && n.set(0, 0, 1), o.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], o), a[0].crossVectors(r[0], i[0]);
                            for (var p = 1; p <= e; p++) {
                                if (i[p] = i[p - 1].clone(), a[p] = a[p - 1].clone(), o.crossVectors(r[p - 1], r[p]), o.length() > Number.EPSILON) {
                                    o.normalize();
                                    var m = Math.acos(eK(r[p - 1].dot(r[p]), -1, 1));
                                    i[p].applyMatrix4(s.makeRotationAxis(o, m))
                                }
                                a[p].crossVectors(r[p], i[p])
                            }
                            if (!0 === t) {
                                var v = Math.acos(eK(i[0].dot(i[e]), -1, 1));
                                v /= e, r[0].dot(o.crossVectors(i[0], i[e])) > 0 && (v = -v);
                                for (var g = 1; g <= e; g++) i[g].applyMatrix4(s.makeRotationAxis(r[g], v * g)), a[g].crossVectors(r[g], i[g])
                            }
                            return {
                                tangents: r,
                                normals: i,
                                binormals: a
                            }
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return (new this.constructor).copy(this)
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return this.arcLengthDivisions = e.arcLengthDivisions, this
                        }
                    }, {
                        key: "toJSON",
                        value: function() {
                            var e = {
                                metadata: {
                                    version: 4.5,
                                    type: "Curve",
                                    generator: "Curve.toJSON"
                                }
                            };
                            return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
                        }
                    }, {
                        key: "fromJSON",
                        value: function(e) {
                            return this.arcLengthDivisions = e.arcLengthDivisions, this
                        }
                    }]), e
                }(),
                ox = function(e) {
                    function t() {
                        var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                            o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                            s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2 * Math.PI,
                            l = arguments.length > 6 && void 0 !== arguments[6] && arguments[6],
                            u = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0;
                        return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "EllipseCurve", e.aX = n, e.aY = r, e.xRadius = i, e.yRadius = a, e.aStartAngle = o, e.aEndAngle = s, e.aClockwise = l, e.aRotation = u, e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "getPoint",
                        value: function(e, t) {
                            for (var n = t || new e4, r = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, a = Math.abs(i) < Number.EPSILON; i < 0;) i += r;
                            for (; i > r;) i -= r;
                            i < Number.EPSILON && (i = a ? 0 : r), !0 !== this.aClockwise || a || (i === r ? i = -r : i -= r);
                            var o = this.aStartAngle + e * i,
                                s = this.aX + this.xRadius * Math.cos(o),
                                l = this.aY + this.yRadius * Math.sin(o);
                            if (0 !== this.aRotation) {
                                var u = Math.cos(this.aRotation),
                                    c = Math.sin(this.aRotation),
                                    h = s - this.aX,
                                    d = l - this.aY;
                                s = h * u - d * c + this.aX, l = h * c + d * u + this.aY
                            }
                            return n.set(s, l)
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                        }
                    }, {
                        key: "toJSON",
                        value: function() {
                            var e = L((0, C._)(t.prototype), "toJSON", this).call(this);
                            return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
                        }
                    }, {
                        key: "fromJSON",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "fromJSON", this).call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                        }
                    }]), t
                }(o_);
            ox.prototype.isEllipseCurve = !0;
            var ob = function(e) {
                function t(e, n, r, i, a, o) {
                    var s;
                    return (0, k._)(this, t), (s = (0, E._)(this, t, [e, n, r, r, i, a, o])).type = "ArcCurve", s
                }
                return (0, P._)(t, e), t
            }(ox);

            function ow() {
                var e = 0,
                    t = 0,
                    n = 0,
                    r = 0;

                function i(i, a, o, s) {
                    e = i, t = o, n = -3 * i + 3 * a - 2 * o - s, r = 2 * i - 2 * a + o + s
                }
                return {
                    initCatmullRom: function(e, t, n, r, a) {
                        i(t, n, a * (n - e), a * (r - t))
                    },
                    initNonuniformCatmullRom: function(e, t, n, r, a, o, s) {
                        var l = (t - e) / a - (n - e) / (a + o) + (n - t) / o,
                            u = (n - t) / o - (r - t) / (o + s) + (r - n) / s;
                        i(t, n, l *= o, u *= o)
                    },
                    calc: function(i) {
                        var a = i * i;
                        return e + t * i + n * a + a * i * r
                    }
                }
            }
            ob.prototype.isArcCurve = !0;
            var oM = new to,
                oS = new ow,
                oT = new ow,
                oE = new ow,
                ok = function(e) {
                    function t() {
                        var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "centripetal",
                            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;
                        return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "CatmullRomCurve3", e.points = n, e.closed = r, e.curveType = i, e.tension = a, e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "getPoint",
                        value: function(e) {
                            var t, n, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new to,
                                i = this.points,
                                a = i.length,
                                o = (a - (this.closed ? 0 : 1)) * e,
                                s = Math.floor(o),
                                l = o - s;
                            this.closed ? s += s > 0 ? 0 : (Math.floor(Math.abs(s) / a) + 1) * a : 0 === l && s === a - 1 && (s = a - 2, l = 1), this.closed || s > 0 ? t = i[(s - 1) % a] : (oM.subVectors(i[0], i[1]).add(i[0]), t = oM);
                            var u = i[s % a],
                                c = i[(s + 1) % a];
                            if (this.closed || s + 2 < a ? n = i[(s + 2) % a] : (oM.subVectors(i[a - 1], i[a - 2]).add(i[a - 1]), n = oM), "centripetal" === this.curveType || "chordal" === this.curveType) {
                                var h = "chordal" === this.curveType ? .5 : .25,
                                    d = Math.pow(t.distanceToSquared(u), h),
                                    f = Math.pow(u.distanceToSquared(c), h),
                                    p = Math.pow(c.distanceToSquared(n), h);
                                f < 1e-4 && (f = 1), d < 1e-4 && (d = f), p < 1e-4 && (p = f), oS.initNonuniformCatmullRom(t.x, u.x, c.x, n.x, d, f, p), oT.initNonuniformCatmullRom(t.y, u.y, c.y, n.y, d, f, p), oE.initNonuniformCatmullRom(t.z, u.z, c.z, n.z, d, f, p)
                            } else "catmullrom" === this.curveType && (oS.initCatmullRom(t.x, u.x, c.x, n.x, this.tension), oT.initCatmullRom(t.y, u.y, c.y, n.y, this.tension), oE.initCatmullRom(t.z, u.z, c.z, n.z, this.tension));
                            return r.set(oS.calc(l), oT.calc(l), oE.calc(l)), r
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            L((0, C._)(t.prototype), "copy", this).call(this, e), this.points = [];
                            for (var n = 0, r = e.points.length; n < r; n++) {
                                var i = e.points[n];
                                this.points.push(i.clone())
                            }
                            return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                        }
                    }, {
                        key: "toJSON",
                        value: function() {
                            var e = L((0, C._)(t.prototype), "toJSON", this).call(this);
                            e.points = [];
                            for (var n = 0, r = this.points.length; n < r; n++) {
                                var i = this.points[n];
                                e.points.push(i.toArray())
                            }
                            return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
                        }
                    }, {
                        key: "fromJSON",
                        value: function(e) {
                            L((0, C._)(t.prototype), "fromJSON", this).call(this, e), this.points = [];
                            for (var n = 0, r = e.points.length; n < r; n++) {
                                var i = e.points[n];
                                this.points.push((new to).fromArray(i))
                            }
                            return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                        }
                    }]), t
                }(o_);

            function oA(e, t, n, r, i) {
                var a = .5 * (r - t),
                    o = .5 * (i - n),
                    s = e * e;
                return e * s * (2 * n - 2 * r + a + o) + (-3 * n + 3 * r - 2 * a - o) * s + a * e + n
            }

            function oR(e, t, n, r) {
                var i;
                return (i = 1 - e) * i * t + 2 * (1 - e) * e * n + e * e * r
            }

            function oC(e, t, n, r, i) {
                var a, o;
                return (a = 1 - e) * a * a * t + 3 * (o = 1 - e) * o * e * n + 3 * (1 - e) * e * e * r + e * e * e * i
            }
            ok.prototype.isCatmullRomCurve3 = !0;
            var oL = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new e4,
                        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new e4,
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new e4,
                        a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new e4;
                    return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "CubicBezierCurve", e.v0 = n, e.v1 = r, e.v2 = i, e.v3 = a, e
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "getPoint",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new e4,
                            n = this.v0,
                            r = this.v1,
                            i = this.v2,
                            a = this.v3;
                        return t.set(oC(e, n.x, r.x, i.x, a.x), oC(e, n.y, r.y, i.y, a.y)), t
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                    }
                }, {
                    key: "toJSON",
                    value: function() {
                        var e = L((0, C._)(t.prototype), "toJSON", this).call(this);
                        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                    }
                }, {
                    key: "fromJSON",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "fromJSON", this).call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                    }
                }]), t
            }(o_);
            oL.prototype.isCubicBezierCurve = !0;
            var oP = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new to,
                        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new to,
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new to,
                        a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new to;
                    return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "CubicBezierCurve3", e.v0 = n, e.v1 = r, e.v2 = i, e.v3 = a, e
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "getPoint",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new to,
                            n = this.v0,
                            r = this.v1,
                            i = this.v2,
                            a = this.v3;
                        return t.set(oC(e, n.x, r.x, i.x, a.x), oC(e, n.y, r.y, i.y, a.y), oC(e, n.z, r.z, i.z, a.z)), t
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                    }
                }, {
                    key: "toJSON",
                    value: function() {
                        var e = L((0, C._)(t.prototype), "toJSON", this).call(this);
                        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                    }
                }, {
                    key: "fromJSON",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "fromJSON", this).call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                    }
                }]), t
            }(o_);
            oP.prototype.isCubicBezierCurve3 = !0;
            var oI = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new e4,
                        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new e4;
                    return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "LineCurve", e.v1 = n, e.v2 = r, e
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "getPoint",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new e4;
                        return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
                    }
                }, {
                    key: "getPointAt",
                    value: function(e, t) {
                        return this.getPoint(e, t)
                    }
                }, {
                    key: "getTangent",
                    value: function(e, t) {
                        var n = t || new e4;
                        return n.copy(this.v2).sub(this.v1).normalize(), n
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                    }
                }, {
                    key: "toJSON",
                    value: function() {
                        var e = L((0, C._)(t.prototype), "toJSON", this).call(this);
                        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                    }
                }, {
                    key: "fromJSON",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "fromJSON", this).call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                    }
                }]), t
            }(o_);
            oI.prototype.isLineCurve = !0;
            var oD = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new e4,
                        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new e4,
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new e4;
                    return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "QuadraticBezierCurve", e.v0 = n, e.v1 = r, e.v2 = i, e
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "getPoint",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new e4,
                            n = this.v0,
                            r = this.v1,
                            i = this.v2;
                        return t.set(oR(e, n.x, r.x, i.x), oR(e, n.y, r.y, i.y)), t
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                    }
                }, {
                    key: "toJSON",
                    value: function() {
                        var e = L((0, C._)(t.prototype), "toJSON", this).call(this);
                        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                    }
                }, {
                    key: "fromJSON",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "fromJSON", this).call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                    }
                }]), t
            }(o_);
            oD.prototype.isQuadraticBezierCurve = !0;
            var oO = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new to,
                        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new to,
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new to;
                    return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "QuadraticBezierCurve3", e.v0 = n, e.v1 = r, e.v2 = i, e
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "getPoint",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new to,
                            n = this.v0,
                            r = this.v1,
                            i = this.v2;
                        return t.set(oR(e, n.x, r.x, i.x), oR(e, n.y, r.y, i.y), oR(e, n.z, r.z, i.z)), t
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                    }
                }, {
                    key: "toJSON",
                    value: function() {
                        var e = L((0, C._)(t.prototype), "toJSON", this).call(this);
                        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                    }
                }, {
                    key: "fromJSON",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "fromJSON", this).call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                    }
                }]), t
            }(o_);
            oO.prototype.isQuadraticBezierCurve3 = !0;
            var oN = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                    return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "SplineCurve", e.points = n, e
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "getPoint",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new e4,
                            n = this.points,
                            r = (n.length - 1) * e,
                            i = Math.floor(r),
                            a = r - i,
                            o = n[0 === i ? i : i - 1],
                            s = n[i],
                            l = n[i > n.length - 2 ? n.length - 1 : i + 1],
                            u = n[i > n.length - 3 ? n.length - 1 : i + 2];
                        return t.set(oA(a, o.x, s.x, l.x, u.x), oA(a, o.y, s.y, l.y, u.y)), t
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        L((0, C._)(t.prototype), "copy", this).call(this, e), this.points = [];
                        for (var n = 0, r = e.points.length; n < r; n++) {
                            var i = e.points[n];
                            this.points.push(i.clone())
                        }
                        return this
                    }
                }, {
                    key: "toJSON",
                    value: function() {
                        var e = L((0, C._)(t.prototype), "toJSON", this).call(this);
                        e.points = [];
                        for (var n = 0, r = this.points.length; n < r; n++) {
                            var i = this.points[n];
                            e.points.push(i.toArray())
                        }
                        return e
                    }
                }, {
                    key: "fromJSON",
                    value: function(e) {
                        L((0, C._)(t.prototype), "fromJSON", this).call(this, e), this.points = [];
                        for (var n = 0, r = e.points.length; n < r; n++) {
                            var i = e.points[n];
                            this.points.push((new e4).fromArray(i))
                        }
                        return this
                    }
                }]), t
            }(o_);
            oN.prototype.isSplineCurve = !0;
            var oF = Object.freeze({
                    __proto__: null,
                    ArcCurve: ob,
                    CatmullRomCurve3: ok,
                    CubicBezierCurve: oL,
                    CubicBezierCurve3: oP,
                    EllipseCurve: ox,
                    LineCurve: oI,
                    LineCurve3: function(e) {
                        function t() {
                            var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new to,
                                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new to;
                            return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "LineCurve3", e.isLineCurve3 = !0, e.v1 = n, e.v2 = r, e
                        }
                        return (0, P._)(t, e), (0, A._)(t, [{
                            key: "getPoint",
                            value: function(e) {
                                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new to;
                                return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
                            }
                        }, {
                            key: "getPointAt",
                            value: function(e, t) {
                                return this.getPoint(e, t)
                            }
                        }, {
                            key: "copy",
                            value: function(e) {
                                return L((0, C._)(t.prototype), "copy", this).call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                            }
                        }, {
                            key: "toJSON",
                            value: function() {
                                var e = L((0, C._)(t.prototype), "toJSON", this).call(this);
                                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                            }
                        }, {
                            key: "fromJSON",
                            value: function(e) {
                                return L((0, C._)(t.prototype), "fromJSON", this).call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                            }
                        }]), t
                    }(o_),
                    QuadraticBezierCurve: oD,
                    QuadraticBezierCurve3: oO,
                    SplineCurve: oN
                }),
                oU = function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t)).type = "Path", n.currentPoint = new e4, e && n.setFromPoints(e), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "setFromPoints",
                        value: function(e) {
                            this.moveTo(e[0].x, e[0].y);
                            for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
                            return this
                        }
                    }, {
                        key: "moveTo",
                        value: function(e, t) {
                            return this.currentPoint.set(e, t), this
                        }
                    }, {
                        key: "lineTo",
                        value: function(e, t) {
                            var n = new oI(this.currentPoint.clone(), new e4(e, t));
                            return this.curves.push(n), this.currentPoint.set(e, t), this
                        }
                    }, {
                        key: "quadraticCurveTo",
                        value: function(e, t, n, r) {
                            var i = new oD(this.currentPoint.clone(), new e4(e, t), new e4(n, r));
                            return this.curves.push(i), this.currentPoint.set(n, r), this
                        }
                    }, {
                        key: "bezierCurveTo",
                        value: function(e, t, n, r, i, a) {
                            var o = new oL(this.currentPoint.clone(), new e4(e, t), new e4(n, r), new e4(i, a));
                            return this.curves.push(o), this.currentPoint.set(i, a), this
                        }
                    }, {
                        key: "splineThru",
                        value: function(e) {
                            var t = new oN([this.currentPoint.clone()].concat(e));
                            return this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this
                        }
                    }, {
                        key: "arc",
                        value: function(e, t, n, r, i, a) {
                            var o = this.currentPoint.x,
                                s = this.currentPoint.y;
                            return this.absarc(e + o, t + s, n, r, i, a), this
                        }
                    }, {
                        key: "absarc",
                        value: function(e, t, n, r, i, a) {
                            return this.absellipse(e, t, n, n, r, i, a), this
                        }
                    }, {
                        key: "ellipse",
                        value: function(e, t, n, r, i, a, o, s) {
                            var l = this.currentPoint.x,
                                u = this.currentPoint.y;
                            return this.absellipse(e + l, t + u, n, r, i, a, o, s), this
                        }
                    }, {
                        key: "absellipse",
                        value: function(e, t, n, r, i, a, o, s) {
                            var l = new ox(e, t, n, r, i, a, o, s);
                            if (this.curves.length > 0) {
                                var u = l.getPoint(0);
                                u.equals(this.currentPoint) || this.lineTo(u.x, u.y)
                            }
                            this.curves.push(l);
                            var c = l.getPoint(1);
                            return this.currentPoint.copy(c), this
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.currentPoint.copy(e.currentPoint), this
                        }
                    }, {
                        key: "toJSON",
                        value: function() {
                            var e = L((0, C._)(t.prototype), "toJSON", this).call(this);
                            return e.currentPoint = this.currentPoint.toArray(), e
                        }
                    }, {
                        key: "fromJSON",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "fromJSON", this).call(this, e), this.currentPoint.fromArray(e.currentPoint), this
                        }
                    }]), t
                }(function(e) {
                    function t() {
                        var e;
                        return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "CurvePath", e.curves = [], e.autoClose = !1, e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "add",
                        value: function(e) {
                            this.curves.push(e)
                        }
                    }, {
                        key: "closePath",
                        value: function() {
                            var e = this.curves[0].getPoint(0),
                                t = this.curves[this.curves.length - 1].getPoint(1);
                            e.equals(t) || this.curves.push(new oI(t, e))
                        }
                    }, {
                        key: "getPoint",
                        value: function(e, t) {
                            for (var n = e * this.getLength(), r = this.getCurveLengths(), i = 0; i < r.length;) {
                                if (r[i] >= n) {
                                    var a = r[i] - n,
                                        o = this.curves[i],
                                        s = o.getLength(),
                                        l = 0 === s ? 0 : 1 - a / s;
                                    return o.getPointAt(l, t)
                                }
                                i++
                            }
                            return null
                        }
                    }, {
                        key: "getLength",
                        value: function() {
                            var e = this.getCurveLengths();
                            return e[e.length - 1]
                        }
                    }, {
                        key: "updateArcLengths",
                        value: function() {
                            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                        }
                    }, {
                        key: "getCurveLengths",
                        value: function() {
                            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                            for (var e = [], t = 0, n = 0, r = this.curves.length; n < r; n++) e.push(t += this.curves[n].getLength());
                            return this.cacheLengths = e, e
                        }
                    }, {
                        key: "getSpacedPoints",
                        value: function() {
                            for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 40, t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                            return this.autoClose && t.push(t[0]), t
                        }
                    }, {
                        key: "getPoints",
                        value: function() {
                            for (var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 12, n = [], r = 0, i = this.curves; r < i.length; r++)
                                for (var a = i[r], o = a && a.isEllipseCurve ? 2 * t : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? t * a.points.length : t, s = a.getPoints(o), l = 0; l < s.length; l++) {
                                    var u = s[l];
                                    e && e.equals(u) || (n.push(u), e = u)
                                }
                            return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            L((0, C._)(t.prototype), "copy", this).call(this, e), this.curves = [];
                            for (var n = 0, r = e.curves.length; n < r; n++) {
                                var i = e.curves[n];
                                this.curves.push(i.clone())
                            }
                            return this.autoClose = e.autoClose, this
                        }
                    }, {
                        key: "toJSON",
                        value: function() {
                            var e = L((0, C._)(t.prototype), "toJSON", this).call(this);
                            e.autoClose = this.autoClose, e.curves = [];
                            for (var n = 0, r = this.curves.length; n < r; n++) {
                                var i = this.curves[n];
                                e.curves.push(i.toJSON())
                            }
                            return e
                        }
                    }, {
                        key: "fromJSON",
                        value: function(e) {
                            L((0, C._)(t.prototype), "fromJSON", this).call(this, e), this.autoClose = e.autoClose, this.curves = [];
                            for (var n = 0, r = e.curves.length; n < r; n++) {
                                var i = e.curves[n];
                                this.curves.push((new oF[i.type]).fromJSON(i))
                            }
                            return this
                        }
                    }]), t
                }(o_)),
                oB = function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t, [e])).uuid = eZ(), n.type = "Shape", n.holes = [], n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "getPointsHoles",
                        value: function(e) {
                            for (var t = [], n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);
                            return t
                        }
                    }, {
                        key: "extractPoints",
                        value: function(e) {
                            return {
                                shape: this.getPoints(e),
                                holes: this.getPointsHoles(e)
                            }
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            L((0, C._)(t.prototype), "copy", this).call(this, e), this.holes = [];
                            for (var n = 0, r = e.holes.length; n < r; n++) {
                                var i = e.holes[n];
                                this.holes.push(i.clone())
                            }
                            return this
                        }
                    }, {
                        key: "toJSON",
                        value: function() {
                            var e = L((0, C._)(t.prototype), "toJSON", this).call(this);
                            e.uuid = this.uuid, e.holes = [];
                            for (var n = 0, r = this.holes.length; n < r; n++) {
                                var i = this.holes[n];
                                e.holes.push(i.toJSON())
                            }
                            return e
                        }
                    }, {
                        key: "fromJSON",
                        value: function(e) {
                            L((0, C._)(t.prototype), "fromJSON", this).call(this, e), this.uuid = e.uuid, this.holes = [];
                            for (var n = 0, r = e.holes.length; n < r; n++) {
                                var i = e.holes[n];
                                this.holes.push((new oU).fromJSON(i))
                            }
                            return this
                        }
                    }]), t
                }(oU),
                oz = function(e, t) {
                    var n, r, i, a, o, s, l, u = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2,
                        c = t && t.length,
                        h = c ? t[0] * u : e.length,
                        d = oH(e, 0, h, u, !0),
                        f = [];
                    if (!d || d.next === d.prev) return f;
                    if (c && (d = function(e, t, n, r) {
                            var i, a, o, s, l, u = [];
                            for (i = 0, a = t.length; i < a; i++) o = t[i] * r, s = i < a - 1 ? t[i + 1] * r : e.length, (l = oH(e, o, s, r, !1)) === l.next && (l.steiner = !0), u.push(function(e) {
                                var t = e,
                                    n = e;
                                do(t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next; while (t !== e);
                                return n
                            }(l));
                            for (u.sort(oG), i = 0; i < u.length; i++)(function(e, t) {
                                if (t = function(e, t) {
                                        var n, r, i, a = t,
                                            o = e.x,
                                            s = e.y,
                                            l = -1 / 0;
                                        do {
                                            if (s <= a.y && s >= a.next.y && a.next.y !== a.y) {
                                                var u = a.x + (s - a.y) * (a.next.x - a.x) / (a.next.y - a.y);
                                                if (u <= o && u > l) {
                                                    if (l = u, u === o) {
                                                        if (s === a.y) return a;
                                                        if (s === a.next.y) return a.next
                                                    }
                                                    i = a.x < a.next.x ? a : a.next
                                                }
                                            }
                                            a = a.next
                                        } while (a !== t);
                                        if (!i) return null;
                                        if (o === l) return i;
                                        var c, h = i,
                                            d = i.x,
                                            f = i.y,
                                            p = 1 / 0;
                                        a = i;
                                        do o >= a.x && a.x >= d && o !== a.x && oj(s < f ? o : l, s, d, f, s < f ? l : o, s, a.x, a.y) && (c = Math.abs(s - a.y) / (o - a.x), oK(a, e) && (c < p || c === p && (a.x > i.x || a.x === i.x && (n = i, r = a, 0 > oq(n.prev, n, r.prev) && 0 > oq(r.next, n, n.next)))) && (i = a, p = c)), a = a.next; while (a !== h);
                                        return i
                                    }(e, t)) {
                                    var n = oQ(t, e);
                                    oV(t, t.next), oV(n, n.next)
                                }
                            })(u[i], n), n = oV(n, n.next);
                            return n
                        }(e, t, d, u)), e.length > 80 * u) {
                        n = i = e[0], r = a = e[1];
                        for (var p = u; p < h; p += u) o = e[p], s = e[p + 1], o < n && (n = o), s < r && (r = s), o > i && (i = o), s > a && (a = s);
                        l = 0 !== (l = Math.max(i - n, a - r)) ? 1 / l : 0
                    }
                    return function e(t, n, r, i, a, o, s) {
                        if (t) {
                            !s && o && function(e, t, n, r) {
                                var i = e;
                                do null === i.z && (i.z = oW(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== e);
                                i.prevZ.nextZ = null, i.prevZ = null,
                                    function(e) {
                                        var t, n, r, i, a, o, s, l, u = 1;
                                        do {
                                            for (n = e, e = null, a = null, o = 0; n;) {
                                                for (o++, r = n, s = 0, t = 0; t < u && (s++, r = r.nextZ); t++);
                                                for (l = u; s > 0 || l > 0 && r;) 0 !== s && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, l--), a ? a.nextZ = i : e = i, i.prevZ = a, a = i;
                                                n = r
                                            }
                                            a.nextZ = null, u *= 2
                                        } while (o > 1)
                                    }(i)
                            }(t, i, a, o);
                            for (var l, u, c = t; t.prev !== t.next;)
                                if (l = t.prev, u = t.next, o ? function(e, t, n, r) {
                                        var i = e.prev,
                                            a = e.next;
                                        if (oq(i, e, a) >= 0) return !1;
                                        for (var o = i.x < e.x ? i.x < a.x ? i.x : a.x : e.x < a.x ? e.x : a.x, s = i.y < e.y ? i.y < a.y ? i.y : a.y : e.y < a.y ? e.y : a.y, l = i.x > e.x ? i.x > a.x ? i.x : a.x : e.x > a.x ? e.x : a.x, u = i.y > e.y ? i.y > a.y ? i.y : a.y : e.y > a.y ? e.y : a.y, c = oW(o, s, t, n, r), h = oW(l, u, t, n, r), d = e.prevZ, f = e.nextZ; d && d.z >= c && f && f.z <= h;) {
                                            if (d !== e.prev && d !== e.next && oj(i.x, i.y, e.x, e.y, a.x, a.y, d.x, d.y) && oq(d.prev, d, d.next) >= 0 || (d = d.prevZ, f !== e.prev && f !== e.next && oj(i.x, i.y, e.x, e.y, a.x, a.y, f.x, f.y) && oq(f.prev, f, f.next) >= 0)) return !1;
                                            f = f.nextZ
                                        }
                                        for (; d && d.z >= c;) {
                                            if (d !== e.prev && d !== e.next && oj(i.x, i.y, e.x, e.y, a.x, a.y, d.x, d.y) && oq(d.prev, d, d.next) >= 0) return !1;
                                            d = d.prevZ
                                        }
                                        for (; f && f.z <= h;) {
                                            if (f !== e.prev && f !== e.next && oj(i.x, i.y, e.x, e.y, a.x, a.y, f.x, f.y) && oq(f.prev, f, f.next) >= 0) return !1;
                                            f = f.nextZ
                                        }
                                        return !0
                                    }(t, i, a, o) : function(e) {
                                        var t = e.prev,
                                            n = e.next;
                                        if (oq(t, e, n) >= 0) return !1;
                                        for (var r = e.next.next; r !== e.prev;) {
                                            if (oj(t.x, t.y, e.x, e.y, n.x, n.y, r.x, r.y) && oq(r.prev, r, r.next) >= 0) return !1;
                                            r = r.next
                                        }
                                        return !0
                                    }(t)) n.push(l.i / r), n.push(t.i / r), n.push(u.i / r), o0(t), t = u.next, c = u.next;
                                else if ((t = u) === c) {
                                s ? 1 === s ? e(t = function(e, t, n) {
                                    var r = e;
                                    do {
                                        var i = r.prev,
                                            a = r.next.next;
                                        !oX(i, a) && oY(i, r, r.next, a) && oK(i, a) && oK(a, i) && (t.push(i.i / n), t.push(r.i / n), t.push(a.i / n), o0(r), o0(r.next), r = e = a), r = r.next
                                    } while (r !== e);
                                    return oV(r)
                                }(oV(t), n, r), n, r, i, a, o, 2) : 2 === s && function(t, n, r, i, a, o) {
                                    var s = t;
                                    do {
                                        for (var l, u, c = s.next.next; c !== s.prev;) {
                                            if (s.i !== c.i && (l = s, u = c, l.next.i !== u.i && l.prev.i !== u.i && ! function(e, t) {
                                                    var n = e;
                                                    do {
                                                        if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && oY(n, n.next, e, t)) return !0;
                                                        n = n.next
                                                    } while (n !== e);
                                                    return !1
                                                }(l, u) && (oK(l, u) && oK(u, l) && function(e, t) {
                                                    var n = e,
                                                        r = !1,
                                                        i = (e.x + t.x) / 2,
                                                        a = (e.y + t.y) / 2;
                                                    do n.y > a != n.next.y > a && n.next.y !== n.y && i < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next; while (n !== e);
                                                    return r
                                                }(l, u) && (oq(l.prev, l, u.prev) || oq(l, u.prev, u)) || oX(l, u) && oq(l.prev, l, l.next) > 0 && oq(u.prev, u, u.next) > 0))) {
                                                var h = oQ(s, c);
                                                return s = oV(s, s.next), h = oV(h, h.next), e(s, n, r, i, a, o), void e(h, n, r, i, a, o)
                                            }
                                            c = c.next
                                        }
                                        s = s.next
                                    } while (s !== t)
                                }(t, n, r, i, a, o) : e(oV(t), n, r, i, a, o, 1);
                                break
                            }
                        }
                    }(d, f, u, n, r, l), f
                };

            function oH(e, t, n, r, i) {
                var a, o;
                if (i === function(e, t, n, r) {
                        for (var i = 0, a = t, o = n - r; a < n; a += r) i += (e[o] - e[a]) * (e[a + 1] + e[o + 1]), o = a;
                        return i
                    }(e, t, n, r) > 0)
                    for (a = t; a < n; a += r) o = o$(a, e[a], e[a + 1], o);
                else
                    for (a = n - r; a >= t; a -= r) o = o$(a, e[a], e[a + 1], o);
                return o && oX(o, o.next) && (o0(o), o = o.next), o
            }

            function oV(e, t) {
                if (!e) return e;
                t || (t = e);
                var n, r = e;
                do
                    if (n = !1, r.steiner || !oX(r, r.next) && 0 !== oq(r.prev, r, r.next)) r = r.next;
                    else {
                        if (o0(r), (r = t = r.prev) === r.next) break;
                        n = !0
                    }
                while (n || r !== t);
                return t
            }

            function oG(e, t) {
                return e.x - t.x
            }

            function oW(e, t, n, r, i) {
                return (e = 0x55555555 & ((e = 0x33333333 & ((e = 0xf0f0f0f & ((e = 0xff00ff & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 0x55555555 & ((t = 0x33333333 & ((t = 0xf0f0f0f & ((t = 0xff00ff & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
            }

            function oj(e, t, n, r, i, a, o, s) {
                return (i - o) * (t - s) - (e - o) * (a - s) >= 0 && (e - o) * (r - s) - (n - o) * (t - s) >= 0 && (n - o) * (a - s) - (i - o) * (r - s) >= 0
            }

            function oq(e, t, n) {
                return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
            }

            function oX(e, t) {
                return e.x === t.x && e.y === t.y
            }

            function oY(e, t, n, r) {
                var i = oZ(oq(e, t, n)),
                    a = oZ(oq(e, t, r)),
                    o = oZ(oq(n, r, e)),
                    s = oZ(oq(n, r, t));
                return i !== a && o !== s || !(0 !== i || !oJ(e, n, t)) || !(0 !== a || !oJ(e, r, t)) || !(0 !== o || !oJ(n, e, r)) || !(0 !== s || !oJ(n, t, r))
            }

            function oJ(e, t, n) {
                return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
            }

            function oZ(e) {
                return e > 0 ? 1 : e < 0 ? -1 : 0
            }

            function oK(e, t) {
                return 0 > oq(e.prev, e, e.next) ? oq(e, t, e.next) >= 0 && oq(e, e.prev, t) >= 0 : 0 > oq(e, t, e.prev) || 0 > oq(e, e.next, t)
            }

            function oQ(e, t) {
                var n = new o1(e.i, e.x, e.y),
                    r = new o1(t.i, t.x, t.y),
                    i = e.next,
                    a = t.prev;
                return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, a.next = r, r.prev = a, r
            }

            function o$(e, t, n, r) {
                var i = new o1(e, t, n);
                return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
            }

            function o0(e) {
                e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }

            function o1(e, t, n) {
                this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            var o2 = function() {
                function e() {
                    (0, k._)(this, e)
                }
                return (0, A._)(e, null, [{
                    key: "area",
                    value: function(e) {
                        for (var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
                        return .5 * n
                    }
                }, {
                    key: "isClockWise",
                    value: function(t) {
                        return 0 > e.area(t)
                    }
                }, {
                    key: "triangulateShape",
                    value: function(e, t) {
                        var n = [],
                            r = [],
                            i = [];
                        o3(e), o4(n, e);
                        var a = e.length;
                        t.forEach(o3);
                        for (var o = 0; o < t.length; o++) r.push(a), a += t[o].length, o4(n, t[o]);
                        for (var s = oz(n, r), l = 0; l < s.length; l += 3) i.push(s.slice(l, l + 3));
                        return i
                    }
                }]), e
            }();

            function o3(e) {
                var t = e.length;
                t > 2 && e[t - 1].equals(e[0]) && e.pop()
            }

            function o4(e, t) {
                for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
            }
            var o5 = function(e) {
                    function t() {
                        var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new oB([new e4(.5, .5), new e4(-.5, .5), new e4(-.5, -.5), new e4(.5, -.5)]),
                            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        (0, k._)(this, t), (e = (0, E._)(this, t)).type = "ExtrudeGeometry", e.parameters = {
                            shapes: n,
                            options: r
                        }, n = Array.isArray(n) ? n : [n];
                        for (var i = [], a = [], o = 0, s = n.length; o < s; o++) ! function(t) {
                            var n = [],
                                o = void 0 !== r.curveSegments ? r.curveSegments : 12,
                                s = void 0 !== r.steps ? r.steps : 1,
                                l = void 0 !== r.depth ? r.depth : 1,
                                u = void 0 === r.bevelEnabled || r.bevelEnabled,
                                c = void 0 !== r.bevelThickness ? r.bevelThickness : .2,
                                h = void 0 !== r.bevelSize ? r.bevelSize : c - .1,
                                d = void 0 !== r.bevelOffset ? r.bevelOffset : 0,
                                f = void 0 !== r.bevelSegments ? r.bevelSegments : 3,
                                p = r.extrudePath,
                                m = void 0 !== r.UVGenerator ? r.UVGenerator : o6;
                            void 0 !== r.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = r.amount);
                            var v, g, y, _, x, b = !1;
                            p && (v = p.getSpacedPoints(s), b = !0, u = !1, g = p.computeFrenetFrames(s, !1), y = new to, _ = new to, x = new to), u || (f = 0, c = 0, h = 0, d = 0);
                            var w = t.extractPoints(o),
                                M = w.shape,
                                S = w.holes;
                            if (!o2.isClockWise(M)) {
                                M = M.reverse();
                                for (var T = 0, E = S.length; T < E; T++) {
                                    var k = S[T];
                                    o2.isClockWise(k) && (S[T] = k.reverse())
                                }
                            }
                            for (var A = o2.triangulateShape(M, S), R = M, C = 0, L = S.length; C < L; C++) {
                                var P = S[C];
                                M = M.concat(P)
                            }

                            function I(e, t, n) {
                                return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
                            }
                            var D = M.length,
                                O = A.length;

                            function N(e, t, n) {
                                var r, i, a, o = e.x - t.x,
                                    s = e.y - t.y,
                                    l = n.x - e.x,
                                    u = n.y - e.y,
                                    c = o * o + s * s;
                                if (Math.abs(o * u - s * l) > Number.EPSILON) {
                                    var h = Math.sqrt(c),
                                        d = Math.sqrt(l * l + u * u),
                                        f = t.x - s / h,
                                        p = t.y + o / h,
                                        m = ((n.x - u / d - f) * u - (n.y + l / d - p) * l) / (o * u - s * l),
                                        v = (r = f + o * m - e.x) * r + (i = p + s * m - e.y) * i;
                                    if (v <= 2) return new e4(r, i);
                                    a = Math.sqrt(v / 2)
                                } else {
                                    var g = !1;
                                    o > Number.EPSILON ? l > Number.EPSILON && (g = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (g = !0) : Math.sign(s) === Math.sign(u) && (g = !0), g ? (r = -s, i = o, a = Math.sqrt(c)) : (r = o, i = s, a = Math.sqrt(c / 2))
                                }
                                return new e4(r / a, i / a)
                            }
                            for (var F = [], U = 0, B = R.length, z = B - 1, H = U + 1; U < B; U++, z++, H++) z === B && (z = 0), H === B && (H = 0), F[U] = N(R[U], R[z], R[H]);
                            for (var V, G = [], W = F.concat(), j = 0, q = S.length; j < q; j++) {
                                var X = S[j];
                                V = [];
                                for (var Y = 0, J = X.length, Z = J - 1, K = Y + 1; Y < J; Y++, Z++, K++) Z === J && (Z = 0), K === J && (K = 0), V[Y] = N(X[Y], X[Z], X[K]);
                                G.push(V), W = W.concat(V)
                            }
                            for (var Q = 0; Q < f; Q++) {
                                for (var $ = Q / f, ee = c * Math.cos($ * Math.PI / 2), et = h * Math.sin($ * Math.PI / 2) + d, en = 0, er = R.length; en < er; en++) {
                                    var ei = I(R[en], F[en], et);
                                    eL(ei.x, ei.y, -ee)
                                }
                                for (var ea = 0, eo = S.length; ea < eo; ea++) {
                                    var es = S[ea];
                                    V = G[ea];
                                    for (var el = 0, eu = es.length; el < eu; el++) {
                                        var ec = I(es[el], V[el], et);
                                        eL(ec.x, ec.y, -ee)
                                    }
                                }
                            }
                            for (var eh = h + d, ed = 0; ed < D; ed++) {
                                var ef = u ? I(M[ed], W[ed], eh) : M[ed];
                                b ? (_.copy(g.normals[0]).multiplyScalar(ef.x), y.copy(g.binormals[0]).multiplyScalar(ef.y), x.copy(v[0]).add(_).add(y), eL(x.x, x.y, x.z)) : eL(ef.x, ef.y, 0)
                            }
                            for (var ep = 1; ep <= s; ep++)
                                for (var em = 0; em < D; em++) {
                                    var ev = u ? I(M[em], W[em], eh) : M[em];
                                    b ? (_.copy(g.normals[ep]).multiplyScalar(ev.x), y.copy(g.binormals[ep]).multiplyScalar(ev.y), x.copy(v[ep]).add(_).add(y), eL(x.x, x.y, x.z)) : eL(ev.x, ev.y, l / s * ep)
                                }
                            for (var eg = f - 1; eg >= 0; eg--) {
                                for (var ey = eg / f, e_ = c * Math.cos(ey * Math.PI / 2), ex = h * Math.sin(ey * Math.PI / 2) + d, eb = 0, ew = R.length; eb < ew; eb++) {
                                    var eM = I(R[eb], F[eb], ex);
                                    eL(eM.x, eM.y, l + e_)
                                }
                                for (var eS = 0, eT = S.length; eS < eT; eS++) {
                                    var eE = S[eS];
                                    V = G[eS];
                                    for (var ek = 0, eA = eE.length; ek < eA; ek++) {
                                        var eR = I(eE[ek], V[ek], ex);
                                        b ? eL(eR.x, eR.y + v[s - 1].y, v[s - 1].x + e_) : eL(eR.x, eR.y, l + e_)
                                    }
                                }
                            }

                            function eC(t, n) {
                                for (var r = t.length; --r >= 0;) {
                                    var a = r,
                                        o = r - 1;
                                    o < 0 && (o = t.length - 1);
                                    for (var l = 0, u = s + 2 * f; l < u; l++) {
                                        var c = D * l,
                                            h = D * (l + 1);
                                        ! function(t, n, r, a) {
                                            eI(t), eI(n), eI(a), eI(n), eI(r), eI(a);
                                            var o = i.length / 3,
                                                s = m.generateSideWallUV(e, i, o - 6, o - 3, o - 2, o - 1);
                                            eD(s[0]), eD(s[1]), eD(s[3]), eD(s[1]), eD(s[2]), eD(s[3])
                                        }(n + a + c, n + o + c, n + o + h, n + a + h)
                                    }
                                }
                            }

                            function eL(e, t, r) {
                                n.push(e), n.push(t), n.push(r)
                            }

                            function eP(t, n, r) {
                                eI(t), eI(n), eI(r);
                                var a = i.length / 3,
                                    o = m.generateTopUV(e, i, a - 3, a - 2, a - 1);
                                eD(o[0]), eD(o[1]), eD(o[2])
                            }

                            function eI(e) {
                                i.push(n[3 * e + 0]), i.push(n[3 * e + 1]), i.push(n[3 * e + 2])
                            }

                            function eD(e) {
                                a.push(e.x), a.push(e.y)
                            }! function() {
                                var t = i.length / 3;
                                if (u) {
                                    for (var n = 0 * D, r = 0; r < O; r++) {
                                        var a = A[r];
                                        eP(a[2] + n, a[1] + n, a[0] + n)
                                    }
                                    n = D * (s + 2 * f);
                                    for (var o = 0; o < O; o++) {
                                        var l = A[o];
                                        eP(l[0] + n, l[1] + n, l[2] + n)
                                    }
                                } else {
                                    for (var c = 0; c < O; c++) {
                                        var h = A[c];
                                        eP(h[2], h[1], h[0])
                                    }
                                    for (var d = 0; d < O; d++) {
                                        var p = A[d];
                                        eP(p[0] + D * s, p[1] + D * s, p[2] + D * s)
                                    }
                                }
                                e.addGroup(t, i.length / 3 - t, 0)
                            }(),
                            function() {
                                var t = i.length / 3,
                                    n = 0;
                                eC(R, 0), n += R.length;
                                for (var r = 0, a = S.length; r < a; r++) {
                                    var o = S[r];
                                    eC(o, n), n += o.length
                                }
                                e.addGroup(t, i.length / 3 - t, 1)
                            }()
                        }(n[o]);
                        return e.setAttribute("position", new nT(i, 3)), e.setAttribute("uv", new nT(a, 2)), e.computeVertexNormals(), e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "toJSON",
                        value: function() {
                            var e = L((0, C._)(t.prototype), "toJSON", this).call(this);
                            return function(e, t, n) {
                                if (n.shapes = [], Array.isArray(e))
                                    for (var r = 0, i = e.length; r < i; r++) {
                                        var a = e[r];
                                        n.shapes.push(a.uuid)
                                    } else n.shapes.push(e.uuid);
                                return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n
                            }(this.parameters.shapes, this.parameters.options, e)
                        }
                    }], [{
                        key: "fromJSON",
                        value: function(e, n) {
                            for (var r = [], i = 0, a = e.shapes.length; i < a; i++) {
                                var o = n[e.shapes[i]];
                                r.push(o)
                            }
                            var s = e.options.extrudePath;
                            return void 0 !== s && (e.options.extrudePath = (new oF[s.type]).fromJSON(s)), new t(r, e.options)
                        }
                    }]), t
                }(nI),
                o6 = {
                    generateTopUV: function(e, t, n, r, i) {
                        var a = t[3 * n],
                            o = t[3 * n + 1],
                            s = t[3 * r],
                            l = t[3 * r + 1],
                            u = t[3 * i],
                            c = t[3 * i + 1];
                        return [new e4(a, o), new e4(s, l), new e4(u, c)]
                    },
                    generateSideWallUV: function(e, t, n, r, i, a) {
                        var o = t[3 * n],
                            s = t[3 * n + 1],
                            l = t[3 * n + 2],
                            u = t[3 * r],
                            c = t[3 * r + 1],
                            h = t[3 * r + 2],
                            d = t[3 * i],
                            f = t[3 * i + 1],
                            p = t[3 * i + 2],
                            m = t[3 * a],
                            v = t[3 * a + 1],
                            g = t[3 * a + 2];
                        return Math.abs(s - c) < Math.abs(o - u) ? [new e4(o, 1 - l), new e4(u, 1 - h), new e4(d, 1 - p), new e4(m, 1 - g)] : [new e4(s, 1 - l), new e4(c, 1 - h), new e4(f, 1 - p), new e4(v, 1 - g)]
                    }
                },
                o8 = function(e) {
                    function t() {
                        var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new oB([new e4(0, .5), new e4(-.5, -.5), new e4(.5, -.5)]),
                            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 12;
                        (0, k._)(this, t), (e = (0, E._)(this, t)).type = "ShapeGeometry", e.parameters = {
                            shapes: n,
                            curveSegments: r
                        };
                        var i = [],
                            a = [],
                            o = [],
                            s = [],
                            l = 0,
                            u = 0;
                        if (!1 === Array.isArray(n)) h(n);
                        else
                            for (var c = 0; c < n.length; c++) h(n[c]), e.addGroup(l, u, c), l += u, u = 0;

                        function h(e) {
                            var t = a.length / 3,
                                n = e.extractPoints(r),
                                l = n.shape,
                                c = n.holes;
                            !1 === o2.isClockWise(l) && (l = l.reverse());
                            for (var h = 0, d = c.length; h < d; h++) {
                                var f = c[h];
                                !0 === o2.isClockWise(f) && (c[h] = f.reverse())
                            }
                            for (var p = o2.triangulateShape(l, c), m = 0, v = c.length; m < v; m++) {
                                var g = c[m];
                                l = l.concat(g)
                            }
                            for (var y = 0, _ = l.length; y < _; y++) {
                                var x = l[y];
                                a.push(x.x, x.y, 0), o.push(0, 0, 1), s.push(x.x, x.y)
                            }
                            for (var b = 0, w = p.length; b < w; b++) {
                                var M = p[b],
                                    S = M[0] + t,
                                    T = M[1] + t,
                                    E = M[2] + t;
                                i.push(S, T, E), u += 3
                            }
                        }
                        return e.setIndex(i), e.setAttribute("position", new nT(a, 3)), e.setAttribute("normal", new nT(o, 3)), e.setAttribute("uv", new nT(s, 2)), e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "toJSON",
                        value: function() {
                            var e = L((0, C._)(t.prototype), "toJSON", this).call(this);
                            return function(e, t) {
                                if (t.shapes = [], Array.isArray(e))
                                    for (var n = 0, r = e.length; n < r; n++) {
                                        var i = e[n];
                                        t.shapes.push(i.uuid)
                                    } else t.shapes.push(e.uuid);
                                return t
                            }(this.parameters.shapes, e)
                        }
                    }], [{
                        key: "fromJSON",
                        value: function(e, n) {
                            for (var r = [], i = 0, a = e.shapes.length; i < a; i++) {
                                var o = n[e.shapes[i]];
                                r.push(o)
                            }
                            return new t(r, e.curveSegments)
                        }
                    }]), t
                }(nI),
                o7 = function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t)).type = "ShadowMaterial", n.color = new ny(0), n.transparent = !0, n.setValues(e), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.color.copy(e.color), this
                        }
                    }]), t
                }(nh);
            o7.prototype.isShadowMaterial = !0;
            var o9 = function(e) {
                function t(e) {
                    var n;
                    return (0, k._)(this, t), (n = (0, E._)(this, t)).defines = {
                        STANDARD: ""
                    }, n.type = "MeshStandardMaterial", n.color = new ny(0xffffff), n.roughness = 1, n.metalness = 0, n.map = null, n.lightMap = null, n.lightMapIntensity = 1, n.aoMap = null, n.aoMapIntensity = 1, n.emissive = new ny(0), n.emissiveIntensity = 1, n.emissiveMap = null, n.bumpMap = null, n.bumpScale = 1, n.normalMap = null, n.normalMapType = 0, n.normalScale = new e4(1, 1), n.displacementMap = null, n.displacementScale = 1, n.displacementBias = 0, n.roughnessMap = null, n.metalnessMap = null, n.alphaMap = null, n.envMap = null, n.envMapIntensity = 1, n.refractionRatio = .98, n.wireframe = !1, n.wireframeLinewidth = 1, n.wireframeLinecap = "round", n.wireframeLinejoin = "round", n.flatShading = !1, n.setValues(e), n
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.defines = {
                            STANDARD: ""
                        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this
                    }
                }]), t
            }(nh);
            o9.prototype.isMeshStandardMaterial = !0;
            var se = function(e) {
                function t(e) {
                    var n;
                    return (0, k._)(this, t), (n = (0, E._)(this, t)).defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, n.type = "MeshPhysicalMaterial", n.clearcoatMap = null, n.clearcoatRoughness = 0, n.clearcoatRoughnessMap = null, n.clearcoatNormalScale = new e4(1, 1), n.clearcoatNormalMap = null, n.ior = 1.5, Object.defineProperty(n, "reflectivity", {
                        get: function() {
                            return eK(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                        },
                        set: function(e) {
                            this.ior = (1 + .4 * e) / (1 - .4 * e)
                        }
                    }), n.sheenColor = new ny(0), n.sheenColorMap = null, n.sheenRoughness = 1, n.sheenRoughnessMap = null, n.transmissionMap = null, n.thickness = 0, n.thicknessMap = null, n.attenuationDistance = 0, n.attenuationColor = new ny(1, 1, 1), n.specularIntensity = 1, n.specularIntensityMap = null, n.specularColor = new ny(1, 1, 1), n.specularColorMap = null, n._sheen = 0, n._clearcoat = 0, n._transmission = 0, n.setValues(e), n
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "sheen",
                    get: function() {
                        return this._sheen
                    },
                    set: function(e) {
                        this._sheen > 0 != e > 0 && this.version++, this._sheen = e
                    }
                }, {
                    key: "clearcoat",
                    get: function() {
                        return this._clearcoat
                    },
                    set: function(e) {
                        this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
                    }
                }, {
                    key: "transmission",
                    get: function() {
                        return this._transmission
                    },
                    set: function(e) {
                        this._transmission > 0 != e > 0 && this.version++, this._transmission = e
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
                    }
                }]), t
            }(o9);
            se.prototype.isMeshPhysicalMaterial = !0,
                function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t)).type = "MeshPhongMaterial", n.color = new ny(0xffffff), n.specular = new ny(1118481), n.shininess = 30, n.map = null, n.lightMap = null, n.lightMapIntensity = 1, n.aoMap = null, n.aoMapIntensity = 1, n.emissive = new ny(0), n.emissiveIntensity = 1, n.emissiveMap = null, n.bumpMap = null, n.bumpScale = 1, n.normalMap = null, n.normalMapType = 0, n.normalScale = new e4(1, 1), n.displacementMap = null, n.displacementScale = 1, n.displacementBias = 0, n.specularMap = null, n.alphaMap = null, n.envMap = null, n.combine = 0, n.reflectivity = 1, n.refractionRatio = .98, n.wireframe = !1, n.wireframeLinewidth = 1, n.wireframeLinecap = "round", n.wireframeLinejoin = "round", n.flatShading = !1, n.setValues(e), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this
                        }
                    }]), t
                }(nh).prototype.isMeshPhongMaterial = !0,
                function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t)).defines = {
                            TOON: ""
                        }, n.type = "MeshToonMaterial", n.color = new ny(0xffffff), n.map = null, n.gradientMap = null, n.lightMap = null, n.lightMapIntensity = 1, n.aoMap = null, n.aoMapIntensity = 1, n.emissive = new ny(0), n.emissiveIntensity = 1, n.emissiveMap = null, n.bumpMap = null, n.bumpScale = 1, n.normalMap = null, n.normalMapType = 0, n.normalScale = new e4(1, 1), n.displacementMap = null, n.displacementScale = 1, n.displacementBias = 0, n.alphaMap = null, n.wireframe = !1, n.wireframeLinewidth = 1, n.wireframeLinecap = "round", n.wireframeLinejoin = "round", n.setValues(e), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
                        }
                    }]), t
                }(nh).prototype.isMeshToonMaterial = !0,
                function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t)).type = "MeshNormalMaterial", n.bumpMap = null, n.bumpScale = 1, n.normalMap = null, n.normalMapType = 0, n.normalScale = new e4(1, 1), n.displacementMap = null, n.displacementScale = 1, n.displacementBias = 0, n.wireframe = !1, n.wireframeLinewidth = 1, n.fog = !1, n.flatShading = !1, n.setValues(e), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
                        }
                    }]), t
                }(nh).prototype.isMeshNormalMaterial = !0,
                function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t)).type = "MeshLambertMaterial", n.color = new ny(0xffffff), n.map = null, n.lightMap = null, n.lightMapIntensity = 1, n.aoMap = null, n.aoMapIntensity = 1, n.emissive = new ny(0), n.emissiveIntensity = 1, n.emissiveMap = null, n.specularMap = null, n.alphaMap = null, n.envMap = null, n.combine = 0, n.reflectivity = 1, n.refractionRatio = .98, n.wireframe = !1, n.wireframeLinewidth = 1, n.wireframeLinecap = "round", n.wireframeLinejoin = "round", n.setValues(e), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
                        }
                    }]), t
                }(nh).prototype.isMeshLambertMaterial = !0,
                function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t)).defines = {
                            MATCAP: ""
                        }, n.type = "MeshMatcapMaterial", n.color = new ny(0xffffff), n.matcap = null, n.map = null, n.bumpMap = null, n.bumpScale = 1, n.normalMap = null, n.normalMapType = 0, n.normalScale = new e4(1, 1), n.displacementMap = null, n.displacementScale = 1, n.displacementBias = 0, n.alphaMap = null, n.flatShading = !1, n.setValues(e), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.defines = {
                                MATCAP: ""
                            }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this
                        }
                    }]), t
                }(nh).prototype.isMeshMatcapMaterial = !0,
                function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t)).type = "LineDashedMaterial", n.scale = 1, n.dashSize = 3, n.gapSize = 1, n.setValues(e), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
                        }
                    }]), t
                }(oe).prototype.isLineDashedMaterial = !0;
            var st = {
                    arraySlice: function(e, t, n) {
                        return st.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
                    },
                    convertArray: function(e, t, n) {
                        return e && (n || e.constructor !== t) ? "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) : e
                    },
                    isTypedArray: function(e) {
                        return ArrayBuffer.isView(e) && !(e instanceof DataView)
                    },
                    getKeyframeOrder: function(e) {
                        for (var t = e.length, n = Array(t), r = 0; r !== t; ++r) n[r] = r;
                        return n.sort(function(t, n) {
                            return e[t] - e[n]
                        }), n
                    },
                    sortedArray: function(e, t, n) {
                        for (var r = e.length, i = new e.constructor(r), a = 0, o = 0; o !== r; ++a)
                            for (var s = n[a] * t, l = 0; l !== t; ++l) i[o++] = e[s + l];
                        return i
                    },
                    flattenJSON: function(e, t, n, r) {
                        for (var i = 1, a = e[0]; void 0 !== a && void 0 === a[r];) a = e[i++];
                        if (void 0 !== a) {
                            var o = a[r];
                            if (void 0 !== o) {
                                if (Array.isArray(o))
                                    do void 0 !== (o = a[r]) && (t.push(a.time), n.push.apply(n, o)), a = e[i++]; while (void 0 !== a);
                                else if (void 0 !== o.toArray)
                                    do void 0 !== (o = a[r]) && (t.push(a.time), o.toArray(n, n.length)), a = e[i++]; while (void 0 !== a);
                                else
                                    do void 0 !== (o = a[r]) && (t.push(a.time), n.push(o)), a = e[i++]; while (void 0 !== a)
                            }
                        }
                    },
                    subclip: function(e, t, n, r) {
                        var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 30,
                            a = e.clone();
                        a.name = t;
                        for (var o = [], s = 0; s < a.tracks.length; ++s) {
                            for (var l = a.tracks[s], u = l.getValueSize(), c = [], h = [], d = 0; d < l.times.length; ++d) {
                                var f = l.times[d] * i;
                                if (!(f < n || f >= r)) {
                                    c.push(l.times[d]);
                                    for (var p = 0; p < u; ++p) h.push(l.values[d * u + p])
                                }
                            }
                            0 !== c.length && (l.times = st.convertArray(c, l.times.constructor), l.values = st.convertArray(h, l.values.constructor), o.push(l))
                        }
                        a.tracks = o;
                        for (var m = 1 / 0, v = 0; v < a.tracks.length; ++v) m > a.tracks[v].times[0] && (m = a.tracks[v].times[0]);
                        for (var g = 0; g < a.tracks.length; ++g) a.tracks[g].shift(-1 * m);
                        return a.resetDuration(), a
                    },
                    makeClipAdditive: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e,
                            r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 30;
                        r <= 0 && (r = 30);
                        for (var i = n.tracks.length, a = t / r, o = 0; o < i; ++o) ! function(t) {
                            var r = n.tracks[t],
                                i = r.ValueTypeName;
                            if ("bool" !== i && "string" !== i) {
                                var o = e.tracks.find(function(e) {
                                    return e.name === r.name && e.ValueTypeName === i
                                });
                                if (void 0 !== o) {
                                    var s = 0,
                                        l = r.getValueSize();
                                    r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s = l / 3);
                                    var u = 0,
                                        c = o.getValueSize();
                                    o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = c / 3);
                                    var h = r.times.length - 1,
                                        d = void 0;
                                    if (a <= r.times[0]) {
                                        var f = s,
                                            p = l - s;
                                        d = st.arraySlice(r.values, f, p)
                                    } else if (a >= r.times[h]) {
                                        var m = h * l + s,
                                            v = m + l - s;
                                        d = st.arraySlice(r.values, m, v)
                                    } else {
                                        var g = r.createInterpolant(),
                                            y = s,
                                            _ = l - s;
                                        g.evaluate(a), d = st.arraySlice(g.resultBuffer, y, _)
                                    }
                                    "quaternion" === i && (new ta).fromArray(d).normalize().conjugate().toArray(d);
                                    for (var x = o.times.length, b = 0; b < x; ++b) {
                                        var w = b * c + u;
                                        if ("quaternion" === i) ta.multiplyQuaternionsFlat(o.values, w, d, 0, o.values, w);
                                        else
                                            for (var M = c - 2 * u, S = 0; S < M; ++S) o.values[w + S] -= d[S]
                                    }
                                }
                            }
                        }(o);
                        return e.blendMode = 2501, e
                    }
                },
                sn = function() {
                    function e(t, n, r, i) {
                        (0, k._)(this, e), this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new n.constructor(r), this.sampleValues = n, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {}
                    }
                    return (0, A._)(e, [{
                        key: "evaluate",
                        value: function(e) {
                            var t, n = this.parameterPositions,
                                r = this._cachedIndex,
                                i = n[r],
                                a = n[r - 1];
                            e: {
                                t: {
                                    n: {
                                        r: if (!(e < i)) {
                                            for (var o = r + 2;;) {
                                                if (void 0 === i) {
                                                    if (e < a) break r;
                                                    return r = n.length, this._cachedIndex = r, this.afterEnd_(r - 1, e, a)
                                                }
                                                if (r === o) break;
                                                if (a = i, e < (i = n[++r])) break t
                                            }
                                            t = n.length;
                                            break n
                                        }if (e >= a) break e;
                                        var s = n[1];e < s && (r = 2, a = s);
                                        for (var l = r - 2;;) {
                                            if (void 0 === a) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
                                            if (r === l) break;
                                            if (i = a, e >= (a = n[--r - 1])) break t
                                        }
                                        t = r,
                                        r = 0
                                    }
                                    for (; r < t;) {
                                        var u = r + t >>> 1;
                                        e < n[u] ? t = u : r = u + 1
                                    }
                                    if (i = n[r], void 0 === (a = n[r - 1])) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
                                    if (void 0 === i) return r = n.length, this._cachedIndex = r, this.afterEnd_(r - 1, a, e)
                                }
                                this._cachedIndex = r,
                                this.intervalChanged_(r, a, i)
                            }
                            return this.interpolate_(r, a, e, i)
                        }
                    }, {
                        key: "getSettings_",
                        value: function() {
                            return this.settings || this.DefaultSettings_
                        }
                    }, {
                        key: "copySampleValue_",
                        value: function(e) {
                            for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r, a = 0; a !== r; ++a) t[a] = n[i + a];
                            return t
                        }
                    }, {
                        key: "interpolate_",
                        value: function() {
                            throw Error("call to abstract method")
                        }
                    }, {
                        key: "intervalChanged_",
                        value: function() {}
                    }]), e
                }();
            sn.prototype.beforeStart_ = sn.prototype.copySampleValue_, sn.prototype.afterEnd_ = sn.prototype.copySampleValue_;
            var sr = function(e) {
                    function t(e, n, r, i) {
                        var a;
                        return (0, k._)(this, t), (a = (0, E._)(this, t, [e, n, r, i]))._weightPrev = -0, a._offsetPrev = -0, a._weightNext = -0, a._offsetNext = -0, a.DefaultSettings_ = {
                            endingStart: 2400,
                            endingEnd: 2400
                        }, a
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "intervalChanged_",
                        value: function(e, t, n) {
                            var r = this.parameterPositions,
                                i = e - 2,
                                a = e + 1,
                                o = r[i],
                                s = r[a];
                            if (void 0 === o) switch (this.getSettings_().endingStart) {
                                case 2401:
                                    i = e, o = 2 * t - n;
                                    break;
                                case 2402:
                                    i = r.length - 2, o = t + r[i] - r[i + 1];
                                    break;
                                default:
                                    i = e, o = n
                            }
                            if (void 0 === s) switch (this.getSettings_().endingEnd) {
                                case 2401:
                                    a = e, s = 2 * n - t;
                                    break;
                                case 2402:
                                    a = 1, s = n + r[1] - r[0];
                                    break;
                                default:
                                    a = e - 1, s = t
                            }
                            var l = .5 * (n - t),
                                u = this.valueSize;
                            this._weightPrev = l / (t - o), this._weightNext = l / (s - n), this._offsetPrev = i * u, this._offsetNext = a * u
                        }
                    }, {
                        key: "interpolate_",
                        value: function(e, t, n, r) {
                            for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, u = this._offsetPrev, c = this._offsetNext, h = this._weightPrev, d = this._weightNext, f = (n - t) / (r - t), p = f * f, m = p * f, v = -h * m + 2 * h * p - h * f, g = (1 + h) * m + (-1.5 - 2 * h) * p + (-.5 + h) * f + 1, y = (-1 - d) * m + (1.5 + d) * p + .5 * f, _ = d * m - d * p, x = 0; x !== o; ++x) i[x] = v * a[u + x] + g * a[l + x] + y * a[s + x] + _ * a[c + x];
                            return i
                        }
                    }]), t
                }(sn),
                si = function(e) {
                    function t(e, n, r, i) {
                        return (0, k._)(this, t), (0, E._)(this, t, [e, n, r, i])
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "interpolate_",
                        value: function(e, t, n, r) {
                            for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, u = (n - t) / (r - t), c = 1 - u, h = 0; h !== o; ++h) i[h] = a[l + h] * c + a[s + h] * u;
                            return i
                        }
                    }]), t
                }(sn),
                sa = function(e) {
                    function t(e, n, r, i) {
                        return (0, k._)(this, t), (0, E._)(this, t, [e, n, r, i])
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "interpolate_",
                        value: function(e) {
                            return this.copySampleValue_(e - 1)
                        }
                    }]), t
                }(sn),
                so = function() {
                    function e(t, n, r, i) {
                        if ((0, k._)(this, e), void 0 === t) throw Error("THREE.KeyframeTrack: track name is undefined");
                        if (void 0 === n || 0 === n.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                        this.name = t, this.times = st.convertArray(n, this.TimeBufferType), this.values = st.convertArray(r, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
                    }
                    return (0, A._)(e, [{
                        key: "InterpolantFactoryMethodDiscrete",
                        value: function(e) {
                            return new sa(this.times, this.values, this.getValueSize(), e)
                        }
                    }, {
                        key: "InterpolantFactoryMethodLinear",
                        value: function(e) {
                            return new si(this.times, this.values, this.getValueSize(), e)
                        }
                    }, {
                        key: "InterpolantFactoryMethodSmooth",
                        value: function(e) {
                            return new sr(this.times, this.values, this.getValueSize(), e)
                        }
                    }, {
                        key: "setInterpolation",
                        value: function(e) {
                            var t;
                            switch (e) {
                                case 2300:
                                    t = this.InterpolantFactoryMethodDiscrete;
                                    break;
                                case 2301:
                                    t = this.InterpolantFactoryMethodLinear;
                                    break;
                                case 2302:
                                    t = this.InterpolantFactoryMethodSmooth
                            }
                            if (void 0 === t) {
                                var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                                if (void 0 === this.createInterpolant) {
                                    if (e === this.DefaultInterpolation) throw Error(n);
                                    this.setInterpolation(this.DefaultInterpolation)
                                }
                                return console.warn("THREE.KeyframeTrack:", n), this
                            }
                            return this.createInterpolant = t, this
                        }
                    }, {
                        key: "getInterpolation",
                        value: function() {
                            switch (this.createInterpolant) {
                                case this.InterpolantFactoryMethodDiscrete:
                                    return 2300;
                                case this.InterpolantFactoryMethodLinear:
                                    return 2301;
                                case this.InterpolantFactoryMethodSmooth:
                                    return 2302
                            }
                        }
                    }, {
                        key: "getValueSize",
                        value: function() {
                            return this.values.length / this.times.length
                        }
                    }, {
                        key: "shift",
                        value: function(e) {
                            if (0 !== e)
                                for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] += e;
                            return this
                        }
                    }, {
                        key: "scale",
                        value: function(e) {
                            if (1 !== e)
                                for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] *= e;
                            return this
                        }
                    }, {
                        key: "trim",
                        value: function(e, t) {
                            for (var n = this.times, r = n.length, i = 0, a = r - 1; i !== r && n[i] < e;) ++i;
                            for (; - 1 !== a && n[a] > t;) --a;
                            if (++a, 0 !== i || a !== r) {
                                i >= a && (i = (a = Math.max(a, 1)) - 1);
                                var o = this.getValueSize();
                                this.times = st.arraySlice(n, i, a), this.values = st.arraySlice(this.values, i * o, a * o)
                            }
                            return this
                        }
                    }, {
                        key: "validate",
                        value: function() {
                            var e = !0,
                                t = this.getValueSize();
                            t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                            var n = this.times,
                                r = this.values,
                                i = n.length;
                            0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                            for (var a = null, o = 0; o !== i; o++) {
                                var s = n[o];
                                if ("number" == typeof s && isNaN(s)) {
                                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), e = !1;
                                    break
                                }
                                if (null !== a && a > s) {
                                    console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a), e = !1;
                                    break
                                }
                                a = s
                            }
                            if (void 0 !== r && st.isTypedArray(r))
                                for (var l = 0, u = r.length; l !== u; ++l) {
                                    var c = r[l];
                                    if (isNaN(c)) {
                                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, l, c), e = !1;
                                        break
                                    }
                                }
                            return e
                        }
                    }, {
                        key: "optimize",
                        value: function() {
                            for (var e = st.arraySlice(this.times), t = st.arraySlice(this.values), n = this.getValueSize(), r = 2302 === this.getInterpolation(), i = e.length - 1, a = 1, o = 1; o < i; ++o) {
                                var s = !1,
                                    l = e[o];
                                if (l !== e[o + 1] && (1 !== o || l !== e[0])) {
                                    if (r) s = !0;
                                    else
                                        for (var u = o * n, c = u - n, h = u + n, d = 0; d !== n; ++d) {
                                            var f = t[u + d];
                                            if (f !== t[c + d] || f !== t[h + d]) {
                                                s = !0;
                                                break
                                            }
                                        }
                                }
                                if (s) {
                                    if (o !== a) {
                                        e[a] = e[o];
                                        for (var p = o * n, m = a * n, v = 0; v !== n; ++v) t[m + v] = t[p + v]
                                    }++a
                                }
                            }
                            if (i > 0) {
                                e[a] = e[i];
                                for (var g = i * n, y = a * n, _ = 0; _ !== n; ++_) t[y + _] = t[g + _];
                                ++a
                            }
                            return a !== e.length ? (this.times = st.arraySlice(e, 0, a), this.values = st.arraySlice(t, 0, a * n)) : (this.times = e, this.values = t), this
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            var e = st.arraySlice(this.times, 0),
                                t = st.arraySlice(this.values, 0),
                                n = new this.constructor(this.name, e, t);
                            return n.createInterpolant = this.createInterpolant, n
                        }
                    }], [{
                        key: "toJSON",
                        value: function(e) {
                            var t, n = e.constructor;
                            if (n.toJSON !== this.toJSON) t = n.toJSON(e);
                            else {
                                t = {
                                    name: e.name,
                                    times: st.convertArray(e.times, Array),
                                    values: st.convertArray(e.values, Array)
                                };
                                var r = e.getInterpolation();
                                r !== e.DefaultInterpolation && (t.interpolation = r)
                            }
                            return t.type = e.ValueTypeName, t
                        }
                    }]), e
                }();
            so.prototype.TimeBufferType = Float32Array, so.prototype.ValueBufferType = Float32Array, so.prototype.DefaultInterpolation = 2301;
            var ss = function(e) {
                function t() {
                    return (0, k._)(this, t), (0, E._)(this, t, arguments)
                }
                return (0, P._)(t, e), t
            }(so);
            ss.prototype.ValueTypeName = "bool", ss.prototype.ValueBufferType = Array, ss.prototype.DefaultInterpolation = 2300, ss.prototype.InterpolantFactoryMethodLinear = void 0, ss.prototype.InterpolantFactoryMethodSmooth = void 0;
            var sl = function(e) {
                function t() {
                    return (0, k._)(this, t), (0, E._)(this, t, arguments)
                }
                return (0, P._)(t, e), t
            }(so);
            sl.prototype.ValueTypeName = "color";
            var su = function(e) {
                function t() {
                    return (0, k._)(this, t), (0, E._)(this, t, arguments)
                }
                return (0, P._)(t, e), t
            }(so);
            su.prototype.ValueTypeName = "number";
            var sc = function(e) {
                    function t(e, n, r, i) {
                        return (0, k._)(this, t), (0, E._)(this, t, [e, n, r, i])
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "interpolate_",
                        value: function(e, t, n, r) {
                            for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = (n - t) / (r - t), l = e * o, u = l + o; l !== u; l += 4) ta.slerpFlat(i, 0, a, l - o, a, l, s);
                            return i
                        }
                    }]), t
                }(sn),
                sh = function(e) {
                    function t() {
                        return (0, k._)(this, t), (0, E._)(this, t, arguments)
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "InterpolantFactoryMethodLinear",
                        value: function(e) {
                            return new sc(this.times, this.values, this.getValueSize(), e)
                        }
                    }]), t
                }(so);
            sh.prototype.ValueTypeName = "quaternion", sh.prototype.DefaultInterpolation = 2301, sh.prototype.InterpolantFactoryMethodSmooth = void 0;
            var sd = function(e) {
                function t() {
                    return (0, k._)(this, t), (0, E._)(this, t, arguments)
                }
                return (0, P._)(t, e), t
            }(so);
            sd.prototype.ValueTypeName = "string", sd.prototype.ValueBufferType = Array, sd.prototype.DefaultInterpolation = 2300, sd.prototype.InterpolantFactoryMethodLinear = void 0, sd.prototype.InterpolantFactoryMethodSmooth = void 0;
            var sf = function(e) {
                function t() {
                    return (0, k._)(this, t), (0, E._)(this, t, arguments)
                }
                return (0, P._)(t, e), t
            }(so);
            sf.prototype.ValueTypeName = "vector";
            var sp = function() {
                    function e(t) {
                        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1,
                            r = arguments.length > 2 ? arguments[2] : void 0,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2500;
                        (0, k._)(this, e), this.name = t, this.tracks = r, this.duration = n, this.blendMode = i, this.uuid = eZ(), this.duration < 0 && this.resetDuration()
                    }
                    return (0, A._)(e, [{
                        key: "resetDuration",
                        value: function() {
                            for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) {
                                var r = this.tracks[t];
                                e = Math.max(e, r.times[r.times.length - 1])
                            }
                            return this.duration = e, this
                        }
                    }, {
                        key: "trim",
                        value: function() {
                            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                            return this
                        }
                    }, {
                        key: "validate",
                        value: function() {
                            for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                            return e
                        }
                    }, {
                        key: "optimize",
                        value: function() {
                            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                            return this
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                            return new this.constructor(this.name, this.duration, e, this.blendMode)
                        }
                    }, {
                        key: "toJSON",
                        value: function() {
                            return this.constructor.toJSON(this)
                        }
                    }], [{
                        key: "parse",
                        value: function(e) {
                            for (var t = [], n = e.tracks, r = 1 / (e.fps || 1), i = 0, a = n.length; i !== a; ++i) t.push((function(e) {
                                if (void 0 === e.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
                                var t = function(e) {
                                    switch (e.toLowerCase()) {
                                        case "scalar":
                                        case "double":
                                        case "float":
                                        case "number":
                                        case "integer":
                                            return su;
                                        case "vector":
                                        case "vector2":
                                        case "vector3":
                                        case "vector4":
                                            return sf;
                                        case "color":
                                            return sl;
                                        case "quaternion":
                                            return sh;
                                        case "bool":
                                        case "boolean":
                                            return ss;
                                        case "string":
                                            return sd
                                    }
                                    throw Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                                }(e.type);
                                if (void 0 === e.times) {
                                    var n = [],
                                        r = [];
                                    st.flattenJSON(e.keys, n, r, "value"), e.times = n, e.values = r
                                }
                                return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
                            })(n[i]).scale(r));
                            var o = new this(e.name, e.duration, t, e.blendMode);
                            return o.uuid = e.uuid, o
                        }
                    }, {
                        key: "toJSON",
                        value: function(e) {
                            for (var t = [], n = e.tracks, r = {
                                    name: e.name,
                                    duration: e.duration,
                                    tracks: t,
                                    uuid: e.uuid,
                                    blendMode: e.blendMode
                                }, i = 0, a = n.length; i !== a; ++i) t.push(so.toJSON(n[i]));
                            return r
                        }
                    }, {
                        key: "CreateFromMorphTargetSequence",
                        value: function(e, t, n, r) {
                            for (var i = t.length, a = [], o = 0; o < i; o++) {
                                var s = [],
                                    l = [];
                                s.push((o + i - 1) % i, o, (o + 1) % i), l.push(0, 1, 0);
                                var u = st.getKeyframeOrder(s);
                                s = st.sortedArray(s, 1, u), l = st.sortedArray(l, 1, u), r || 0 !== s[0] || (s.push(i), l.push(l[0])), a.push(new su(".morphTargetInfluences[" + t[o].name + "]", s, l).scale(1 / n))
                            }
                            return new this(e, -1, a)
                        }
                    }, {
                        key: "findByName",
                        value: function(e, t) {
                            var n = e;
                            Array.isArray(e) || (n = e.geometry && e.geometry.animations || e.animations);
                            for (var r = 0; r < n.length; r++)
                                if (n[r].name === t) return n[r];
                            return null
                        }
                    }, {
                        key: "CreateClipsFromMorphTargetSequences",
                        value: function(e, t, n) {
                            for (var r = {}, i = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) {
                                var s = e[a],
                                    l = s.name.match(i);
                                if (l && l.length > 1) {
                                    var u = l[1],
                                        c = r[u];
                                    c || (r[u] = c = []), c.push(s)
                                }
                            }
                            var h = [];
                            for (var d in r) h.push(this.CreateFromMorphTargetSequence(d, r[d], t, n));
                            return h
                        }
                    }, {
                        key: "parseAnimation",
                        value: function(e, t) {
                            if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                            for (var n = function(e, t, n, r, i) {
                                    if (0 !== n.length) {
                                        var a = [],
                                            o = [];
                                        st.flattenJSON(n, a, o, r), 0 !== a.length && i.push(new e(t, a, o))
                                    }
                                }, r = [], i = e.name || "default", a = e.fps || 30, o = e.blendMode, s = e.length || -1, l = e.hierarchy || [], u = 0; u < l.length; u++) {
                                var c = l[u].keys;
                                if (c && 0 !== c.length) {
                                    if (c[0].morphTargets) {
                                        var h = {},
                                            d = void 0;
                                        for (d = 0; d < c.length; d++)
                                            if (c[d].morphTargets)
                                                for (var f = 0; f < c[d].morphTargets.length; f++) h[c[d].morphTargets[f]] = -1;
                                        for (var p in h) {
                                            for (var m = [], v = [], g = 0; g !== c[d].morphTargets.length; ++g) {
                                                var y = c[d];
                                                m.push(y.time), v.push(y.morphTarget === p ? 1 : 0)
                                            }
                                            r.push(new su(".morphTargetInfluence[" + p + "]", m, v))
                                        }
                                        s = h.length * (a || 1)
                                    } else {
                                        var _ = ".bones[" + t[u].name + "]";
                                        n(sf, _ + ".position", c, "pos", r), n(sh, _ + ".quaternion", c, "rot", r), n(sf, _ + ".scale", c, "scl", r)
                                    }
                                }
                            }
                            return 0 === r.length ? null : new this(i, s, r, o)
                        }
                    }]), e
                }(),
                sm = {
                    enabled: !1,
                    files: {},
                    add: function(e, t) {
                        !1 !== this.enabled && (this.files[e] = t)
                    },
                    get: function(e) {
                        if (!1 !== this.enabled) return this.files[e]
                    },
                    remove: function(e) {
                        delete this.files[e]
                    },
                    clear: function() {
                        this.files = {}
                    }
                },
                sv = new function e(t, n, r) {
                    (0, k._)(this, e);
                    var i, a = this,
                        o = !1,
                        s = 0,
                        l = 0,
                        u = [];
                    this.onStart = void 0, this.onLoad = t, this.onProgress = n, this.onError = r, this.itemStart = function(e) {
                        l++, !1 === o && void 0 !== a.onStart && a.onStart(e, s, l), o = !0
                    }, this.itemEnd = function(e) {
                        s++, void 0 !== a.onProgress && a.onProgress(e, s, l), s === l && (o = !1, void 0 !== a.onLoad && a.onLoad())
                    }, this.itemError = function(e) {
                        void 0 !== a.onError && a.onError(e)
                    }, this.resolveURL = function(e) {
                        return i ? i(e) : e
                    }, this.setURLModifier = function(e) {
                        return i = e, this
                    }, this.addHandler = function(e, t) {
                        return u.push(e, t), this
                    }, this.removeHandler = function(e) {
                        var t = u.indexOf(e);
                        return -1 !== t && u.splice(t, 2), this
                    }, this.getHandler = function(e) {
                        for (var t = 0, n = u.length; t < n; t += 2) {
                            var r = u[t],
                                i = u[t + 1];
                            if (r.global && (r.lastIndex = 0), r.test(e)) return i
                        }
                        return null
                    }
                },
                sg = function() {
                    function e(t) {
                        (0, k._)(this, e), this.manager = void 0 !== t ? t : sv, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                    }
                    return (0, A._)(e, [{
                        key: "load",
                        value: function() {}
                    }, {
                        key: "loadAsync",
                        value: function(e, t) {
                            var n = this;
                            return new Promise(function(r, i) {
                                n.load(e, r, t, i)
                            })
                        }
                    }, {
                        key: "parse",
                        value: function() {}
                    }, {
                        key: "setCrossOrigin",
                        value: function(e) {
                            return this.crossOrigin = e, this
                        }
                    }, {
                        key: "setWithCredentials",
                        value: function(e) {
                            return this.withCredentials = e, this
                        }
                    }, {
                        key: "setPath",
                        value: function(e) {
                            return this.path = e, this
                        }
                    }, {
                        key: "setResourcePath",
                        value: function(e) {
                            return this.resourcePath = e, this
                        }
                    }, {
                        key: "setRequestHeader",
                        value: function(e) {
                            return this.requestHeader = e, this
                        }
                    }]), e
                }(),
                sy = {},
                s_ = function(e) {
                    function t(e) {
                        return (0, k._)(this, t), (0, E._)(this, t, [e])
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "load",
                        value: function(e, t, n, r) {
                            var i = this;
                            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                            var a = sm.get(e);
                            return void 0 !== a ? (this.manager.itemStart(e), setTimeout(function() {
                                t && t(a), i.manager.itemEnd(e)
                            }, 0), a) : void 0 !== sy[e] ? void sy[e].push({
                                onLoad: t,
                                onProgress: n,
                                onError: r
                            }) : void(sy[e] = [], sy[e].push({
                                onLoad: t,
                                onProgress: n,
                                onError: r
                            }), fetch(new Request(e, {
                                headers: new Headers(this.requestHeader),
                                credentials: this.withCredentials ? "include" : "same-origin"
                            })).then(function(t) {
                                if (200 === t.status || 0 === t.status) {
                                    if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body.getReader) return t;
                                    var n = sy[e],
                                        r = t.body.getReader(),
                                        i = t.headers.get("Content-Length"),
                                        a = i ? parseInt(i) : 0,
                                        o = 0 !== a,
                                        s = 0;
                                    return new Response(new ReadableStream({
                                        start: function(e) {
                                            ! function t() {
                                                r.read().then(function(r) {
                                                    var i = r.done,
                                                        l = r.value;
                                                    if (i) e.close();
                                                    else {
                                                        for (var u = new ProgressEvent("progress", {
                                                                lengthComputable: o,
                                                                loaded: s += l.byteLength,
                                                                total: a
                                                            }), c = 0, h = n.length; c < h; c++) {
                                                            var d = n[c];
                                                            d.onProgress && d.onProgress(u)
                                                        }
                                                        e.enqueue(l), t()
                                                    }
                                                })
                                            }()
                                        }
                                    }))
                                }
                                throw Error('fetch for "'.concat(t.url, '" responded with ').concat(t.status, ": ").concat(t.statusText))
                            }).then(function(e) {
                                switch (i.responseType) {
                                    case "arraybuffer":
                                        return e.arrayBuffer();
                                    case "blob":
                                        return e.blob();
                                    case "document":
                                        return e.text().then(function(e) {
                                            return (new DOMParser).parseFromString(e, i.mimeType)
                                        });
                                    case "json":
                                        return e.json();
                                    default:
                                        return e.text()
                                }
                            }).then(function(t) {
                                sm.add(e, t);
                                var n = sy[e];
                                delete sy[e];
                                for (var r = 0, i = n.length; r < i; r++) {
                                    var a = n[r];
                                    a.onLoad && a.onLoad(t)
                                }
                            }).catch(function(t) {
                                var n = sy[e];
                                if (void 0 === n) throw i.manager.itemError(e), t;
                                delete sy[e];
                                for (var r = 0, a = n.length; r < a; r++) {
                                    var o = n[r];
                                    o.onError && o.onError(t)
                                }
                                i.manager.itemError(e)
                            }).finally(function() {
                                i.manager.itemEnd(e)
                            }), this.manager.itemStart(e))
                        }
                    }, {
                        key: "setResponseType",
                        value: function(e) {
                            return this.responseType = e, this
                        }
                    }, {
                        key: "setMimeType",
                        value: function(e) {
                            return this.mimeType = e, this
                        }
                    }]), t
                }(sg),
                sx = function(e) {
                    function t(e) {
                        return (0, k._)(this, t), (0, E._)(this, t, [e])
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "load",
                        value: function(e, t, n, r) {
                            void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                            var i = this,
                                a = sm.get(e);
                            if (void 0 !== a) return i.manager.itemStart(e), setTimeout(function() {
                                t && t(a), i.manager.itemEnd(e)
                            }, 0), a;
                            var o = e8("img");

                            function s() {
                                u(), sm.add(e, this), t && t(this), i.manager.itemEnd(e)
                            }

                            function l(t) {
                                u(), r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
                            }

                            function u() {
                                o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1)
                            }
                            return o.addEventListener("load", s, !1), o.addEventListener("error", l, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(e), o.src = e, o
                        }
                    }]), t
                }(sg),
                sb = function(e) {
                    function t(e) {
                        return (0, k._)(this, t), (0, E._)(this, t, [e])
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "load",
                        value: function(e, t, n, r) {
                            var i = new n8,
                                a = new sx(this.manager);
                            a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
                            for (var o = 0, s = 0; s < e.length; ++s) ! function(n) {
                                a.load(e[n], function(e) {
                                    i.images[n] = e, 6 == ++o && (i.needsUpdate = !0, t && t(i))
                                }, void 0, r)
                            }(s);
                            return i
                        }
                    }]), t
                }(sg),
                sw = function(e) {
                    function t(e) {
                        return (0, k._)(this, t), (0, E._)(this, t, [e])
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "load",
                        value: function(e, t, n, r) {
                            var i = this,
                                a = new a1,
                                o = new s_(this.manager);
                            return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(i.withCredentials), o.load(e, function(e) {
                                var n = i.parse(e);
                                n && (void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width, a.image.height = n.height, a.image.data = n.data), a.wrapS = void 0 !== n.wrapS ? n.wrapS : 1001, a.wrapT = void 0 !== n.wrapT ? n.wrapT : 1001, a.magFilter = void 0 !== n.magFilter ? n.magFilter : 1006, a.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (a.encoding = n.encoding), void 0 !== n.flipY && (a.flipY = n.flipY), void 0 !== n.format && (a.format = n.format), void 0 !== n.type && (a.type = n.type), void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps, a.minFilter = 1008), 1 === n.mipmapCount && (a.minFilter = 1006), void 0 !== n.generateMipmaps && (a.generateMipmaps = n.generateMipmaps), a.needsUpdate = !0, t && t(a, n))
                            }, n, r), a
                        }
                    }]), t
                }(sg),
                sM = function(e) {
                    function t(e) {
                        return (0, k._)(this, t), (0, E._)(this, t, [e])
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "load",
                        value: function(e, t, n, r) {
                            var i = new te,
                                a = new sx(this.manager);
                            return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(e) {
                                i.image = e, i.needsUpdate = !0, void 0 !== t && t(i)
                            }, n, r), i
                        }
                    }]), t
                }(sg),
                sS = function(e) {
                    function t(e) {
                        var n, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                        return (0, k._)(this, t), (n = (0, E._)(this, t)).type = "Light", n.color = new ny(e), n.intensity = r, n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "dispose",
                        value: function() {}
                    }, {
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
                        }
                    }, {
                        key: "toJSON",
                        value: function(e) {
                            var n = L((0, C._)(t.prototype), "toJSON", this).call(this, e);
                            return n.object.color = this.color.getHex(), n.object.intensity = this.intensity, void 0 !== this.groundColor && (n.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (n.object.distance = this.distance), void 0 !== this.angle && (n.object.angle = this.angle), void 0 !== this.decay && (n.object.decay = this.decay), void 0 !== this.penumbra && (n.object.penumbra = this.penumbra), void 0 !== this.shadow && (n.object.shadow = this.shadow.toJSON()), n
                        }
                    }]), t
                }(t7);
            sS.prototype.isLight = !0,
                function(e) {
                    function t(e, n, r) {
                        var i;
                        return (0, k._)(this, t), (i = (0, E._)(this, t, [e, r])).type = "HemisphereLight", i.position.copy(t7.DefaultUp), i.updateMatrix(), i.groundColor = new ny(n), i
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return sS.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
                        }
                    }]), t
                }(sS).prototype.isHemisphereLight = !0;
            var sT = new tF,
                sE = new to,
                sk = new to,
                sA = function() {
                    function e(t) {
                        (0, k._)(this, e), this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new e4(512, 512), this.map = null, this.mapPass = null, this.matrix = new tF, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new ra, this._frameExtents = new e4(1, 1), this._viewportCount = 1, this._viewports = [new tn(0, 0, 1, 1)]
                    }
                    return (0, A._)(e, [{
                        key: "getViewportCount",
                        value: function() {
                            return this._viewportCount
                        }
                    }, {
                        key: "getFrustum",
                        value: function() {
                            return this._frustum
                        }
                    }, {
                        key: "updateMatrices",
                        value: function(e) {
                            var t = this.camera,
                                n = this.matrix;
                            sE.setFromMatrixPosition(e.matrixWorld), t.position.copy(sE), sk.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(sk), t.updateMatrixWorld(), sT.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(sT), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
                        }
                    }, {
                        key: "getViewport",
                        value: function(e) {
                            return this._viewports[e]
                        }
                    }, {
                        key: "getFrameExtents",
                        value: function() {
                            return this._frameExtents
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return (new this.constructor).copy(this)
                        }
                    }, {
                        key: "toJSON",
                        value: function() {
                            var e = {};
                            return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
                        }
                    }]), e
                }(),
                sR = function(e) {
                    function t() {
                        var e;
                        return (0, k._)(this, t), (e = (0, E._)(this, t, [new n5(50, 1, .5, 500)])).focus = 1, e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "updateMatrices",
                        value: function(e) {
                            var n = this.camera,
                                r = 2 * eJ * e.angle * this.focus,
                                i = this.mapSize.width / this.mapSize.height,
                                a = e.distance || n.far;
                            r === n.fov && i === n.aspect && a === n.far || (n.fov = r, n.aspect = i, n.far = a, n.updateProjectionMatrix()), L((0, C._)(t.prototype), "updateMatrices", this).call(this, e)
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.focus = e.focus, this
                        }
                    }]), t
                }(sA);
            sR.prototype.isSpotLightShadow = !0;
            var sC = function(e) {
                function t(e, n) {
                    var r, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                        a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Math.PI / 3,
                        o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                        s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
                    return (0, k._)(this, t), (r = (0, E._)(this, t, [e, n])).type = "SpotLight", r.position.copy(t7.DefaultUp), r.updateMatrix(), r.target = new t7, r.distance = i, r.angle = a, r.penumbra = o, r.decay = s, r.shadow = new sR, r
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "power",
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(e) {
                        this.intensity = e / Math.PI
                    }
                }, {
                    key: "dispose",
                    value: function() {
                        this.shadow.dispose()
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                    }
                }]), t
            }(sS);
            sC.prototype.isSpotLight = !0;
            var sL = new tF,
                sP = new to,
                sI = new to,
                sD = function(e) {
                    function t() {
                        var e;
                        return (0, k._)(this, t), (e = (0, E._)(this, t, [new n5(90, 1, .5, 500)]))._frameExtents = new e4(4, 2), e._viewportCount = 6, e._viewports = [new tn(2, 1, 1, 1), new tn(0, 1, 1, 1), new tn(3, 1, 1, 1), new tn(1, 1, 1, 1), new tn(3, 0, 1, 1), new tn(1, 0, 1, 1)], e._cubeDirections = [new to(1, 0, 0), new to(-1, 0, 0), new to(0, 0, 1), new to(0, 0, -1), new to(0, 1, 0), new to(0, -1, 0)], e._cubeUps = [new to(0, 1, 0), new to(0, 1, 0), new to(0, 1, 0), new to(0, 1, 0), new to(0, 0, 1), new to(0, 0, -1)], e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "updateMatrices",
                        value: function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                                n = this.camera,
                                r = this.matrix,
                                i = e.distance || n.far;
                            i !== n.far && (n.far = i, n.updateProjectionMatrix()), sP.setFromMatrixPosition(e.matrixWorld), n.position.copy(sP), sI.copy(n.position), sI.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(sI), n.updateMatrixWorld(), r.makeTranslation(-sP.x, -sP.y, -sP.z), sL.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(sL)
                        }
                    }]), t
                }(sA);
            sD.prototype.isPointLightShadow = !0;
            var sO = function(e) {
                function t(e, n) {
                    var r, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                        a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                    return (0, k._)(this, t), (r = (0, E._)(this, t, [e, n])).type = "PointLight", r.distance = i, r.decay = a, r.shadow = new sD, r
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "power",
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(e) {
                        this.intensity = e / (4 * Math.PI)
                    }
                }, {
                    key: "dispose",
                    value: function() {
                        this.shadow.dispose()
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
                    }
                }]), t
            }(sS);
            sO.prototype.isPointLight = !0;
            var sN = function(e) {
                function t() {
                    return (0, k._)(this, t), (0, E._)(this, t, [new ry(-5, 5, 5, -5, .5, 500)])
                }
                return (0, P._)(t, e), t
            }(sA);
            sN.prototype.isDirectionalLightShadow = !0;
            var sF = function(e) {
                function t(e, n) {
                    var r;
                    return (0, k._)(this, t), (r = (0, E._)(this, t, [e, n])).type = "DirectionalLight", r.position.copy(t7.DefaultUp), r.updateMatrix(), r.target = new t7, r.shadow = new sN, r
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "dispose",
                    value: function() {
                        this.shadow.dispose()
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                    }
                }]), t
            }(sS);
            sF.prototype.isDirectionalLight = !0,
                function(e) {
                    function t(e, n) {
                        var r;
                        return (0, k._)(this, t), (r = (0, E._)(this, t, [e, n])).type = "AmbientLight", r
                    }
                    return (0, P._)(t, e), t
                }(sS).prototype.isAmbientLight = !0,
                function(e) {
                    function t(e, n) {
                        var r, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
                            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 10;
                        return (0, k._)(this, t), (r = (0, E._)(this, t, [e, n])).type = "RectAreaLight", r.width = i, r.height = a, r
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "power",
                        get: function() {
                            return this.intensity * this.width * this.height * Math.PI
                        },
                        set: function(e) {
                            this.intensity = e / (this.width * this.height * Math.PI)
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.width = e.width, this.height = e.height, this
                        }
                    }, {
                        key: "toJSON",
                        value: function(e) {
                            var n = L((0, C._)(t.prototype), "toJSON", this).call(this, e);
                            return n.object.width = this.width, n.object.height = this.height, n
                        }
                    }]), t
                }(sS).prototype.isRectAreaLight = !0;
            var sU = function() {
                function e() {
                    (0, k._)(this, e), this.coefficients = [];
                    for (var t = 0; t < 9; t++) this.coefficients.push(new to)
                }
                return (0, A._)(e, [{
                    key: "set",
                    value: function(e) {
                        for (var t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
                        return this
                    }
                }, {
                    key: "zero",
                    value: function() {
                        for (var e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                        return this
                    }
                }, {
                    key: "getAt",
                    value: function(e, t) {
                        var n = e.x,
                            r = e.y,
                            i = e.z,
                            a = this.coefficients;
                        return t.copy(a[0]).multiplyScalar(.282095), t.addScaledVector(a[1], .488603 * r), t.addScaledVector(a[2], .488603 * i), t.addScaledVector(a[3], .488603 * n), t.addScaledVector(a[4], n * r * 1.092548), t.addScaledVector(a[5], r * i * 1.092548), t.addScaledVector(a[6], .315392 * (3 * i * i - 1)), t.addScaledVector(a[7], n * i * 1.092548), t.addScaledVector(a[8], .546274 * (n * n - r * r)), t
                    }
                }, {
                    key: "getIrradianceAt",
                    value: function(e, t) {
                        var n = e.x,
                            r = e.y,
                            i = e.z,
                            a = this.coefficients;
                        return t.copy(a[0]).multiplyScalar(.886227), t.addScaledVector(a[1], 1.023328 * r), t.addScaledVector(a[2], 1.023328 * i), t.addScaledVector(a[3], 1.023328 * n), t.addScaledVector(a[4], .858086 * n * r), t.addScaledVector(a[5], .858086 * r * i), t.addScaledVector(a[6], .743125 * i * i - .247708), t.addScaledVector(a[7], .858086 * n * i), t.addScaledVector(a[8], .429043 * (n * n - r * r)), t
                    }
                }, {
                    key: "add",
                    value: function(e) {
                        for (var t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
                        return this
                    }
                }, {
                    key: "addScaledSH",
                    value: function(e, t) {
                        for (var n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
                        return this
                    }
                }, {
                    key: "scale",
                    value: function(e) {
                        for (var t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
                        return this
                    }
                }, {
                    key: "lerp",
                    value: function(e, t) {
                        for (var n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
                        return this
                    }
                }, {
                    key: "equals",
                    value: function(e) {
                        for (var t = 0; t < 9; t++)
                            if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
                        return !0
                    }
                }, {
                    key: "copy",
                    value: function(e) {
                        return this.set(e.coefficients)
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return (new this.constructor).copy(this)
                    }
                }, {
                    key: "fromArray",
                    value: function(e) {
                        for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = this.coefficients, r = 0; r < 9; r++) n[r].fromArray(e, t + 3 * r);
                        return this
                    }
                }, {
                    key: "toArray",
                    value: function() {
                        for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = this.coefficients, r = 0; r < 9; r++) n[r].toArray(e, t + 3 * r);
                        return e
                    }
                }], [{
                    key: "getBasisAt",
                    value: function(e, t) {
                        var n = e.x,
                            r = e.y,
                            i = e.z;
                        t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * i, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * i, t[6] = .315392 * (3 * i * i - 1), t[7] = 1.092548 * n * i, t[8] = .546274 * (n * n - r * r)
                    }
                }]), e
            }();
            sU.prototype.isSphericalHarmonics3 = !0;
            var sB = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new sU,
                        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                    return (0, k._)(this, t), (e = (0, E._)(this, t, [void 0, r])).sh = n, e
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.sh.copy(e.sh), this
                    }
                }, {
                    key: "fromJSON",
                    value: function(e) {
                        return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
                    }
                }, {
                    key: "toJSON",
                    value: function(e) {
                        var n = L((0, C._)(t.prototype), "toJSON", this).call(this, e);
                        return n.object.sh = this.sh.toArray(), n
                    }
                }]), t
            }(sS);
            sB.prototype.isLightProbe = !0;
            var sz = function() {
                function e() {
                    (0, k._)(this, e)
                }
                return (0, A._)(e, null, [{
                    key: "decodeText",
                    value: function(e) {
                        if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
                        for (var t = "", n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);
                        try {
                            return decodeURIComponent(escape(t))
                        } catch (e) {
                            return t
                        }
                    }
                }, {
                    key: "extractUrlBase",
                    value: function(e) {
                        var t = e.lastIndexOf("/");
                        return -1 === t ? "./" : e.substr(0, t + 1)
                    }
                }, {
                    key: "resolveURL",
                    value: function(e, t) {
                        return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
                    }
                }]), e
            }();
            (function(e) {
                function t() {
                    var e;
                    return (0, k._)(this, t), (e = (0, E._)(this, t)).type = "InstancedBufferGeometry", e.instanceCount = 1 / 0, e
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e), this.instanceCount = e.instanceCount, this
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return (new this.constructor).copy(this)
                    }
                }, {
                    key: "toJSON",
                    value: function() {
                        var e = L((0, C._)(t.prototype), "toJSON", this).call(this, this);
                        return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
                    }
                }]), t
            })(nI).prototype.isInstancedBufferGeometry = !0;
            var sH = function(e) {
                function t(e) {
                    var n;
                    return (0, k._)(this, t), n = (0, E._)(this, t, [e]), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), n.options = {
                        premultiplyAlpha: "none"
                    }, n
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "setOptions",
                    value: function(e) {
                        return this.options = e, this
                    }
                }, {
                    key: "load",
                    value: function(e, t, n, r) {
                        void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                        var i = this,
                            a = sm.get(e);
                        if (void 0 !== a) return i.manager.itemStart(e), setTimeout(function() {
                            t && t(a), i.manager.itemEnd(e)
                        }, 0), a;
                        var o = {};
                        o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(e, o).then(function(e) {
                            return e.blob()
                        }).then(function(e) {
                            return createImageBitmap(e, Object.assign(i.options, {
                                colorSpaceConversion: "none"
                            }))
                        }).then(function(n) {
                            sm.add(e, n), t && t(n), i.manager.itemEnd(e)
                        }).catch(function(t) {
                            r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
                        }), i.manager.itemStart(e)
                    }
                }]), t
            }(sg);
            sH.prototype.isImageBitmapLoader = !0;
            var sV = function(e) {
                function t(e) {
                    return (0, k._)(this, t), (0, E._)(this, t, [e])
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "load",
                    value: function(e, t, n, r) {
                        var i = this,
                            a = new s_(this.manager);
                        a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(n) {
                            try {
                                var a = n.slice(0);
                                (void 0 === cE && (cE = new(window.AudioContext || window.webkitAudioContext)), cE).decodeAudioData(a, function(e) {
                                    t(e)
                                })
                            } catch (t) {
                                r ? r(t) : console.error(t), i.manager.itemError(e)
                            }
                        }, n, r)
                    }
                }]), t
            }(sg);
            (function(e) {
                function t(e, n) {
                    var r, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                    (0, k._)(this, t), r = (0, E._)(this, t, [void 0, i]);
                    var a = (new ny).set(e),
                        o = (new ny).set(n),
                        s = new to(a.r, a.g, a.b),
                        l = new to(o.r, o.g, o.b),
                        u = Math.sqrt(Math.PI),
                        c = u * Math.sqrt(.75);
                    return r.sh.coefficients[0].copy(s).add(l).multiplyScalar(u), r.sh.coefficients[1].copy(s).sub(l).multiplyScalar(c), r
                }
                return (0, P._)(t, e), t
            })(sB).prototype.isHemisphereLightProbe = !0,
                function(e) {
                    function t(e) {
                        var n, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                        (0, k._)(this, t), n = (0, E._)(this, t, [void 0, r]);
                        var i = (new ny).set(e);
                        return n.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI)), n
                    }
                    return (0, P._)(t, e), t
                }(sB).prototype.isAmbientLightProbe = !0;
            var sG = function() {
                    function e(t, n, r) {
                        var i, a, o;
                        switch ((0, k._)(this, e), this.binding = t, this.valueSize = r, n) {
                            case "quaternion":
                                i = this._slerp, a = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * r), this._workIndex = 5;
                                break;
                            case "string":
                            case "bool":
                                i = this._select, a = this._select, o = this._setAdditiveIdentityOther, this.buffer = Array(5 * r);
                                break;
                            default:
                                i = this._lerp, a = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * r)
                        }
                        this._mixBufferRegion = i, this._mixBufferRegionAdditive = a, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                    }
                    return (0, A._)(e, [{
                        key: "accumulate",
                        value: function(e, t) {
                            var n = this.buffer,
                                r = this.valueSize,
                                i = e * r + r,
                                a = this.cumulativeWeight;
                            if (0 === a) {
                                for (var o = 0; o !== r; ++o) n[i + o] = n[o];
                                a = t
                            } else {
                                a += t;
                                var s = t / a;
                                this._mixBufferRegion(n, i, 0, s, r)
                            }
                            this.cumulativeWeight = a
                        }
                    }, {
                        key: "accumulateAdditive",
                        value: function(e) {
                            var t = this.buffer,
                                n = this.valueSize,
                                r = n * this._addIndex;
                            0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e
                        }
                    }, {
                        key: "apply",
                        value: function(e) {
                            var t = this.valueSize,
                                n = this.buffer,
                                r = e * t + t,
                                i = this.cumulativeWeight,
                                a = this.cumulativeWeightAdditive,
                                o = this.binding;
                            if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
                                var s = t * this._origIndex;
                                this._mixBufferRegion(n, r, s, 1 - i, t)
                            }
                            a > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
                            for (var l = t, u = t + t; l !== u; ++l)
                                if (n[l] !== n[l + t]) {
                                    o.setValue(n, r);
                                    break
                                }
                        }
                    }, {
                        key: "saveOriginalState",
                        value: function() {
                            var e = this.binding,
                                t = this.buffer,
                                n = this.valueSize,
                                r = n * this._origIndex;
                            e.getValue(t, r);
                            for (var i = n; i !== r; ++i) t[i] = t[r + i % n];
                            this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                        }
                    }, {
                        key: "restoreOriginalState",
                        value: function() {
                            var e = 3 * this.valueSize;
                            this.binding.setValue(this.buffer, e)
                        }
                    }, {
                        key: "_setAdditiveIdentityNumeric",
                        value: function() {
                            for (var e = this._addIndex * this.valueSize, t = e + this.valueSize, n = e; n < t; n++) this.buffer[n] = 0
                        }
                    }, {
                        key: "_setAdditiveIdentityQuaternion",
                        value: function() {
                            this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                        }
                    }, {
                        key: "_setAdditiveIdentityOther",
                        value: function() {
                            for (var e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize, n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n]
                        }
                    }, {
                        key: "_select",
                        value: function(e, t, n, r, i) {
                            if (r >= .5)
                                for (var a = 0; a !== i; ++a) e[t + a] = e[n + a]
                        }
                    }, {
                        key: "_slerp",
                        value: function(e, t, n, r) {
                            ta.slerpFlat(e, t, e, t, e, n, r)
                        }
                    }, {
                        key: "_slerpAdditive",
                        value: function(e, t, n, r, i) {
                            var a = this._workIndex * i;
                            ta.multiplyQuaternionsFlat(e, a, e, t, e, n), ta.slerpFlat(e, t, e, t, e, a, r)
                        }
                    }, {
                        key: "_lerp",
                        value: function(e, t, n, r, i) {
                            for (var a = 1 - r, o = 0; o !== i; ++o) {
                                var s = t + o;
                                e[s] = e[s] * a + e[n + o] * r
                            }
                        }
                    }, {
                        key: "_lerpAdditive",
                        value: function(e, t, n, r, i) {
                            for (var a = 0; a !== i; ++a) {
                                var o = t + a;
                                e[o] = e[o] + e[n + a] * r
                            }
                        }
                    }]), e
                }(),
                sW = RegExp("[\\[\\]\\.:\\/]", "g"),
                sj = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                sq = RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]") + /(WCOD+)?/.source.replace("WCOD", sj) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]") + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]") + "$"),
                sX = ["material", "materials", "bones"],
                sY = function() {
                    function e(t, n, r) {
                        (0, k._)(this, e), this.path = n, this.parsedPath = r || e.parseTrackName(n), this.node = e.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                    return (0, A._)(e, [{
                        key: "_getValue_unavailable",
                        value: function() {}
                    }, {
                        key: "_setValue_unavailable",
                        value: function() {}
                    }, {
                        key: "_getValue_direct",
                        value: function(e, t) {
                            e[t] = this.targetObject[this.propertyName]
                        }
                    }, {
                        key: "_getValue_array",
                        value: function(e, t) {
                            for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) e[t++] = n[r]
                        }
                    }, {
                        key: "_getValue_arrayElement",
                        value: function(e, t) {
                            e[t] = this.resolvedProperty[this.propertyIndex]
                        }
                    }, {
                        key: "_getValue_toArray",
                        value: function(e, t) {
                            this.resolvedProperty.toArray(e, t)
                        }
                    }, {
                        key: "_setValue_direct",
                        value: function(e, t) {
                            this.targetObject[this.propertyName] = e[t]
                        }
                    }, {
                        key: "_setValue_direct_setNeedsUpdate",
                        value: function(e, t) {
                            this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                        }
                    }, {
                        key: "_setValue_direct_setMatrixWorldNeedsUpdate",
                        value: function(e, t) {
                            this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                    }, {
                        key: "_setValue_array",
                        value: function(e, t) {
                            for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++]
                        }
                    }, {
                        key: "_setValue_array_setNeedsUpdate",
                        value: function(e, t) {
                            for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                            this.targetObject.needsUpdate = !0
                        }
                    }, {
                        key: "_setValue_array_setMatrixWorldNeedsUpdate",
                        value: function(e, t) {
                            for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                            this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                    }, {
                        key: "_setValue_arrayElement",
                        value: function(e, t) {
                            this.resolvedProperty[this.propertyIndex] = e[t]
                        }
                    }, {
                        key: "_setValue_arrayElement_setNeedsUpdate",
                        value: function(e, t) {
                            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                        }
                    }, {
                        key: "_setValue_arrayElement_setMatrixWorldNeedsUpdate",
                        value: function(e, t) {
                            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                    }, {
                        key: "_setValue_fromArray",
                        value: function(e, t) {
                            this.resolvedProperty.fromArray(e, t)
                        }
                    }, {
                        key: "_setValue_fromArray_setNeedsUpdate",
                        value: function(e, t) {
                            this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                        }
                    }, {
                        key: "_setValue_fromArray_setMatrixWorldNeedsUpdate",
                        value: function(e, t) {
                            this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                    }, {
                        key: "_getValue_unbound",
                        value: function(e, t) {
                            this.bind(), this.getValue(e, t)
                        }
                    }, {
                        key: "_setValue_unbound",
                        value: function(e, t) {
                            this.bind(), this.setValue(e, t)
                        }
                    }, {
                        key: "bind",
                        value: function() {
                            var t = this.node,
                                n = this.parsedPath,
                                r = n.objectName,
                                i = n.propertyName,
                                a = n.propertyIndex;
                            if (t || (t = e.findNode(this.rootNode, n.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                            if (r) {
                                var o = n.objectIndex;
                                switch (r) {
                                    case "materials":
                                        if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                        if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                        t = t.material.materials;
                                        break;
                                    case "bones":
                                        if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                        t = t.skeleton.bones;
                                        for (var s = 0; s < t.length; s++)
                                            if (t[s].name === o) {
                                                o = s;
                                                break
                                            }
                                        break;
                                    default:
                                        if (void 0 === t[r]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                        t = t[r]
                                }
                                if (void 0 !== o) {
                                    if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                    t = t[o]
                                }
                            }
                            var l = t[i];
                            if (void 0 === l) return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n.nodeName + "." + i + " but it wasn't found.", t);
                            var u = this.Versioning.None;
                            this.targetObject = t, void 0 !== t.needsUpdate ? u = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (u = this.Versioning.MatrixWorldNeedsUpdate);
                            var c = this.BindingType.Direct;
                            if (void 0 !== a) {
                                if ("morphTargetInfluences" === i) {
                                    if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                    if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                                    if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    void 0 !== t.morphTargetDictionary[a] && (a = t.morphTargetDictionary[a])
                                }
                                c = this.BindingType.ArrayElement, this.resolvedProperty = l, this.propertyIndex = a
                            } else void 0 !== l.fromArray && void 0 !== l.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = l) : Array.isArray(l) ? (c = this.BindingType.EntireArray, this.resolvedProperty = l) : this.propertyName = i;
                            this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][u]
                        }
                    }, {
                        key: "unbind",
                        value: function() {
                            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                        }
                    }], [{
                        key: "create",
                        value: function(t, n, r) {
                            return t && t.isAnimationObjectGroup ? new e.Composite(t, n, r) : new e(t, n, r)
                        }
                    }, {
                        key: "sanitizeNodeName",
                        value: function(e) {
                            return e.replace(/\s/g, "_").replace(sW, "")
                        }
                    }, {
                        key: "parseTrackName",
                        value: function(e) {
                            var t = sq.exec(e);
                            if (!t) throw Error("PropertyBinding: Cannot parse trackName: " + e);
                            var n = {
                                    nodeName: t[2],
                                    objectName: t[3],
                                    objectIndex: t[4],
                                    propertyName: t[5],
                                    propertyIndex: t[6]
                                },
                                r = n.nodeName && n.nodeName.lastIndexOf(".");
                            if (void 0 !== r && -1 !== r) {
                                var i = n.nodeName.substring(r + 1); - 1 !== sX.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = i)
                            }
                            if (null === n.propertyName || 0 === n.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                            return n
                        }
                    }, {
                        key: "findNode",
                        value: function(e, t) {
                            if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                            if (e.skeleton) {
                                var n = e.skeleton.getBoneByName(t);
                                if (void 0 !== n) return n
                            }
                            if (e.children) {
                                var r = function(e) {
                                        for (var n = 0; n < e.length; n++) {
                                            var i = e[n];
                                            if (i.name === t || i.uuid === t) return i;
                                            var a = r(i.children);
                                            if (a) return a
                                        }
                                        return null
                                    },
                                    i = r(e.children);
                                if (i) return i
                            }
                            return null
                        }
                    }]), e
                }();
            sY.Composite = function() {
                function e(t, n, r) {
                    (0, k._)(this, e);
                    var i = r || sY.parseTrackName(n);
                    this._targetGroup = t, this._bindings = t.subscribe_(n, i)
                }
                return (0, A._)(e, [{
                    key: "getValue",
                    value: function(e, t) {
                        this.bind();
                        var n = this._targetGroup.nCachedObjects_,
                            r = this._bindings[n];
                        void 0 !== r && r.getValue(e, t)
                    }
                }, {
                    key: "setValue",
                    value: function(e, t) {
                        for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t)
                    }
                }, {
                    key: "bind",
                    value: function() {
                        for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
                    }
                }, {
                    key: "unbind",
                    value: function() {
                        for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
                    }
                }]), e
            }(), sY.prototype.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            }, sY.prototype.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            }, sY.prototype.GetterByBindingType = [sY.prototype._getValue_direct, sY.prototype._getValue_array, sY.prototype._getValue_arrayElement, sY.prototype._getValue_toArray], sY.prototype.SetterByBindingTypeAndVersioning = [
                [sY.prototype._setValue_direct, sY.prototype._setValue_direct_setNeedsUpdate, sY.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                [sY.prototype._setValue_array, sY.prototype._setValue_array_setNeedsUpdate, sY.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                [sY.prototype._setValue_arrayElement, sY.prototype._setValue_arrayElement_setNeedsUpdate, sY.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                [sY.prototype._setValue_fromArray, sY.prototype._setValue_fromArray_setNeedsUpdate, sY.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
            ];
            var sJ = function() {
                    function e(t, n) {
                        var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : n.blendMode;
                        (0, k._)(this, e), this._mixer = t, this._clip = n, this._localRoot = r, this.blendMode = i;
                        for (var a = n.tracks, o = a.length, s = Array(o), l = {
                                endingStart: 2400,
                                endingEnd: 2400
                            }, u = 0; u !== o; ++u) {
                            var c = a[u].createInterpolant(null);
                            s[u] = c, c.settings = l
                        }
                        this._interpolantSettings = l, this._interpolants = s, this._propertyBindings = Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                    }
                    return (0, A._)(e, [{
                        key: "play",
                        value: function() {
                            return this._mixer._activateAction(this), this
                        }
                    }, {
                        key: "stop",
                        value: function() {
                            return this._mixer._deactivateAction(this), this.reset()
                        }
                    }, {
                        key: "reset",
                        value: function() {
                            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                        }
                    }, {
                        key: "isRunning",
                        value: function() {
                            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                        }
                    }, {
                        key: "isScheduled",
                        value: function() {
                            return this._mixer._isActiveAction(this)
                        }
                    }, {
                        key: "startAt",
                        value: function(e) {
                            return this._startTime = e, this
                        }
                    }, {
                        key: "setLoop",
                        value: function(e, t) {
                            return this.loop = e, this.repetitions = t, this
                        }
                    }, {
                        key: "setEffectiveWeight",
                        value: function(e) {
                            return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
                        }
                    }, {
                        key: "getEffectiveWeight",
                        value: function() {
                            return this._effectiveWeight
                        }
                    }, {
                        key: "fadeIn",
                        value: function(e) {
                            return this._scheduleFading(e, 0, 1)
                        }
                    }, {
                        key: "fadeOut",
                        value: function(e) {
                            return this._scheduleFading(e, 1, 0)
                        }
                    }, {
                        key: "crossFadeFrom",
                        value: function(e, t, n) {
                            if (e.fadeOut(t), this.fadeIn(t), n) {
                                var r = this._clip.duration,
                                    i = e._clip.duration;
                                e.warp(1, i / r, t), this.warp(r / i, 1, t)
                            }
                            return this
                        }
                    }, {
                        key: "crossFadeTo",
                        value: function(e, t, n) {
                            return e.crossFadeFrom(this, t, n)
                        }
                    }, {
                        key: "stopFading",
                        value: function() {
                            var e = this._weightInterpolant;
                            return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                        }
                    }, {
                        key: "setEffectiveTimeScale",
                        value: function(e) {
                            return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
                        }
                    }, {
                        key: "getEffectiveTimeScale",
                        value: function() {
                            return this._effectiveTimeScale
                        }
                    }, {
                        key: "setDuration",
                        value: function(e) {
                            return this.timeScale = this._clip.duration / e, this.stopWarping()
                        }
                    }, {
                        key: "syncWith",
                        value: function(e) {
                            return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
                        }
                    }, {
                        key: "halt",
                        value: function(e) {
                            return this.warp(this._effectiveTimeScale, 0, e)
                        }
                    }, {
                        key: "warp",
                        value: function(e, t, n) {
                            var r = this._mixer,
                                i = r.time,
                                a = this.timeScale,
                                o = this._timeScaleInterpolant;
                            null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
                            var s = o.parameterPositions,
                                l = o.sampleValues;
                            return s[0] = i, s[1] = i + n, l[0] = e / a, l[1] = t / a, this
                        }
                    }, {
                        key: "stopWarping",
                        value: function() {
                            var e = this._timeScaleInterpolant;
                            return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                        }
                    }, {
                        key: "getMixer",
                        value: function() {
                            return this._mixer
                        }
                    }, {
                        key: "getClip",
                        value: function() {
                            return this._clip
                        }
                    }, {
                        key: "getRoot",
                        value: function() {
                            return this._localRoot || this._mixer._root
                        }
                    }, {
                        key: "_update",
                        value: function(e, t, n, r) {
                            if (!this.enabled) return void this._updateWeight(e);
                            var i = this._startTime;
                            if (null !== i) {
                                var a = (e - i) * n;
                                if (a < 0 || 0 === n) return;
                                this._startTime = null, t = n * a
                            }
                            t *= this._updateTimeScale(e);
                            var o = this._updateTime(t),
                                s = this._updateWeight(e);
                            if (s > 0) {
                                var l = this._interpolants,
                                    u = this._propertyBindings;
                                if (2501 === this.blendMode)
                                    for (var c = 0, h = l.length; c !== h; ++c) l[c].evaluate(o), u[c].accumulateAdditive(s);
                                else
                                    for (var d = 0, f = l.length; d !== f; ++d) l[d].evaluate(o), u[d].accumulate(r, s)
                            }
                        }
                    }, {
                        key: "_updateWeight",
                        value: function(e) {
                            var t = 0;
                            if (this.enabled) {
                                t = this.weight;
                                var n = this._weightInterpolant;
                                if (null !== n) {
                                    var r = n.evaluate(e)[0];
                                    t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                                }
                            }
                            return this._effectiveWeight = t, t
                        }
                    }, {
                        key: "_updateTimeScale",
                        value: function(e) {
                            var t = 0;
                            if (!this.paused) {
                                t = this.timeScale;
                                var n = this._timeScaleInterpolant;
                                null !== n && (t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t))
                            }
                            return this._effectiveTimeScale = t, t
                        }
                    }, {
                        key: "_updateTime",
                        value: function(e) {
                            var t = this._clip.duration,
                                n = this.loop,
                                r = this.time + e,
                                i = this._loopCount,
                                a = 2202 === n;
                            if (0 === e) return -1 === i ? r : a && 1 == (1 & i) ? t - r : r;
                            if (2200 === n) {
                                -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                                e: {
                                    if (r >= t) r = t;
                                    else {
                                        if (!(r < 0)) {
                                            this.time = r;
                                            break e
                                        }
                                        r = 0
                                    }
                                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                    this.time = r,
                                    this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: e < 0 ? -1 : 1
                                    })
                                }
                            } else {
                                if (-1 === i && (e >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), r >= t || r < 0) {
                                    var o = Math.floor(r / t);
                                    r -= t * o, i += Math.abs(o);
                                    var s = this.repetitions - i;
                                    if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: e > 0 ? 1 : -1
                                    });
                                    else {
                                        if (1 === s) {
                                            var l = e < 0;
                                            this._setEndings(l, !l, a)
                                        } else this._setEndings(!1, !1, a);
                                        this._loopCount = i, this.time = r, this._mixer.dispatchEvent({
                                            type: "loop",
                                            action: this,
                                            loopDelta: o
                                        })
                                    }
                                } else this.time = r;
                                if (a && 1 == (1 & i)) return t - r
                            }
                            return r
                        }
                    }, {
                        key: "_setEndings",
                        value: function(e, t, n) {
                            var r = this._interpolantSettings;
                            n ? (r.endingStart = 2401, r.endingEnd = 2401) : (r.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, r.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
                        }
                    }, {
                        key: "_scheduleFading",
                        value: function(e, t, n) {
                            var r = this._mixer,
                                i = r.time,
                                a = this._weightInterpolant;
                            null === a && (a = r._lendControlInterpolant(), this._weightInterpolant = a);
                            var o = a.parameterPositions,
                                s = a.sampleValues;
                            return o[0] = i, s[0] = t, o[1] = i + e, s[1] = n, this
                        }
                    }]), e
                }(),
                sZ = function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t))._root = e, n._initMemoryManager(), n._accuIndex = 0, n.time = 0, n.timeScale = 1, n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "_bindAction",
                        value: function(e, t) {
                            var n = e._localRoot || this._root,
                                r = e._clip.tracks,
                                i = r.length,
                                a = e._propertyBindings,
                                o = e._interpolants,
                                s = n.uuid,
                                l = this._bindingsByRootAndName,
                                u = l[s];
                            void 0 === u && (u = {}, l[s] = u);
                            for (var c = 0; c !== i; ++c) {
                                var h = r[c],
                                    d = h.name,
                                    f = u[d];
                                if (void 0 !== f) a[c] = f;
                                else {
                                    if (void 0 !== (f = a[c])) {
                                        null === f._cacheIndex && (++f.referenceCount, this._addInactiveBinding(f, s, d));
                                        continue
                                    }
                                    var p = t && t._propertyBindings[c].binding.parsedPath;
                                    f = new sG(sY.create(n, d, p), h.ValueTypeName, h.getValueSize()), ++f.referenceCount, this._addInactiveBinding(f, s, d), a[c] = f
                                }
                                o[c].resultBuffer = f.buffer
                            }
                        }
                    }, {
                        key: "_activateAction",
                        value: function(e) {
                            if (!this._isActiveAction(e)) {
                                if (null === e._cacheIndex) {
                                    var t = (e._localRoot || this._root).uuid,
                                        n = e._clip.uuid,
                                        r = this._actionsByClip[n];
                                    this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t)
                                }
                                for (var i = e._propertyBindings, a = 0, o = i.length; a !== o; ++a) {
                                    var s = i[a];
                                    0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                                }
                                this._lendAction(e)
                            }
                        }
                    }, {
                        key: "_deactivateAction",
                        value: function(e) {
                            if (this._isActiveAction(e)) {
                                for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                                    var i = t[n];
                                    0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                                }
                                this._takeBackAction(e)
                            }
                        }
                    }, {
                        key: "_initMemoryManager",
                        value: function() {
                            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                            var e = this;
                            this.stats = {
                                actions: {
                                    get total() {
                                        return e._actions.length
                                    },
                                    get inUse() {
                                        return e._nActiveActions
                                    }
                                },
                                bindings: {
                                    get total() {
                                        return e._bindings.length
                                    },
                                    get inUse() {
                                        return e._nActiveBindings
                                    }
                                },
                                controlInterpolants: {
                                    get total() {
                                        return e._controlInterpolants.length
                                    },
                                    get inUse() {
                                        return e._nActiveControlInterpolants
                                    }
                                }
                            }
                        }
                    }, {
                        key: "_isActiveAction",
                        value: function(e) {
                            var t = e._cacheIndex;
                            return null !== t && t < this._nActiveActions
                        }
                    }, {
                        key: "_addInactiveAction",
                        value: function(e, t, n) {
                            var r = this._actions,
                                i = this._actionsByClip,
                                a = i[t];
                            if (void 0 === a) a = {
                                knownActions: [e],
                                actionByRoot: {}
                            }, e._byClipCacheIndex = 0, i[t] = a;
                            else {
                                var o = a.knownActions;
                                e._byClipCacheIndex = o.length, o.push(e)
                            }
                            e._cacheIndex = r.length, r.push(e), a.actionByRoot[n] = e
                        }
                    }, {
                        key: "_removeInactiveAction",
                        value: function(e) {
                            var t = this._actions,
                                n = t[t.length - 1],
                                r = e._cacheIndex;
                            n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null;
                            var i = e._clip.uuid,
                                a = this._actionsByClip,
                                o = a[i],
                                s = o.knownActions,
                                l = s[s.length - 1],
                                u = e._byClipCacheIndex;
                            l._byClipCacheIndex = u, s[u] = l, s.pop(), e._byClipCacheIndex = null, delete o.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete a[i], this._removeInactiveBindingsForAction(e)
                        }
                    }, {
                        key: "_removeInactiveBindingsForAction",
                        value: function(e) {
                            for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                                var i = t[n];
                                0 == --i.referenceCount && this._removeInactiveBinding(i)
                            }
                        }
                    }, {
                        key: "_lendAction",
                        value: function(e) {
                            var t = this._actions,
                                n = e._cacheIndex,
                                r = this._nActiveActions++,
                                i = t[r];
                            e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                        }
                    }, {
                        key: "_takeBackAction",
                        value: function(e) {
                            var t = this._actions,
                                n = e._cacheIndex,
                                r = --this._nActiveActions,
                                i = t[r];
                            e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                        }
                    }, {
                        key: "_addInactiveBinding",
                        value: function(e, t, n) {
                            var r = this._bindingsByRootAndName,
                                i = this._bindings,
                                a = r[t];
                            void 0 === a && (a = {}, r[t] = a), a[n] = e, e._cacheIndex = i.length, i.push(e)
                        }
                    }, {
                        key: "_removeInactiveBinding",
                        value: function(e) {
                            var t = this._bindings,
                                n = e.binding,
                                r = n.rootNode.uuid,
                                i = n.path,
                                a = this._bindingsByRootAndName,
                                o = a[r],
                                s = t[t.length - 1],
                                l = e._cacheIndex;
                            s._cacheIndex = l, t[l] = s, t.pop(), delete o[i], 0 === Object.keys(o).length && delete a[r]
                        }
                    }, {
                        key: "_lendBinding",
                        value: function(e) {
                            var t = this._bindings,
                                n = e._cacheIndex,
                                r = this._nActiveBindings++,
                                i = t[r];
                            e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                        }
                    }, {
                        key: "_takeBackBinding",
                        value: function(e) {
                            var t = this._bindings,
                                n = e._cacheIndex,
                                r = --this._nActiveBindings,
                                i = t[r];
                            e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                        }
                    }, {
                        key: "_lendControlInterpolant",
                        value: function() {
                            var e = this._controlInterpolants,
                                t = this._nActiveControlInterpolants++,
                                n = e[t];
                            return void 0 === n && ((n = new si(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, e[t] = n), n
                        }
                    }, {
                        key: "_takeBackControlInterpolant",
                        value: function(e) {
                            var t = this._controlInterpolants,
                                n = e.__cacheIndex,
                                r = --this._nActiveControlInterpolants,
                                i = t[r];
                            e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i
                        }
                    }, {
                        key: "clipAction",
                        value: function(e, t, n) {
                            var r = t || this._root,
                                i = r.uuid,
                                a = "string" == typeof e ? sp.findByName(r, e) : e,
                                o = null !== a ? a.uuid : e,
                                s = this._actionsByClip[o],
                                l = null;
                            if (void 0 === n && (n = null !== a ? a.blendMode : 2500), void 0 !== s) {
                                var u = s.actionByRoot[i];
                                if (void 0 !== u && u.blendMode === n) return u;
                                l = s.knownActions[0], null === a && (a = l._clip)
                            }
                            if (null === a) return null;
                            var c = new sJ(this, a, t, n);
                            return this._bindAction(c, l), this._addInactiveAction(c, o, i), c
                        }
                    }, {
                        key: "existingAction",
                        value: function(e, t) {
                            var n = t || this._root,
                                r = n.uuid,
                                i = "string" == typeof e ? sp.findByName(n, e) : e,
                                a = i ? i.uuid : e,
                                o = this._actionsByClip[a];
                            return void 0 !== o && o.actionByRoot[r] || null
                        }
                    }, {
                        key: "stopAllAction",
                        value: function() {
                            for (var e = this._actions, t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
                            return this
                        }
                    }, {
                        key: "update",
                        value: function(e) {
                            e *= this.timeScale;
                            for (var t = this._actions, n = this._nActiveActions, r = this.time += e, i = Math.sign(e), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) t[o]._update(r, e, i, a);
                            for (var s = this._bindings, l = this._nActiveBindings, u = 0; u !== l; ++u) s[u].apply(a);
                            return this
                        }
                    }, {
                        key: "setTime",
                        value: function(e) {
                            this.time = 0;
                            for (var t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                            return this.update(e)
                        }
                    }, {
                        key: "getRoot",
                        value: function() {
                            return this._root
                        }
                    }, {
                        key: "uncacheClip",
                        value: function(e) {
                            var t = this._actions,
                                n = e.uuid,
                                r = this._actionsByClip,
                                i = r[n];
                            if (void 0 !== i) {
                                for (var a = i.knownActions, o = 0, s = a.length; o !== s; ++o) {
                                    var l = a[o];
                                    this._deactivateAction(l);
                                    var u = l._cacheIndex,
                                        c = t[t.length - 1];
                                    l._cacheIndex = null, l._byClipCacheIndex = null, c._cacheIndex = u, t[u] = c, t.pop(), this._removeInactiveBindingsForAction(l)
                                }
                                delete r[n]
                            }
                        }
                    }, {
                        key: "uncacheRoot",
                        value: function(e) {
                            var t = e.uuid,
                                n = this._actionsByClip;
                            for (var r in n) {
                                var i = n[r].actionByRoot[t];
                                void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                            }
                            var a = this._bindingsByRootAndName[t];
                            if (void 0 !== a)
                                for (var o in a) {
                                    var s = a[o];
                                    s.restoreOriginalState(), this._removeInactiveBinding(s)
                                }
                        }
                    }, {
                        key: "uncacheAction",
                        value: function(e, t) {
                            var n = this.existingAction(e, t);
                            null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                        }
                    }]), t
                }(eW);

            function sK(e, t) {
                return e.distance - t.distance
            }

            function sQ(e, t, n, r) {
                if (e.layers.test(t.layers) && e.raycast(t, n), !0 === r)
                    for (var i = e.children, a = 0, o = i.length; a < o; a++) sQ(i[a], t, n, !0)
            }
            sZ.prototype._controlInterpolantsResultBuffer = new Float32Array(1),
                function(e) {
                    function t(e, n) {
                        var r, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                        return (0, k._)(this, t), (r = (0, E._)(this, t, [e, n])).meshPerAttribute = i, r
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
                        }
                    }, {
                        key: "clone",
                        value: function(e) {
                            var n = L((0, C._)(t.prototype), "clone", this).call(this, e);
                            return n.meshPerAttribute = this.meshPerAttribute, n
                        }
                    }, {
                        key: "toJSON",
                        value: function(e) {
                            var n = L((0, C._)(t.prototype), "toJSON", this).call(this, e);
                            return n.isInstancedInterleavedBuffer = !0, n.meshPerAttribute = this.meshPerAttribute, n
                        }
                    }]), t
                }(aL).prototype.isInstancedInterleavedBuffer = !0;
            var s$ = function() {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        return (0, k._)(this, e), this.radius = t, this.phi = n, this.theta = r, this
                    }
                    return (0, A._)(e, [{
                        key: "set",
                        value: function(e, t, n) {
                            return this.radius = e, this.phi = t, this.theta = n, this
                        }
                    }, {
                        key: "copy",
                        value: function(e) {
                            return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
                        }
                    }, {
                        key: "makeSafe",
                        value: function() {
                            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                        }
                    }, {
                        key: "setFromVector3",
                        value: function(e) {
                            return this.setFromCartesianCoords(e.x, e.y, e.z)
                        }
                    }, {
                        key: "setFromCartesianCoords",
                        value: function(e, t, n) {
                            return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(eK(t / this.radius, -1, 1))), this
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return (new this.constructor).copy(this)
                        }
                    }]), e
                }(),
                s0 = new to,
                s1 = new tF,
                s2 = new tF,
                s3 = new Float32Array(1),
                s4 = new Int32Array(s3.buffer),
                s5 = function() {
                    function e() {
                        (0, k._)(this, e)
                    }
                    return (0, A._)(e, null, [{
                        key: "toHalfFloat",
                        value: function(e) {
                            e > 65504 && (console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."), e = 65504), s3[0] = e;
                            var t = s4[0],
                                n = t >> 16 & 32768,
                                r = t >> 12 & 2047,
                                i = t >> 23 & 255;
                            return i < 103 ? n : i > 142 ? (n |= 31744, n |= (255 == i ? 0 : 1) && 8388607 & t) : i < 113 ? (r |= 2048, n |= (r >> 114 - i) + (r >> 113 - i & 1)) : (n |= i - 112 << 10 | r >> 1, n += 1 & r)
                        }
                    }]), e
                }();
            o_.create = function(e, t) {
                    return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(o_.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
                }, oU.prototype.fromPoints = function(e) {
                    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
                },
                function(e) {
                    function t() {
                        var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10,
                            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10,
                            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 4473924,
                            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8947848;
                        (0, k._)(this, t), i = new ny(i), a = new ny(a);
                        for (var o = r / 2, s = n / r, l = n / 2, u = [], c = [], h = 0, d = 0, f = -l; h <= r; h++, f += s) {
                            u.push(-l, 0, f, l, 0, f), u.push(f, 0, -l, f, 0, l);
                            var p = h === o ? i : a;
                            p.toArray(c, d), d += 3, p.toArray(c, d), d += 3, p.toArray(c, d), d += 3, p.toArray(c, d), d += 3
                        }
                        var m = new nI;
                        return m.setAttribute("position", new nT(u, 3)), m.setAttribute("color", new nT(c, 3)), (e = (0, E._)(this, t, [m, new oe({
                            vertexColors: !0,
                            toneMapped: !1
                        })])).type = "GridHelper", e
                    }
                    return (0, P._)(t, e), t
                }(ou).prototype.setColors = function() {
                    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
                },
                function(e) {
                    function t(e) {
                        (0, k._)(this, t);
                        for (var n, r = function e(t) {
                                var n = [];
                                t && t.isBone && n.push(t);
                                for (var r = 0; r < t.children.length; r++) n.push.apply(n, e(t.children[r]));
                                return n
                            }(e), i = new nI, a = [], o = [], s = new ny(0, 0, 1), l = new ny(0, 1, 0), u = 0; u < r.length; u++) {
                            var c = r[u];
                            c.parent && c.parent.isBone && (a.push(0, 0, 0), a.push(0, 0, 0), o.push(s.r, s.g, s.b), o.push(l.r, l.g, l.b))
                        }
                        return i.setAttribute("position", new nT(a, 3)), i.setAttribute("color", new nT(o, 3)), (n = (0, E._)(this, t, [i, new oe({
                            vertexColors: !0,
                            depthTest: !1,
                            depthWrite: !1,
                            toneMapped: !1,
                            transparent: !0
                        })])).type = "SkeletonHelper", n.isSkeletonHelper = !0, n.root = e, n.bones = r, n.matrix = e.matrixWorld, n.matrixAutoUpdate = !1, n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "updateMatrixWorld",
                        value: function(e) {
                            var n = this.bones,
                                r = this.geometry,
                                i = r.getAttribute("position");
                            s2.copy(this.root.matrixWorld).invert();
                            for (var a = 0, o = 0; a < n.length; a++) {
                                var s = n[a];
                                s.parent && s.parent.isBone && (s1.multiplyMatrices(s2, s.matrixWorld), s0.setFromMatrixPosition(s1), i.setXYZ(o, s0.x, s0.y, s0.z), s1.multiplyMatrices(s2, s.parent.matrixWorld), s0.setFromMatrixPosition(s1), i.setXYZ(o + 1, s0.x, s0.y, s0.z), o += 2)
                            }
                            r.getAttribute("position").needsUpdate = !0, L((0, C._)(t.prototype), "updateMatrixWorld", this).call(this, e)
                        }
                    }]), t
                }(ou).prototype.update = function() {
                    console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
                }, sg.prototype.extractUrlBase = function(e) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), sz.extractUrlBase(e)
                }, sg.Handlers = {
                    add: function() {
                        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                    },
                    get: function() {
                        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                    }
                }, tu.prototype.center = function(e) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
                }, tu.prototype.empty = function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                }, tu.prototype.isIntersectionBox = function(e) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                }, tu.prototype.isIntersectionSphere = function(e) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
                }, tu.prototype.size = function(e) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
                }, tA.prototype.empty = function() {
                    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                }, ra.prototype.setFromMatrix = function(e) {
                    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e)
                }, e5.prototype.flattenToArrayOffset = function(e, t) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
                }, e5.prototype.multiplyVector3 = function(e) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
                }, e5.prototype.multiplyVector3Array = function() {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                }, e5.prototype.applyToBufferAttribute = function(e) {
                    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
                }, e5.prototype.applyToVector3Array = function() {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }, e5.prototype.getInverse = function(e) {
                    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert()
                }, tF.prototype.extractPosition = function(e) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
                }, tF.prototype.flattenToArrayOffset = function(e, t) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
                }, tF.prototype.getPosition = function() {
                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new to).setFromMatrixColumn(this, 3)
                }, tF.prototype.setRotationFromQuaternion = function(e) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
                }, tF.prototype.multiplyToArray = function() {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                }, tF.prototype.multiplyVector3 = function(e) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                }, tF.prototype.multiplyVector4 = function(e) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                }, tF.prototype.multiplyVector3Array = function() {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                }, tF.prototype.rotateAxis = function(e) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
                }, tF.prototype.crossVector = function(e) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                }, tF.prototype.translate = function() {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                }, tF.prototype.rotateX = function() {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                }, tF.prototype.rotateY = function() {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                }, tF.prototype.rotateZ = function() {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                }, tF.prototype.rotateByAxis = function() {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                }, tF.prototype.applyToBufferAttribute = function(e) {
                    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                }, tF.prototype.applyToVector3Array = function() {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                }, tF.prototype.makeFrustum = function(e, t, n, r, i, a) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, r, n, i, a)
                }, tF.prototype.getInverse = function(e) {
                    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert()
                }, rn.prototype.isIntersectionLine = function(e) {
                    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
                }, ta.prototype.multiplyVector3 = function(e) {
                    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
                }, ta.prototype.inverse = function() {
                    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
                }, tN.prototype.isIntersectionBox = function(e) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                }, tN.prototype.isIntersectionPlane = function(e) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
                }, tN.prototype.isIntersectionSphere = function(e) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
                }, nu.prototype.area = function() {
                    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                }, nu.prototype.barycoordFromPoint = function(e, t) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
                }, nu.prototype.midpoint = function(e) {
                    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
                }, nu.prototypenormal = function(e) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
                }, nu.prototype.plane = function(e) {
                    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
                }, nu.barycoordFromPoint = function(e, t, n, r, i) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), nu.getBarycoord(e, t, n, r, i)
                }, nu.normal = function(e, t, n, r) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), nu.getNormal(e, t, n, r)
                }, oB.prototype.extractAllPoints = function(e) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
                }, oB.prototype.extrude = function(e) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new o5(this, e)
                }, oB.prototype.makeGeometry = function(e) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new o8(this, e)
                }, e4.prototype.fromAttribute = function(e, t, n) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
                }, e4.prototype.distanceToManhattan = function(e) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
                }, e4.prototype.lengthManhattan = function() {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }, to.prototype.setEulerFromRotationMatrix = function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                }, to.prototype.setEulerFromQuaternion = function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                }, to.prototype.getPositionFromMatrix = function(e) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
                }, to.prototype.getScaleFromMatrix = function(e) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
                }, to.prototype.getColumnFromMatrix = function(e, t) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
                }, to.prototype.applyProjection = function(e) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
                }, to.prototype.fromAttribute = function(e, t, n) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
                }, to.prototype.distanceToManhattan = function(e) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
                }, to.prototype.lengthManhattan = function() {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }, tn.prototype.fromAttribute = function(e, t, n) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
                }, tn.prototype.lengthManhattan = function() {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }, t7.prototype.getChildByName = function(e) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
                }, t7.prototype.renderDepth = function() {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                }, t7.prototype.translate = function(e, t) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
                }, t7.prototype.getWorldRotation = function() {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                }, t7.prototype.applyMatrix = function(e) {
                    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
                }, Object.defineProperties(t7.prototype, {
                    eulerOrder: {
                        get: function() {
                            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                        },
                        set: function(e) {
                            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
                        }
                    },
                    useQuaternion: {
                        get: function() {
                            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                        },
                        set: function() {
                            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                        }
                    }
                }), nK.prototype.setDrawMode = function() {
                    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }, Object.defineProperties(nK.prototype, {
                    drawMode: {
                        get: function() {
                            return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                        },
                        set: function() {
                            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                        }
                    }
                }), a$.prototype.initBones = function() {
                    console.error("THREE.SkinnedMesh: initBones() has been removed.")
                }, n5.prototype.setLens = function(e, t) {
                    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
                }, Object.defineProperties(sS.prototype, {
                    onlyShadow: {
                        set: function() {
                            console.warn("THREE.Light: .onlyShadow has been removed.")
                        }
                    },
                    shadowCameraFov: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
                        }
                    },
                    shadowCameraLeft: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
                        }
                    },
                    shadowCameraRight: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
                        }
                    },
                    shadowCameraTop: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
                        }
                    },
                    shadowCameraBottom: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
                        }
                    },
                    shadowCameraNear: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
                        }
                    },
                    shadowCameraFar: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
                        }
                    },
                    shadowCameraVisible: {
                        set: function() {
                            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                        }
                    },
                    shadowBias: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
                        }
                    },
                    shadowDarkness: {
                        set: function() {
                            console.warn("THREE.Light: .shadowDarkness has been removed.")
                        }
                    },
                    shadowMapWidth: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
                        }
                    },
                    shadowMapHeight: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
                        }
                    }
                }), Object.defineProperties(nw.prototype, {
                    length: {
                        get: function() {
                            return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                        }
                    },
                    dynamic: {
                        get: function() {
                            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 35048 === this.usage
                        },
                        set: function() {
                            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048)
                        }
                    }
                }), nw.prototype.setDynamic = function(e) {
                    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? 35048 : 35044), this
                }, nw.prototype.copyIndicesArray = function() {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                }, nw.prototype.setArray = function() {
                    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                }, nI.prototype.addIndex = function(e) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
                }, nI.prototype.addAttribute = function(e, t) {
                    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new nw(arguments[1], arguments[2])))
                }, nI.prototype.addDrawCall = function(e, t, n) {
                    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
                }, nI.prototype.clearDrawCalls = function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                }, nI.prototype.computeOffsets = function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }, nI.prototype.removeAttribute = function(e) {
                    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e)
                }, nI.prototype.applyMatrix = function(e) {
                    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
                }, Object.defineProperties(nI.prototype, {
                    drawcalls: {
                        get: function() {
                            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                        }
                    },
                    offsets: {
                        get: function() {
                            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                        }
                    }
                }), aL.prototype.setDynamic = function(e) {
                    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? 35048 : 35044), this
                }, aL.prototype.setArray = function() {
                    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                }, o5.prototype.getArrays = function() {
                    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
                }, o5.prototype.addShapeList = function() {
                    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
                }, o5.prototype.addShape = function() {
                    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
                }, aC.prototype.dispose = function() {
                    console.error("THREE.Scene: .dispose() has been removed.")
                }, Object.defineProperties(nh.prototype, {
                    wrapAround: {
                        get: function() {
                            console.warn("THREE.Material: .wrapAround has been removed.")
                        },
                        set: function() {
                            console.warn("THREE.Material: .wrapAround has been removed.")
                        }
                    },
                    overdraw: {
                        get: function() {
                            console.warn("THREE.Material: .overdraw has been removed.")
                        },
                        set: function() {
                            console.warn("THREE.Material: .overdraw has been removed.")
                        }
                    },
                    wrapRGB: {
                        get: function() {
                            return console.warn("THREE.Material: .wrapRGB has been removed."), new ny
                        }
                    },
                    shading: {
                        get: function() {
                            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                        },
                        set: function(e) {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e
                        }
                    },
                    stencilMask: {
                        get: function() {
                            return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                        },
                        set: function(e) {
                            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e
                        }
                    },
                    vertexTangents: {
                        get: function() {
                            console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                        },
                        set: function() {
                            console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                        }
                    }
                }), Object.defineProperties(n3.prototype, {
                    derivatives: {
                        get: function() {
                            return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                        },
                        set: function(e) {
                            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
                        }
                    }
                }), aR.prototype.clearTarget = function(e, t, n, r) {
                    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, r)
                }, aR.prototype.animate = function(e) {
                    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
                }, aR.prototype.getCurrentRenderTarget = function() {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                }, aR.prototype.getMaxAnisotropy = function() {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                }, aR.prototype.getPrecision = function() {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                }, aR.prototype.resetGLState = function() {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                }, aR.prototype.supportsFloatTextures = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                }, aR.prototype.supportsHalfFloatTextures = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                }, aR.prototype.supportsStandardDerivatives = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                }, aR.prototype.supportsCompressedTextureS3TC = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                }, aR.prototype.supportsCompressedTexturePVRTC = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                }, aR.prototype.supportsBlendMinMax = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                }, aR.prototype.supportsVertexTextures = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                }, aR.prototype.supportsInstancedArrays = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                }, aR.prototype.enableScissorTest = function(e) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
                }, aR.prototype.initMaterial = function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                }, aR.prototype.addPrePlugin = function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                }, aR.prototype.addPostPlugin = function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                }, aR.prototype.updateShadowMap = function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                }, aR.prototype.setFaceCulling = function() {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                }, aR.prototype.allocTextureUnit = function() {
                    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
                }, aR.prototype.setTexture = function() {
                    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
                }, aR.prototype.setTexture2D = function() {
                    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
                }, aR.prototype.setTextureCube = function() {
                    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
                }, aR.prototype.getActiveMipMapLevel = function() {
                    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
                }, Object.defineProperties(aR.prototype, {
                    shadowMapEnabled: {
                        get: function() {
                            return this.shadowMap.enabled
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
                        }
                    },
                    shadowMapType: {
                        get: function() {
                            return this.shadowMap.type
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
                        }
                    },
                    shadowMapCullFace: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    context: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                        }
                    },
                    vr: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                        }
                    },
                    gammaInput: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                        }
                    },
                    gammaOutput: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? 3001 : 3e3
                        }
                    },
                    toneMappingWhitePoint: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                        }
                    },
                    gammaFactor: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
                        }
                    }
                }), Object.defineProperties(ay.prototype, {
                    cullFace: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    renderReverseSided: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    renderSingleSided: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                        }
                    }
                }), Object.defineProperties(tr.prototype, {
                    wrapS: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
                        }
                    },
                    wrapT: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
                        }
                    },
                    magFilter: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
                        }
                    },
                    minFilter: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
                        }
                    },
                    anisotropy: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
                        }
                    },
                    offset: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
                        }
                    },
                    repeat: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
                        }
                    },
                    format: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
                        }
                    },
                    type: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
                        }
                    },
                    generateMipmaps: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
                        }
                    }
                }),
                function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t)).type = "Audio", n.listener = e, n.context = e.context, n.gain = n.context.createGain(), n.gain.connect(e.getInput()), n.autoplay = !1, n.buffer = null, n.detune = 0, n.loop = !1, n.loopStart = 0, n.loopEnd = 0, n.offset = 0, n.duration = void 0, n.playbackRate = 1, n.isPlaying = !1, n.hasPlaybackControl = !0, n.source = null, n.sourceType = "empty", n._startedAt = 0, n._progress = 0, n._connected = !1, n.filters = [], n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "getOutput",
                        value: function() {
                            return this.gain
                        }
                    }, {
                        key: "setNodeSource",
                        value: function(e) {
                            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
                        }
                    }, {
                        key: "setMediaElementSource",
                        value: function(e) {
                            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
                        }
                    }, {
                        key: "setMediaStreamSource",
                        value: function(e) {
                            return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
                        }
                    }, {
                        key: "setBuffer",
                        value: function(e) {
                            return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
                        }
                    }, {
                        key: "play",
                        value: function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                            if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                            if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                            this._startedAt = this.context.currentTime + e;
                            var t = this.context.createBufferSource();
                            return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                        }
                    }, {
                        key: "pause",
                        value: function() {
                            if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                            console.warn("THREE.Audio: this Audio has no playback control.")
                        }
                    }, {
                        key: "stop",
                        value: function() {
                            if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                            console.warn("THREE.Audio: this Audio has no playback control.")
                        }
                    }, {
                        key: "connect",
                        value: function() {
                            if (this.filters.length > 0) {
                                this.source.connect(this.filters[0]);
                                for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                                this.filters[this.filters.length - 1].connect(this.getOutput())
                            } else this.source.connect(this.getOutput());
                            return this._connected = !0, this
                        }
                    }, {
                        key: "disconnect",
                        value: function() {
                            if (this.filters.length > 0) {
                                this.source.disconnect(this.filters[0]);
                                for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                                this.filters[this.filters.length - 1].disconnect(this.getOutput())
                            } else this.source.disconnect(this.getOutput());
                            return this._connected = !1, this
                        }
                    }, {
                        key: "getFilters",
                        value: function() {
                            return this.filters
                        }
                    }, {
                        key: "setFilters",
                        value: function(e) {
                            return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
                        }
                    }, {
                        key: "setDetune",
                        value: function(e) {
                            if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                        }
                    }, {
                        key: "getDetune",
                        value: function() {
                            return this.detune
                        }
                    }, {
                        key: "getFilter",
                        value: function() {
                            return this.getFilters()[0]
                        }
                    }, {
                        key: "setFilter",
                        value: function(e) {
                            return this.setFilters(e ? [e] : [])
                        }
                    }, {
                        key: "setPlaybackRate",
                        value: function(e) {
                            if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                            console.warn("THREE.Audio: this Audio has no playback control.")
                        }
                    }, {
                        key: "getPlaybackRate",
                        value: function() {
                            return this.playbackRate
                        }
                    }, {
                        key: "onEnded",
                        value: function() {
                            this.isPlaying = !1
                        }
                    }, {
                        key: "getLoop",
                        value: function() {
                            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                        }
                    }, {
                        key: "setLoop",
                        value: function(e) {
                            if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                            console.warn("THREE.Audio: this Audio has no playback control.")
                        }
                    }, {
                        key: "setLoopStart",
                        value: function(e) {
                            return this.loopStart = e, this
                        }
                    }, {
                        key: "setLoopEnd",
                        value: function(e) {
                            return this.loopEnd = e, this
                        }
                    }, {
                        key: "getVolume",
                        value: function() {
                            return this.gain.gain.value
                        }
                    }, {
                        key: "setVolume",
                        value: function(e) {
                            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                        }
                    }]), t
                }(t7).prototype.load = function(e) {
                    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                    var t = this;
                    return (new sV).load(e, function(e) {
                        t.setBuffer(e)
                    }), this
                }, n6.prototype.updateCubeMap = function(e, t) {
                    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
                }, n6.prototype.clear = function(e, t, n, r) {
                    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(e, t, n, r)
                }, e7.crossOrigin = void 0, e7.loadTexture = function(e, t, n, r) {
                    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                    var i = new sM;
                    i.setCrossOrigin(this.crossOrigin);
                    var a = i.load(e, n, void 0, r);
                    return t && (a.mapping = t), a
                }, e7.loadTextureCube = function(e, t, n, r) {
                    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                    var i = new sb;
                    i.setCrossOrigin(this.crossOrigin);
                    var a = i.load(e, n, void 0, r);
                    return t && (a.mapping = t), a
                }, e7.loadCompressedTexture = function() {
                    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
                }, e7.loadCompressedTextureCube = function() {
                    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                    detail: {
                        revision: "136"
                    }
                })), window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "136";
            var s6 = null != navigator.xr && null != self.XRSession && null != navigator.xr.isSessionSupported,
                s8 = s6 && self.XRSession.prototype.requestHitTestSource,
                s7 = null != self.ResizeObserver,
                s9 = null != self.IntersectionObserver;
            (function() {
                var e = navigator.userAgent || navigator.vendor || self.opera;
                /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0, 4))
            })(), /\bCrOS\b/.test(navigator.userAgent);
            var le = /android/i.test(navigator.userAgent),
                lt = /iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1,
                ln = function() {
                    var e = document.createElement("a");
                    return !!(e.relList && e.relList.supports && e.relList.supports("ar"))
                }();
            /Safari\//.test(navigator.userAgent);
            var lr = /firefox/i.test(navigator.userAgent),
                li = /OculusBrowser/.test(navigator.userAgent);
            lt && /CriOS\//.test(navigator.userAgent);
            var la = le && !lr && !li,
                lo = eA(W(), eA(H()), eA(V()), eA(G())),
                ls = new WeakMap;

            function ll() {
                var e, t;
                onmessage = function(n) {
                    var r = n.data;
                    switch (r.type) {
                        case "init":
                            e = r.decoderConfig, t = new Promise(function(t) {
                                e.onModuleLoaded = function(e) {
                                    t({
                                        draco: e
                                    })
                                }, DracoDecoderModule(e)
                            });
                            break;
                        case "decode":
                            var i = r.buffer,
                                a = r.taskConfig;
                            t.then(function(e) {
                                var t = e.draco,
                                    n = new t.Decoder,
                                    o = new t.DecoderBuffer;
                                o.Init(new Int8Array(i), i.byteLength);
                                try {
                                    var s = function(e, t, n, r) {
                                            var i, a, o = r.attributeIDs,
                                                s = r.attributeTypes,
                                                l = t.GetEncodedGeometryType(n);
                                            if (l === e.TRIANGULAR_MESH) i = new e.Mesh, a = t.DecodeBufferToMesh(n, i);
                                            else {
                                                if (l !== e.POINT_CLOUD) throw Error("THREE.DRACOLoader: Unexpected geometry type.");
                                                i = new e.PointCloud, a = t.DecodeBufferToPointCloud(n, i)
                                            }
                                            if (!a.ok() || 0 === i.ptr) throw Error("THREE.DRACOLoader: Decoding failed: " + a.error_msg());
                                            var u = {
                                                index: null,
                                                attributes: []
                                            };
                                            for (var c in o) {
                                                var h = self[s[c]],
                                                    d = void 0,
                                                    f = void 0;
                                                if (r.useUniqueIDs) f = o[c], d = t.GetAttributeByUniqueId(i, f);
                                                else {
                                                    if (f = t.GetAttributeId(i, e[o[c]]), -1 === f) continue;
                                                    d = t.GetAttribute(i, f)
                                                }
                                                u.attributes.push(function(e, t, n, r, i, a) {
                                                    var o = a.num_components(),
                                                        s = n.num_points() * o,
                                                        l = s * i.BYTES_PER_ELEMENT,
                                                        u = function(e, t) {
                                                            switch (t) {
                                                                case Float32Array:
                                                                    return e.DT_FLOAT32;
                                                                case Int8Array:
                                                                    return e.DT_INT8;
                                                                case Int16Array:
                                                                    return e.DT_INT16;
                                                                case Int32Array:
                                                                    return e.DT_INT32;
                                                                case Uint8Array:
                                                                    return e.DT_UINT8;
                                                                case Uint16Array:
                                                                    return e.DT_UINT16;
                                                                case Uint32Array:
                                                                    return e.DT_UINT32
                                                            }
                                                        }(e, i),
                                                        c = e._malloc(l);
                                                    t.GetAttributeDataArrayForAllPoints(n, a, u, l, c);
                                                    var h = new i(e.HEAPF32.buffer, c, s).slice();
                                                    return e._free(c), {
                                                        name: r,
                                                        array: h,
                                                        itemSize: o
                                                    }
                                                }(e, t, i, c, h, d))
                                            }
                                            return l === e.TRIANGULAR_MESH && (u.index = function(e, t, n) {
                                                var r = 3 * n.num_faces(),
                                                    i = 4 * r,
                                                    a = e._malloc(i);
                                                t.GetTrianglesUInt32Array(n, i, a);
                                                var o = new Uint32Array(e.HEAPF32.buffer, a, r).slice();
                                                return e._free(a), {
                                                    array: o,
                                                    itemSize: 1
                                                }
                                            }(e, t, i)), e.destroy(i), u
                                        }(t, n, o, a),
                                        l = s.attributes.map(function(e) {
                                            return e.array.buffer
                                        });
                                    s.index && l.push(s.index.array.buffer), self.postMessage({
                                        type: "decode",
                                        id: r.id,
                                        geometry: s
                                    }, l)
                                } catch (e) {
                                    console.error(e), self.postMessage({
                                        type: "error",
                                        id: r.id,
                                        error: e.message
                                    })
                                } finally {
                                    t.destroy(o), t.destroy(n)
                                }
                            })
                    }
                }
            }
            var lu = function(e) {
                function t(e) {
                    var n;
                    return (0, k._)(this, t), (n = (0, E._)(this, t, [e])).dracoLoader = null, n.ktx2Loader = null, n.meshoptDecoder = null, n.pluginCallbacks = [], n.register(function(e) {
                        return new lp(e)
                    }), n.register(function(e) {
                        return new lx(e)
                    }), n.register(function(e) {
                        return new lb(e)
                    }), n.register(function(e) {
                        return new lm(e)
                    }), n.register(function(e) {
                        return new lv(e)
                    }), n.register(function(e) {
                        return new lg(e)
                    }), n.register(function(e) {
                        return new ly(e)
                    }), n.register(function(e) {
                        return new l_(e)
                    }), n.register(function(e) {
                        return new ld(e)
                    }), n.register(function(e) {
                        return new lw(e)
                    }), n
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "load",
                    value: function(e, t, n, r) {
                        var i, a = this;
                        i = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : sz.extractUrlBase(e), this.manager.itemStart(e);
                        var o = function(t) {
                                r ? r(t) : console.error(t), a.manager.itemError(e), a.manager.itemEnd(e)
                            },
                            s = new s_(this.manager);
                        s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function(n) {
                            try {
                                a.parse(n, i, function(n) {
                                    t(n), a.manager.itemEnd(e)
                                }, o)
                            } catch (e) {
                                o(e)
                            }
                        }, n, o)
                    }
                }, {
                    key: "setDRACOLoader",
                    value: function(e) {
                        return this.dracoLoader = e, this
                    }
                }, {
                    key: "setDDSLoader",
                    value: function() {
                        throw Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
                    }
                }, {
                    key: "setKTX2Loader",
                    value: function(e) {
                        return this.ktx2Loader = e, this
                    }
                }, {
                    key: "setMeshoptDecoder",
                    value: function(e) {
                        return this.meshoptDecoder = e, this
                    }
                }, {
                    key: "register",
                    value: function(e) {
                        return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
                    }
                }, {
                    key: "unregister",
                    value: function(e) {
                        return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
                    }
                }, {
                    key: "parse",
                    value: function(e, t, n, r) {
                        var i, a = {},
                            o = {};
                        if ("string" == typeof e) i = e;
                        else if (sz.decodeText(new Uint8Array(e, 0, 4)) === lM) {
                            try {
                                a[lh.KHR_BINARY_GLTF] = new lS(e)
                            } catch (e) {
                                return void(r && r(e))
                            }
                            i = a[lh.KHR_BINARY_GLTF].content
                        } else i = sz.decodeText(new Uint8Array(e));
                        var s = JSON.parse(i);
                        if (void 0 === s.asset || s.asset.version[0] < 2) return void(r && r(Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                        var l = new lW(s, {
                            path: t || this.resourcePath || "",
                            crossOrigin: this.crossOrigin,
                            requestHeader: this.requestHeader,
                            manager: this.manager,
                            ktx2Loader: this.ktx2Loader,
                            meshoptDecoder: this.meshoptDecoder
                        });
                        l.fileLoader.setRequestHeader(this.requestHeader);
                        for (var u = 0; u < this.pluginCallbacks.length; u++) {
                            var c = this.pluginCallbacks[u](l);
                            o[c.name] = c, a[c.name] = !0
                        }
                        if (s.extensionsUsed)
                            for (var h = 0; h < s.extensionsUsed.length; ++h) {
                                var d = s.extensionsUsed[h],
                                    f = s.extensionsRequired || [];
                                switch (d) {
                                    case lh.KHR_MATERIALS_UNLIT:
                                        a[d] = new lf;
                                        break;
                                    case lh.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                        a[d] = new lA;
                                        break;
                                    case lh.KHR_DRACO_MESH_COMPRESSION:
                                        a[d] = new lT(s, this.dracoLoader);
                                        break;
                                    case lh.KHR_TEXTURE_TRANSFORM:
                                        a[d] = new lE;
                                        break;
                                    case lh.KHR_MESH_QUANTIZATION:
                                        a[d] = new lR;
                                        break;
                                    default:
                                        f.indexOf(d) >= 0 && void 0 === o[d] && console.warn('THREE.GLTFLoader: Unknown extension "' + d + '".')
                                }
                            }
                        l.setExtensions(a), l.setPlugins(o), l.parse(n, r)
                    }
                }, {
                    key: "parseAsync",
                    value: function(e, t) {
                        var n = this;
                        return new Promise(function(r, i) {
                            n.parse(e, t, r, i)
                        })
                    }
                }]), t
            }(sg);

            function lc() {
                var e = {};
                return {
                    get: function(t) {
                        return e[t]
                    },
                    add: function(t, n) {
                        e[t] = n
                    },
                    remove: function(t) {
                        delete e[t]
                    },
                    removeAll: function() {
                        e = {}
                    }
                }
            }
            var lh = {
                    KHR_BINARY_GLTF: "KHR_binary_glTF",
                    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                    KHR_MATERIALS_IOR: "KHR_materials_ior",
                    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
                    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
                    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
                    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
                    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                    EXT_TEXTURE_WEBP: "EXT_texture_webp",
                    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
                },
                ld = function() {
                    function e(t) {
                        (0, k._)(this, e), this.parser = t, this.name = lh.KHR_LIGHTS_PUNCTUAL, this.cache = {
                            refs: {},
                            uses: {}
                        }
                    }
                    return (0, A._)(e, [{
                        key: "_markDefs",
                        value: function() {
                            for (var e = this.parser, t = this.parser.json.nodes || [], n = 0, r = t.length; n < r; n++) {
                                var i = t[n];
                                i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
                            }
                        }
                    }, {
                        key: "_loadLight",
                        value: function(e) {
                            var t, n = this.parser,
                                r = "light:" + e,
                                i = n.cache.get(r);
                            if (i) return i;
                            var a = n.json,
                                o = ((a.extensions && a.extensions[this.name] || {}).lights || [])[e],
                                s = new ny(0xffffff);
                            void 0 !== o.color && s.fromArray(o.color);
                            var l = void 0 !== o.range ? o.range : 0;
                            switch (o.type) {
                                case "directional":
                                    (t = new sF(s)).target.position.set(0, 0, -1), t.add(t.target);
                                    break;
                                case "point":
                                    (t = new sO(s)).distance = l;
                                    break;
                                case "spot":
                                    (t = new sC(s)).distance = l, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, t.angle = o.spot.outerConeAngle, t.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, t.target.position.set(0, 0, -1), t.add(t.target);
                                    break;
                                default:
                                    throw Error("THREE.GLTFLoader: Unexpected light type: " + o.type)
                            }
                            return t.position.set(0, 0, 0), t.decay = 2, void 0 !== o.intensity && (t.intensity = o.intensity), t.name = n.createUniqueName(o.name || "light_" + e), i = Promise.resolve(t), n.cache.add(r, i), i
                        }
                    }, {
                        key: "createNodeAttachment",
                        value: function(e) {
                            var t = this,
                                n = this.parser,
                                r = n.json.nodes[e],
                                i = (r.extensions && r.extensions[this.name] || {}).light;
                            return void 0 === i ? null : this._loadLight(i).then(function(e) {
                                return n._getNodeRef(t.cache, i, e)
                            })
                        }
                    }]), e
                }(),
                lf = function() {
                    function e() {
                        (0, k._)(this, e), this.name = lh.KHR_MATERIALS_UNLIT
                    }
                    return (0, A._)(e, [{
                        key: "getMaterialType",
                        value: function() {
                            return n_
                        }
                    }, {
                        key: "extendParams",
                        value: function(e, t, n) {
                            var r = [];
                            e.color = new ny(1, 1, 1), e.opacity = 1;
                            var i = t.pbrMetallicRoughness;
                            if (i) {
                                if (Array.isArray(i.baseColorFactor)) {
                                    var a = i.baseColorFactor;
                                    e.color.fromArray(a), e.opacity = a[3]
                                }
                                void 0 !== i.baseColorTexture && r.push(n.assignTexture(e, "map", i.baseColorTexture))
                            }
                            return Promise.all(r)
                        }
                    }]), e
                }(),
                lp = function() {
                    function e(t) {
                        (0, k._)(this, e), this.parser = t, this.name = lh.KHR_MATERIALS_CLEARCOAT
                    }
                    return (0, A._)(e, [{
                        key: "getMaterialType",
                        value: function(e) {
                            var t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? se : null
                        }
                    }, {
                        key: "extendMaterialParams",
                        value: function(e, t) {
                            var n = this.parser,
                                r = n.json.materials[e];
                            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                            var i = [],
                                a = r.extensions[this.name];
                            if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor), void 0 !== a.clearcoatTexture && i.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), void 0 !== a.clearcoatRoughnessTexture && i.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), void 0 !== a.clearcoatNormalTexture && (i.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), void 0 !== a.clearcoatNormalTexture.scale)) {
                                var o = a.clearcoatNormalTexture.scale;
                                t.clearcoatNormalScale = new e4(o, o)
                            }
                            return Promise.all(i)
                        }
                    }]), e
                }(),
                lm = function() {
                    function e(t) {
                        (0, k._)(this, e), this.parser = t, this.name = lh.KHR_MATERIALS_SHEEN
                    }
                    return (0, A._)(e, [{
                        key: "getMaterialType",
                        value: function(e) {
                            var t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? se : null
                        }
                    }, {
                        key: "extendMaterialParams",
                        value: function(e, t) {
                            var n = this.parser,
                                r = n.json.materials[e];
                            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                            var i = [];
                            t.sheenColor = new ny(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
                            var a = r.extensions[this.name];
                            return void 0 !== a.sheenColorFactor && t.sheenColor.fromArray(a.sheenColorFactor), void 0 !== a.sheenRoughnessFactor && (t.sheenRoughness = a.sheenRoughnessFactor), void 0 !== a.sheenColorTexture && i.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture)), void 0 !== a.sheenRoughnessTexture && i.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(i)
                        }
                    }]), e
                }(),
                lv = function() {
                    function e(t) {
                        (0, k._)(this, e), this.parser = t, this.name = lh.KHR_MATERIALS_TRANSMISSION
                    }
                    return (0, A._)(e, [{
                        key: "getMaterialType",
                        value: function(e) {
                            var t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? se : null
                        }
                    }, {
                        key: "extendMaterialParams",
                        value: function(e, t) {
                            var n = this.parser,
                                r = n.json.materials[e];
                            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                            var i = [],
                                a = r.extensions[this.name];
                            return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor), void 0 !== a.transmissionTexture && i.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(i)
                        }
                    }]), e
                }(),
                lg = function() {
                    function e(t) {
                        (0, k._)(this, e), this.parser = t, this.name = lh.KHR_MATERIALS_VOLUME
                    }
                    return (0, A._)(e, [{
                        key: "getMaterialType",
                        value: function(e) {
                            var t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? se : null
                        }
                    }, {
                        key: "extendMaterialParams",
                        value: function(e, t) {
                            var n = this.parser,
                                r = n.json.materials[e];
                            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                            var i = [],
                                a = r.extensions[this.name];
                            t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0, void 0 !== a.thicknessTexture && i.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 0;
                            var o = a.attenuationColor || [1, 1, 1];
                            return t.attenuationColor = new ny(o[0], o[1], o[2]), Promise.all(i)
                        }
                    }]), e
                }(),
                ly = function() {
                    function e(t) {
                        (0, k._)(this, e), this.parser = t, this.name = lh.KHR_MATERIALS_IOR
                    }
                    return (0, A._)(e, [{
                        key: "getMaterialType",
                        value: function(e) {
                            var t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? se : null
                        }
                    }, {
                        key: "extendMaterialParams",
                        value: function(e, t) {
                            var n = this.parser.json.materials[e];
                            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                            var r = n.extensions[this.name];
                            return t.ior = void 0 !== r.ior ? r.ior : 1.5, Promise.resolve()
                        }
                    }]), e
                }(),
                l_ = function() {
                    function e(t) {
                        (0, k._)(this, e), this.parser = t, this.name = lh.KHR_MATERIALS_SPECULAR
                    }
                    return (0, A._)(e, [{
                        key: "getMaterialType",
                        value: function(e) {
                            var t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? se : null
                        }
                    }, {
                        key: "extendMaterialParams",
                        value: function(e, t) {
                            var n = this.parser,
                                r = n.json.materials[e];
                            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                            var i = [],
                                a = r.extensions[this.name];
                            t.specularIntensity = void 0 !== a.specularFactor ? a.specularFactor : 1, void 0 !== a.specularTexture && i.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
                            var o = a.specularColorFactor || [1, 1, 1];
                            return t.specularColor = new ny(o[0], o[1], o[2]), void 0 !== a.specularColorTexture && i.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture).then(function(e) {
                                e.encoding = 3001
                            })), Promise.all(i)
                        }
                    }]), e
                }(),
                lx = function() {
                    function e(t) {
                        (0, k._)(this, e), this.parser = t, this.name = lh.KHR_TEXTURE_BASISU
                    }
                    return (0, A._)(e, [{
                        key: "loadTexture",
                        value: function(e) {
                            var t = this.parser,
                                n = t.json,
                                r = n.textures[e];
                            if (!r.extensions || !r.extensions[this.name]) return null;
                            var i = r.extensions[this.name],
                                a = n.images[i.source],
                                o = t.options.ktx2Loader;
                            if (!o) {
                                if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                                return null
                            }
                            return t.loadTextureImage(e, a, o)
                        }
                    }]), e
                }(),
                lb = function() {
                    function e(t) {
                        (0, k._)(this, e), this.parser = t, this.name = lh.EXT_TEXTURE_WEBP, this.isSupported = null
                    }
                    return (0, A._)(e, [{
                        key: "loadTexture",
                        value: function(e) {
                            var t = this.name,
                                n = this.parser,
                                r = n.json,
                                i = r.textures[e];
                            if (!i.extensions || !i.extensions[t]) return null;
                            var a = i.extensions[t],
                                o = r.images[a.source],
                                s = n.textureLoader;
                            if (o.uri) {
                                var l = n.options.manager.getHandler(o.uri);
                                null !== l && (s = l)
                            }
                            return this.detectSupport().then(function(i) {
                                if (i) return n.loadTextureImage(e, o, s);
                                if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                                return n.loadTexture(e)
                            })
                        }
                    }, {
                        key: "detectSupport",
                        value: function() {
                            return this.isSupported || (this.isSupported = new Promise(function(e) {
                                var t = new Image;
                                t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                                    e(1 === t.height)
                                }
                            })), this.isSupported
                        }
                    }]), e
                }(),
                lw = function() {
                    function e(t) {
                        (0, k._)(this, e), this.name = lh.EXT_MESHOPT_COMPRESSION, this.parser = t
                    }
                    return (0, A._)(e, [{
                        key: "loadBufferView",
                        value: function(e) {
                            var t = this.parser.json,
                                n = t.bufferViews[e];
                            if (n.extensions && n.extensions[this.name]) {
                                var r = n.extensions[this.name],
                                    i = this.parser.getDependency("buffer", r.buffer),
                                    a = this.parser.options.meshoptDecoder;
                                if (!a || !a.supported) {
                                    if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                                    return null
                                }
                                return Promise.all([i, a.ready]).then(function(e) {
                                    var t = r.byteOffset || 0,
                                        n = r.byteLength || 0,
                                        i = r.count,
                                        o = r.byteStride,
                                        s = new ArrayBuffer(i * o),
                                        l = new Uint8Array(e[0], t, n);
                                    return a.decodeGltfBuffer(new Uint8Array(s), i, o, l, r.mode, r.filter), s
                                })
                            }
                            return null
                        }
                    }]), e
                }(),
                lM = "glTF",
                lS = function e(t) {
                    (0, k._)(this, e), this.name = lh.KHR_BINARY_GLTF, this.content = null, this.body = null;
                    var n = new DataView(t, 0, 12);
                    if (this.header = {
                            magic: sz.decodeText(new Uint8Array(t.slice(0, 4))),
                            version: n.getUint32(4, !0),
                            length: n.getUint32(8, !0)
                        }, this.header.magic !== lM) throw Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                    if (this.header.version < 2) throw Error("THREE.GLTFLoader: Legacy binary file detected.");
                    for (var r = this.header.length - 12, i = new DataView(t, 12), a = 0; a < r;) {
                        var o = i.getUint32(a, !0);
                        a += 4;
                        var s = i.getUint32(a, !0);
                        if (a += 4, 0x4e4f534a === s) {
                            var l = new Uint8Array(t, 12 + a, o);
                            this.content = sz.decodeText(l)
                        } else if (5130562 === s) {
                            var u = 12 + a;
                            this.body = t.slice(u, u + o)
                        }
                        a += o
                    }
                    if (null === this.content) throw Error("THREE.GLTFLoader: JSON content not found.")
                },
                lT = function() {
                    function e(t, n) {
                        if ((0, k._)(this, e), !n) throw Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                        this.name = lh.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = n, this.dracoLoader.preload()
                    }
                    return (0, A._)(e, [{
                        key: "decodePrimitive",
                        value: function(e, t) {
                            var n = this.json,
                                r = this.dracoLoader,
                                i = e.extensions[this.name].bufferView,
                                a = e.extensions[this.name].attributes,
                                o = {},
                                s = {},
                                l = {};
                            for (var u in a) o[lF[u] || u.toLowerCase()] = a[u];
                            for (var c in e.attributes) {
                                var h = lF[c] || c.toLowerCase();
                                if (void 0 !== a[c]) {
                                    var d = n.accessors[e.attributes[c]],
                                        f = lI[d.componentType];
                                    l[h] = f, s[h] = !0 === d.normalized
                                }
                            }
                            return t.getDependency("bufferView", i).then(function(e) {
                                return new Promise(function(t) {
                                    r.decodeDracoFile(e, function(e) {
                                        for (var n in e.attributes) {
                                            var r = e.attributes[n],
                                                i = s[n];
                                            void 0 !== i && (r.normalized = i)
                                        }
                                        t(e)
                                    }, o, l)
                                })
                            })
                        }
                    }]), e
                }(),
                lE = function() {
                    function e() {
                        (0, k._)(this, e), this.name = lh.KHR_TEXTURE_TRANSFORM
                    }
                    return (0, A._)(e, [{
                        key: "extendTexture",
                        value: function(e, t) {
                            return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
                        }
                    }]), e
                }(),
                lk = function(e) {
                    function t(e) {
                        (0, k._)(this, t), (n = (0, E._)(this, t)).isGLTFSpecularGlossinessMaterial = !0;
                        var n, r = {
                            specular: {
                                value: (new ny).setHex(0xffffff)
                            },
                            glossiness: {
                                value: 1
                            },
                            specularMap: {
                                value: null
                            },
                            glossinessMap: {
                                value: null
                            }
                        };
                        return n._extraUniforms = r, n.onBeforeCompile = function(e) {
                            for (var t in r) e.uniforms[t] = r[t];
                            e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif").replace("#include <metalnessmap_pars_fragment>", "#ifdef USE_GLOSSINESSMAP\n	uniform sampler2D glossinessMap;\n#endif").replace("#include <roughnessmap_fragment>", "vec3 specularFactor = specular;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	texelSpecular = sRGBToLinear( texelSpecular );\n	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture\n	specularFactor *= texelSpecular.rgb;\n#endif").replace("#include <metalnessmap_fragment>", "float glossinessFactor = glossiness;\n#ifdef USE_GLOSSINESSMAP\n	vec4 texelGlossiness = texture2D( glossinessMap, vUv );\n	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture\n	glossinessFactor *= texelGlossiness.a;\n#endif").replace("#include <lights_physical_fragment>", "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\nmaterial.specularColor = specularFactor;")
                        }, Object.defineProperties(n, {
                            specular: {
                                get: function() {
                                    return r.specular.value
                                },
                                set: function(e) {
                                    r.specular.value = e
                                }
                            },
                            specularMap: {
                                get: function() {
                                    return r.specularMap.value
                                },
                                set: function(e) {
                                    r.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                                }
                            },
                            glossiness: {
                                get: function() {
                                    return r.glossiness.value
                                },
                                set: function(e) {
                                    r.glossiness.value = e
                                }
                            },
                            glossinessMap: {
                                get: function() {
                                    return r.glossinessMap.value
                                },
                                set: function(e) {
                                    r.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                                }
                            }
                        }), delete n.metalness, delete n.roughness, delete n.metalnessMap, delete n.roughnessMap, n.setValues(e), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copy",
                        value: function(e) {
                            return L((0, C._)(t.prototype), "copy", this).call(this, e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
                        }
                    }]), t
                }(o9),
                lA = function() {
                    function e() {
                        (0, k._)(this, e), this.name = lh.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
                    }
                    return (0, A._)(e, [{
                        key: "getMaterialType",
                        value: function() {
                            return lk
                        }
                    }, {
                        key: "extendParams",
                        value: function(e, t, n) {
                            var r = t.extensions[this.name];
                            e.color = new ny(1, 1, 1), e.opacity = 1;
                            var i = [];
                            if (Array.isArray(r.diffuseFactor)) {
                                var a = r.diffuseFactor;
                                e.color.fromArray(a), e.opacity = a[3]
                            }
                            if (void 0 !== r.diffuseTexture && i.push(n.assignTexture(e, "map", r.diffuseTexture)), e.emissive = new ny(0, 0, 0), e.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, e.specular = new ny(1, 1, 1), Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture) {
                                var o = r.specularGlossinessTexture;
                                i.push(n.assignTexture(e, "glossinessMap", o)), i.push(n.assignTexture(e, "specularMap", o))
                            }
                            return Promise.all(i)
                        }
                    }, {
                        key: "createMaterial",
                        value: function(e) {
                            var t = new lk(e);
                            return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = 0, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t
                        }
                    }]), e
                }(),
                lR = function e() {
                    (0, k._)(this, e), this.name = lh.KHR_MESH_QUANTIZATION
                },
                lC = function(e) {
                    function t(e, n, r, i) {
                        return (0, k._)(this, t), (0, E._)(this, t, [e, n, r, i])
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "copySampleValue_",
                        value: function(e) {
                            for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r * 3 + r, a = 0; a !== r; a++) t[a] = n[i + a];
                            return t
                        }
                    }]), t
                }(sn);
            lC.prototype.beforeStart_ = lC.prototype.copySampleValue_, lC.prototype.afterEnd_ = lC.prototype.copySampleValue_, lC.prototype.interpolate_ = function(e, t, n, r) {
                for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = 2 * o, l = 3 * o, u = r - t, c = (n - t) / u, h = c * c, d = h * c, f = e * l, p = f - l, m = -2 * d + 3 * h, v = d - h, g = 1 - m, y = v - h + c, _ = 0; _ !== o; _++) {
                    var x = a[p + _ + o],
                        b = a[p + _ + s] * u,
                        w = a[f + _ + o],
                        M = a[f + _] * u;
                    i[_] = g * x + y * b + m * w + v * M
                }
                return i
            };
            var lL = new ta,
                lP = function(e) {
                    function t() {
                        return (0, k._)(this, t), (0, E._)(this, t, arguments)
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "interpolate_",
                        value: function(e, n, r, i) {
                            var a = L((0, C._)(t.prototype), "interpolate_", this).call(this, e, n, r, i);
                            return lL.fromArray(a).normalize().toArray(a), a
                        }
                    }]), t
                }(lC),
                lI = {
                    5120: Int8Array,
                    5121: Uint8Array,
                    5122: Int16Array,
                    5123: Uint16Array,
                    5125: Uint32Array,
                    5126: Float32Array
                },
                lD = {
                    9728: 1003,
                    9729: 1006,
                    9984: 1004,
                    9985: 1007,
                    9986: 1005,
                    9987: 1008
                },
                lO = {
                    33071: 1001,
                    33648: 1002,
                    10497: 1e3
                },
                lN = {
                    SCALAR: 1,
                    VEC2: 2,
                    VEC3: 3,
                    VEC4: 4,
                    MAT2: 4,
                    MAT3: 9,
                    MAT4: 16
                },
                lF = {
                    POSITION: "position",
                    NORMAL: "normal",
                    TANGENT: "tangent",
                    TEXCOORD_0: "uv",
                    TEXCOORD_1: "uv2",
                    COLOR_0: "color",
                    WEIGHTS_0: "skinWeight",
                    JOINTS_0: "skinIndex"
                },
                lU = {
                    scale: "scale",
                    translation: "position",
                    rotation: "quaternion",
                    weights: "morphTargetInfluences"
                },
                lB = {
                    CUBICSPLINE: void 0,
                    LINEAR: 2301,
                    STEP: 2300
                };

            function lz(e, t, n) {
                for (var r in n.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = n.extensions[r])
            }

            function lH(e, t) {
                void 0 !== t.extras && ("object" == (0, U._)(t.extras) ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
            }

            function lV(e) {
                for (var t = "", n = Object.keys(e).sort(), r = 0, i = n.length; r < i; r++) t += n[r] + ":" + e[n[r]] + ";";
                return t
            }

            function lG(e) {
                switch (e) {
                    case Int8Array:
                        return 1 / 127;
                    case Uint8Array:
                        return 1 / 255;
                    case Int16Array:
                        return 1 / 32767;
                    case Uint16Array:
                        return 1 / 65535;
                    default:
                        throw Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
                }
            }
            var lW = function() {
                function e() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    (0, k._)(this, e), this.json = t, this.extensions = {}, this.plugins = {}, this.options = n, this.cache = new lc, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                        refs: {},
                        uses: {}
                    }, this.cameraCache = {
                        refs: {},
                        uses: {}
                    }, this.lightCache = {
                        refs: {},
                        uses: {}
                    }, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox|Safari/.test(navigator.userAgent) ? this.textureLoader = new sH(this.options.manager) : this.textureLoader = new sM(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new s_(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
                }
                return (0, A._)(e, [{
                    key: "setExtensions",
                    value: function(e) {
                        this.extensions = e
                    }
                }, {
                    key: "setPlugins",
                    value: function(e) {
                        this.plugins = e
                    }
                }, {
                    key: "parse",
                    value: function(e, t) {
                        var n = this,
                            r = this.json,
                            i = this.extensions;
                        this.cache.removeAll(), this._invokeAll(function(e) {
                            return e._markDefs && e._markDefs()
                        }), Promise.all(this._invokeAll(function(e) {
                            return e.beforeRoot && e.beforeRoot()
                        })).then(function() {
                            return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                        }).then(function(t) {
                            var a = {
                                scene: t[0][r.scene || 0],
                                scenes: t[0],
                                animations: t[1],
                                cameras: t[2],
                                asset: r.asset,
                                parser: n,
                                userData: {}
                            };
                            lz(i, a, r), lH(a, r), Promise.all(n._invokeAll(function(e) {
                                return e.afterRoot && e.afterRoot(a)
                            })).then(function() {
                                e(a)
                            })
                        }).catch(t)
                    }
                }, {
                    key: "_markDefs",
                    value: function() {
                        for (var e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [], r = 0, i = t.length; r < i; r++)
                            for (var a = t[r].joints, o = 0, s = a.length; o < s; o++) e[a[o]].isBone = !0;
                        for (var l = 0, u = e.length; l < u; l++) {
                            var c = e[l];
                            void 0 !== c.mesh && (this._addNodeRef(this.meshCache, c.mesh), void 0 !== c.skin && (n[c.mesh].isSkinnedMesh = !0)), void 0 !== c.camera && this._addNodeRef(this.cameraCache, c.camera)
                        }
                    }
                }, {
                    key: "_addNodeRef",
                    value: function(e, t) {
                        void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
                    }
                }, {
                    key: "_getNodeRef",
                    value: function(e, t, n) {
                        var r = this;
                        if (e.refs[t] <= 1) return n;
                        var i = n.clone(),
                            a = function(e, t) {
                                var n = r.associations.get(e);
                                null != n && r.associations.set(t, n);
                                var i = !0,
                                    o = !1,
                                    s = void 0;
                                try {
                                    for (var l, u = e.children.entries()[Symbol.iterator](); !(i = (l = u.next()).done); i = !0) {
                                        var c = (0, O._)(l.value, 2),
                                            h = c[0],
                                            d = c[1];
                                        a(d, t.children[h])
                                    }
                                } catch (e) {
                                    o = !0, s = e
                                } finally {
                                    try {
                                        i || null == u.return || u.return()
                                    } finally {
                                        if (o) throw s
                                    }
                                }
                            };
                        return a(n, i), i.name += "_instance_" + e.uses[t]++, i
                    }
                }, {
                    key: "_invokeOne",
                    value: function(e) {
                        var t = Object.values(this.plugins);
                        t.push(this);
                        for (var n = 0; n < t.length; n++) {
                            var r = e(t[n]);
                            if (r) return r
                        }
                        return null
                    }
                }, {
                    key: "_invokeAll",
                    value: function(e) {
                        var t = Object.values(this.plugins);
                        t.unshift(this);
                        for (var n = [], r = 0; r < t.length; r++) {
                            var i = e(t[r]);
                            i && n.push(i)
                        }
                        return n
                    }
                }, {
                    key: "getDependency",
                    value: function(e, t) {
                        var n = e + ":" + t,
                            r = this.cache.get(n);
                        if (!r) {
                            switch (e) {
                                case "scene":
                                    r = this.loadScene(t);
                                    break;
                                case "node":
                                    r = this.loadNode(t);
                                    break;
                                case "mesh":
                                    r = this._invokeOne(function(e) {
                                        return e.loadMesh && e.loadMesh(t)
                                    });
                                    break;
                                case "accessor":
                                    r = this.loadAccessor(t);
                                    break;
                                case "bufferView":
                                    r = this._invokeOne(function(e) {
                                        return e.loadBufferView && e.loadBufferView(t)
                                    });
                                    break;
                                case "buffer":
                                    r = this.loadBuffer(t);
                                    break;
                                case "material":
                                    r = this._invokeOne(function(e) {
                                        return e.loadMaterial && e.loadMaterial(t)
                                    });
                                    break;
                                case "texture":
                                    r = this._invokeOne(function(e) {
                                        return e.loadTexture && e.loadTexture(t)
                                    });
                                    break;
                                case "skin":
                                    r = this.loadSkin(t);
                                    break;
                                case "animation":
                                    r = this.loadAnimation(t);
                                    break;
                                case "camera":
                                    r = this.loadCamera(t);
                                    break;
                                default:
                                    throw Error("Unknown type: " + e)
                            }
                            this.cache.add(n, r)
                        }
                        return r
                    }
                }, {
                    key: "getDependencies",
                    value: function(e) {
                        var t = this.cache.get(e);
                        if (!t) {
                            var n = this;
                            t = Promise.all((this.json[e + ("mesh" === e ? "es" : "s")] || []).map(function(t, r) {
                                return n.getDependency(e, r)
                            })), this.cache.add(e, t)
                        }
                        return t
                    }
                }, {
                    key: "loadBuffer",
                    value: function(e) {
                        var t = this.json.buffers[e],
                            n = this.fileLoader;
                        if (t.type && "arraybuffer" !== t.type) throw Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                        if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[lh.KHR_BINARY_GLTF].body);
                        var r = this.options;
                        return new Promise(function(e, i) {
                            n.load(sz.resolveURL(t.uri, r.path), e, void 0, function() {
                                i(Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                            })
                        })
                    }
                }, {
                    key: "loadBufferView",
                    value: function(e) {
                        var t = this.json.bufferViews[e];
                        return this.getDependency("buffer", t.buffer).then(function(e) {
                            var n = t.byteLength || 0,
                                r = t.byteOffset || 0;
                            return e.slice(r, r + n)
                        })
                    }
                }, {
                    key: "loadAccessor",
                    value: function(e) {
                        var t = this,
                            n = this.json,
                            r = this.json.accessors[e];
                        if (void 0 === r.bufferView && void 0 === r.sparse) return Promise.resolve(null);
                        var i = [];
                        return void 0 !== r.bufferView ? i.push(this.getDependency("bufferView", r.bufferView)) : i.push(null), void 0 !== r.sparse && (i.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(i).then(function(e) {
                            var i, a = e[0],
                                o = lN[r.type],
                                s = lI[r.componentType],
                                l = s.BYTES_PER_ELEMENT,
                                u = l * o,
                                c = r.byteOffset || 0,
                                h = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0,
                                d = !0 === r.normalized;
                            if (h && h !== u) {
                                var f = Math.floor(c / h),
                                    p = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + f + ":" + r.count,
                                    m = t.cache.get(p);
                                m || (m = new aL(new s(a, f * h, r.count * h / l), h / l), t.cache.add(p, m)), i = new aI(m, o, c % h / l, d)
                            } else i = new nw(null === a ? new s(r.count * o) : new s(a, c, r.count * o), o, d);
                            if (void 0 !== r.sparse) {
                                var v = lN.SCALAR,
                                    g = lI[r.sparse.indices.componentType],
                                    y = r.sparse.indices.byteOffset || 0,
                                    _ = r.sparse.values.byteOffset || 0,
                                    x = new g(e[1], y, r.sparse.count * v),
                                    b = new s(e[2], _, r.sparse.count * o);
                                null !== a && (i = new nw(i.array.slice(), i.itemSize, i.normalized));
                                for (var w = 0, M = x.length; w < M; w++) {
                                    var S = x[w];
                                    if (i.setX(S, b[w * o]), o >= 2 && i.setY(S, b[w * o + 1]), o >= 3 && i.setZ(S, b[w * o + 2]), o >= 4 && i.setW(S, b[w * o + 3]), o >= 5) throw Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                                }
                            }
                            return i
                        })
                    }
                }, {
                    key: "loadTexture",
                    value: function(e) {
                        var t = this.json,
                            n = this.options,
                            r = t.textures[e],
                            i = t.images[r.source],
                            a = this.textureLoader;
                        if (i.uri) {
                            var o = n.manager.getHandler(i.uri);
                            null !== o && (a = o)
                        }
                        return this.loadTextureImage(e, i, a)
                    }
                }, {
                    key: "loadTextureImage",
                    value: function(e, t, n) {
                        var r = this,
                            i = this.json,
                            a = this.options,
                            o = i.textures[e],
                            s = (t.uri || t.bufferView) + ":" + o.sampler;
                        if (this.textureCache[s]) return this.textureCache[s];
                        var l = self.URL || self.webkitURL,
                            u = t.uri || "",
                            c = !1;
                        if (void 0 !== t.bufferView) u = r.getDependency("bufferView", t.bufferView).then(function(e) {
                            c = !0;
                            var n = new Blob([e], {
                                type: t.mimeType
                            });
                            return u = l.createObjectURL(n)
                        });
                        else if (void 0 === t.uri) throw Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                        var h = Promise.resolve(u).then(function(e) {
                            return new Promise(function(t, r) {
                                var i = t;
                                !0 === n.isImageBitmapLoader && (i = function(e) {
                                    var n = new te(e);
                                    n.needsUpdate = !0, t(n)
                                }), n.load(sz.resolveURL(e, a.path), i, void 0, r)
                            })
                        }).then(function(t) {
                            !0 === c && l.revokeObjectURL(u), t.flipY = !1, o.name && (t.name = o.name);
                            var n = (i.samplers || {})[o.sampler] || {};
                            return t.magFilter = lD[n.magFilter] || 1006, t.minFilter = lD[n.minFilter] || 1008, t.wrapS = lO[n.wrapS] || 1e3, t.wrapT = lO[n.wrapT] || 1e3, r.associations.set(t, {
                                textures: e
                            }), t
                        }).catch(function() {
                            return console.error("THREE.GLTFLoader: Couldn't load texture", u), null
                        });
                        return this.textureCache[s] = h, h
                    }
                }, {
                    key: "assignTexture",
                    value: function(e, t, n) {
                        var r = this;
                        return this.getDependency("texture", n.index).then(function(i) {
                            if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === t && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."), r.extensions[lh.KHR_TEXTURE_TRANSFORM]) {
                                var a = void 0 !== n.extensions ? n.extensions[lh.KHR_TEXTURE_TRANSFORM] : void 0;
                                if (a) {
                                    var o = r.associations.get(i);
                                    i = r.extensions[lh.KHR_TEXTURE_TRANSFORM].extendTexture(i, a), r.associations.set(i, o)
                                }
                            }
                            return e[t] = i, i
                        })
                    }
                }, {
                    key: "assignFinalMaterial",
                    value: function(e) {
                        var t = e.geometry,
                            n = e.material,
                            r = void 0 === t.attributes.tangent,
                            i = void 0 !== t.attributes.color,
                            a = void 0 === t.attributes.normal;
                        if (e.isPoints) {
                            var o = "PointsMaterial:" + n.uuid,
                                s = this.cache.get(o);
                            s || (s = new oh, nh.prototype.copy.call(s, n), s.color.copy(n.color), s.map = n.map, s.sizeAttenuation = !1, this.cache.add(o, s)), n = s
                        } else if (e.isLine) {
                            var l = "LineBasicMaterial:" + n.uuid,
                                u = this.cache.get(l);
                            u || (u = new oe, nh.prototype.copy.call(u, n), u.color.copy(n.color), this.cache.add(l, u)), n = u
                        }
                        if (r || i || a) {
                            var c = "ClonedMaterial:" + n.uuid + ":";
                            n.isGLTFSpecularGlossinessMaterial && (c += "specular-glossiness:"), r && (c += "derivative-tangents:"), i && (c += "vertex-colors:"), a && (c += "flat-shading:");
                            var h = this.cache.get(c);
                            h || (h = n.clone(), i && (h.vertexColors = !0), a && (h.flatShading = !0), r && (h.normalScale && (h.normalScale.y *= -1), h.clearcoatNormalScale && (h.clearcoatNormalScale.y *= -1)), this.cache.add(c, h), this.associations.set(h, this.associations.get(n))), n = h
                        }
                        n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = n
                    }
                }, {
                    key: "getMaterialType",
                    value: function() {
                        return o9
                    }
                }, {
                    key: "loadMaterial",
                    value: function(e) {
                        var t, n = this,
                            r = this.json,
                            i = this.extensions,
                            a = r.materials[e],
                            o = {},
                            s = a.extensions || {},
                            l = [];
                        if (s[lh.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                            var u = i[lh.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                            t = u.getMaterialType(), l.push(u.extendParams(o, a, n))
                        } else if (s[lh.KHR_MATERIALS_UNLIT]) {
                            var c = i[lh.KHR_MATERIALS_UNLIT];
                            t = c.getMaterialType(), l.push(c.extendParams(o, a, n))
                        } else {
                            var h = a.pbrMetallicRoughness || {};
                            if (o.color = new ny(1, 1, 1), o.opacity = 1, Array.isArray(h.baseColorFactor)) {
                                var d = h.baseColorFactor;
                                o.color.fromArray(d), o.opacity = d[3]
                            }
                            void 0 !== h.baseColorTexture && l.push(n.assignTexture(o, "map", h.baseColorTexture)), o.metalness = void 0 !== h.metallicFactor ? h.metallicFactor : 1, o.roughness = void 0 !== h.roughnessFactor ? h.roughnessFactor : 1, void 0 !== h.metallicRoughnessTexture && (l.push(n.assignTexture(o, "metalnessMap", h.metallicRoughnessTexture)), l.push(n.assignTexture(o, "roughnessMap", h.metallicRoughnessTexture))), t = this._invokeOne(function(t) {
                                return t.getMaterialType && t.getMaterialType(e)
                            }), l.push(Promise.all(this._invokeAll(function(t) {
                                return t.extendMaterialParams && t.extendMaterialParams(e, o)
                            })))
                        }!0 === a.doubleSided && (o.side = 2);
                        var f = a.alphaMode || "OPAQUE";
                        if ("BLEND" === f ? (o.transparent = !0, o.depthWrite = !1) : (o.format = 1022, o.transparent = !1, "MASK" === f && (o.alphaTest = void 0 !== a.alphaCutoff ? a.alphaCutoff : .5)), void 0 !== a.normalTexture && t !== n_ && (l.push(n.assignTexture(o, "normalMap", a.normalTexture)), o.normalScale = new e4(1, 1), void 0 !== a.normalTexture.scale)) {
                            var p = a.normalTexture.scale;
                            o.normalScale.set(p, p)
                        }
                        return void 0 !== a.occlusionTexture && t !== n_ && (l.push(n.assignTexture(o, "aoMap", a.occlusionTexture)), void 0 !== a.occlusionTexture.strength && (o.aoMapIntensity = a.occlusionTexture.strength)), void 0 !== a.emissiveFactor && t !== n_ && (o.emissive = (new ny).fromArray(a.emissiveFactor)), void 0 !== a.emissiveTexture && t !== n_ && l.push(n.assignTexture(o, "emissiveMap", a.emissiveTexture)), Promise.all(l).then(function() {
                            var r;
                            return r = t === lk ? i[lh.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o) : new t(o), a.name && (r.name = a.name), r.map && (r.map.encoding = 3001), r.emissiveMap && (r.emissiveMap.encoding = 3001), lH(r, a), n.associations.set(r, {
                                materials: e
                            }), a.extensions && lz(i, r, a), r
                        })
                    }
                }, {
                    key: "createUniqueName",
                    value: function(e) {
                        for (var t = sY.sanitizeNodeName(e || ""), n = t, r = 1; this.nodeNamesUsed[n]; ++r) n = t + "_" + r;
                        return this.nodeNamesUsed[n] = !0, n
                    }
                }, {
                    key: "loadGeometries",
                    value: function(e) {
                        for (var t = this, n = this.extensions, r = this.primitiveCache, i = [], a = 0, o = e.length; a < o; a++) {
                            var s = e[a],
                                l = function(e) {
                                    var t = e.extensions && e.extensions[lh.KHR_DRACO_MESH_COMPRESSION];
                                    return t ? "draco:" + t.bufferView + ":" + t.indices + ":" + lV(t.attributes) : e.indices + ":" + lV(e.attributes) + ":" + e.mode
                                }(s),
                                u = r[l];
                            if (u) i.push(u.promise);
                            else {
                                var c = void 0;
                                c = s.extensions && s.extensions[lh.KHR_DRACO_MESH_COMPRESSION] ? function(e) {
                                    return n[lh.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then(function(n) {
                                        return lj(n, e, t)
                                    })
                                }(s) : lj(new nI, s, t), r[l] = {
                                    primitive: s,
                                    promise: c
                                }, i.push(c)
                            }
                        }
                        return Promise.all(i)
                    }
                }, {
                    key: "loadMesh",
                    value: function(e) {
                        for (var t = this, n = this.json, r = this.extensions, i = n.meshes[e], a = i.primitives, o = [], s = 0, l = a.length; s < l; s++) {
                            var u, c = void 0 === a[s].material ? (void 0 === (u = this.cache).DefaultMaterial && (u.DefaultMaterial = new o9({
                                color: 0xffffff,
                                emissive: 0,
                                metalness: 1,
                                roughness: 1,
                                transparent: !1,
                                depthTest: !0,
                                side: 0
                            })), u.DefaultMaterial) : this.getDependency("material", a[s].material);
                            o.push(c)
                        }
                        return o.push(t.loadGeometries(a)), Promise.all(o).then(function(n) {
                            for (var o = n.slice(0, n.length - 1), s = n[n.length - 1], l = [], u = 0, c = s.length; u < c; u++) {
                                var h = s[u],
                                    d = a[u],
                                    f = void 0,
                                    p = o[u];
                                if (4 === d.mode || 5 === d.mode || 6 === d.mode || void 0 === d.mode) !0 !== (f = !0 === i.isSkinnedMesh ? new a$(h, p) : new nK(h, p)).isSkinnedMesh || f.geometry.attributes.skinWeight.normalized || f.normalizeSkinWeights(), 5 === d.mode ? f.geometry = lq(f.geometry, 1) : 6 === d.mode && (f.geometry = lq(f.geometry, 2));
                                else if (1 === d.mode) f = new ou(h, p);
                                else if (3 === d.mode) f = new oo(h, p);
                                else if (2 === d.mode) f = new oc(h, p);
                                else {
                                    if (0 !== d.mode) throw Error("THREE.GLTFLoader: Primitive mode unsupported: " + d.mode);
                                    f = new ov(h, p)
                                }
                                Object.keys(f.geometry.morphAttributes).length > 0 && function(e, t) {
                                    if (e.updateMorphTargets(), void 0 !== t.weights)
                                        for (var n = 0, r = t.weights.length; n < r; n++) e.morphTargetInfluences[n] = t.weights[n];
                                    if (t.extras && Array.isArray(t.extras.targetNames)) {
                                        var i = t.extras.targetNames;
                                        if (e.morphTargetInfluences.length === i.length) {
                                            e.morphTargetDictionary = {};
                                            for (var a = 0, o = i.length; a < o; a++) e.morphTargetDictionary[i[a]] = a
                                        } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
                                    }
                                }(f, i), f.name = t.createUniqueName(i.name || "mesh_" + e), lH(f, i), d.extensions && lz(r, f, d), t.assignFinalMaterial(f), l.push(f)
                            }
                            for (var m = 0, v = l.length; m < v; m++) t.associations.set(l[m], {
                                meshes: e,
                                primitives: m
                            });
                            if (1 === l.length) return l[0];
                            var g = new aM;
                            t.associations.set(g, {
                                meshes: e
                            });
                            for (var y = 0, _ = l.length; y < _; y++) g.add(l[y]);
                            return g
                        })
                    }
                }, {
                    key: "loadCamera",
                    value: function(e) {
                        var t, n = this.json.cameras[e],
                            r = n[n.type];
                        if (r) return "perspective" === n.type ? t = new n5(e3.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (t = new ry(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (t.name = this.createUniqueName(n.name)), lH(t, n), Promise.resolve(t);
                        console.warn("THREE.GLTFLoader: Missing camera parameters.")
                    }
                }, {
                    key: "loadSkin",
                    value: function(e) {
                        var t = this.json.skins[e],
                            n = {
                                joints: t.joints
                            };
                        return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then(function(e) {
                            return n.inverseBindMatrices = e, n
                        })
                    }
                }, {
                    key: "loadAnimation",
                    value: function(e) {
                        for (var t = this.json.animations[e], n = [], r = [], i = [], a = [], o = [], s = 0, l = t.channels.length; s < l; s++) {
                            var u = t.channels[s],
                                c = t.samplers[u.sampler],
                                h = u.target,
                                d = void 0 !== h.node ? h.node : h.id,
                                f = void 0 !== t.parameters ? t.parameters[c.input] : c.input,
                                p = void 0 !== t.parameters ? t.parameters[c.output] : c.output;
                            n.push(this.getDependency("node", d)), r.push(this.getDependency("accessor", f)), i.push(this.getDependency("accessor", p)), a.push(c), o.push(h)
                        }
                        return Promise.all([Promise.all(n), Promise.all(r), Promise.all(i), Promise.all(a), Promise.all(o)]).then(function(n) {
                            for (var r = n[0], i = n[1], a = n[2], o = n[3], s = n[4], l = [], u = 0, c = r.length; u < c; u++) ! function(e, t) {
                                var n = r[e],
                                    u = i[e],
                                    c = a[e],
                                    h = o[e],
                                    d = s[e];
                                if (void 0 !== n) {
                                    var f = void 0;
                                    switch (n.updateMatrix(), n.matrixAutoUpdate = !0, lU[d.path]) {
                                        case lU.weights:
                                            f = su;
                                            break;
                                        case lU.rotation:
                                            f = sh;
                                            break;
                                        default:
                                            f = sf
                                    }
                                    var p = n.name ? n.name : n.uuid,
                                        m = void 0 !== h.interpolation ? lB[h.interpolation] : 2301,
                                        v = [];
                                    lU[d.path] === lU.weights ? n.traverse(function(e) {
                                        e.morphTargetInfluences && v.push(e.name ? e.name : e.uuid)
                                    }) : v.push(p);
                                    var g = c.array;
                                    if (c.normalized) {
                                        for (var y = lG(g.constructor), _ = new Float32Array(g.length), x = 0, b = g.length; x < b; x++) _[x] = g[x] * y;
                                        g = _
                                    }
                                    for (var w = 0, M = v.length; w < M; w++) {
                                        var S = new f(v[w] + "." + lU[d.path], u.array, g, m);
                                        "CUBICSPLINE" === h.interpolation && (S.createInterpolant = function(e) {
                                            return new(this instanceof sh ? lP : lC)(this.times, this.values, this.getValueSize() / 3, e)
                                        }, S.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(S)
                                    }
                                }
                            }(u, 0);
                            return new sp(t.name ? t.name : "animation_" + e, void 0, l)
                        })
                    }
                }, {
                    key: "createNodeMesh",
                    value: function(e) {
                        var t = this.json,
                            n = this,
                            r = t.nodes[e];
                        return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then(function(e) {
                            var t = n._getNodeRef(n.meshCache, r.mesh, e);
                            return void 0 !== r.weights && t.traverse(function(e) {
                                if (e.isMesh)
                                    for (var t = 0, n = r.weights.length; t < n; t++) e.morphTargetInfluences[t] = r.weights[t]
                            }), t
                        })
                    }
                }, {
                    key: "loadNode",
                    value: function(e) {
                        var t, n, r = this.json,
                            i = this.extensions,
                            a = this,
                            o = r.nodes[e],
                            s = o.name ? a.createUniqueName(o.name) : "";
                        return (t = [], (n = a._invokeOne(function(t) {
                            return t.createNodeMesh && t.createNodeMesh(e)
                        })) && t.push(n), void 0 !== o.camera && t.push(a.getDependency("camera", o.camera).then(function(e) {
                            return a._getNodeRef(a.cameraCache, o.camera, e)
                        })), a._invokeAll(function(t) {
                            return t.createNodeAttachment && t.createNodeAttachment(e)
                        }).forEach(function(e) {
                            t.push(e)
                        }), Promise.all(t)).then(function(t) {
                            var n;
                            if ((n = !0 === o.isBone ? new a0 : t.length > 1 ? new aM : 1 === t.length ? t[0] : new t7) !== t[0])
                                for (var r = 0, l = t.length; r < l; r++) n.add(t[r]);
                            if (o.name && (n.userData.name = o.name, n.name = s), lH(n, o), o.extensions && lz(i, n, o), void 0 !== o.matrix) {
                                var u = new tF;
                                u.fromArray(o.matrix), n.applyMatrix4(u)
                            } else void 0 !== o.translation && n.position.fromArray(o.translation), void 0 !== o.rotation && n.quaternion.fromArray(o.rotation), void 0 !== o.scale && n.scale.fromArray(o.scale);
                            return a.associations.has(n) || a.associations.set(n, {}), a.associations.get(n).nodes = e, n
                        })
                    }
                }, {
                    key: "loadScene",
                    value: function(e) {
                        var t = this.json,
                            n = this.extensions,
                            r = this.json.scenes[e],
                            i = this,
                            a = new aM;
                        r.name && (a.name = i.createUniqueName(r.name)), lH(a, r), r.extensions && lz(n, a, r);
                        for (var o = r.nodes || [], s = [], l = 0, u = o.length; l < u; l++) s.push(function e(t, n, r, i) {
                            var a = r.nodes[t];
                            return i.getDependency("node", t).then(function(e) {
                                var t;
                                return void 0 === a.skin ? e : i.getDependency("skin", a.skin).then(function(e) {
                                    t = e;
                                    for (var n = [], r = 0, a = t.joints.length; r < a; r++) n.push(i.getDependency("node", t.joints[r]));
                                    return Promise.all(n)
                                }).then(function(n) {
                                    return e.traverse(function(e) {
                                        if (e.isMesh) {
                                            for (var r = [], i = [], a = 0, o = n.length; a < o; a++) {
                                                var s = n[a];
                                                if (s) {
                                                    r.push(s);
                                                    var l = new tF;
                                                    void 0 !== t.inverseBindMatrices && l.fromArray(t.inverseBindMatrices.array, 16 * a), i.push(l)
                                                } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[a])
                                            }
                                            e.bind(new a4(r, i), e.matrixWorld)
                                        }
                                    }), e
                                })
                            }).then(function(t) {
                                n.add(t);
                                var o = [];
                                if (a.children)
                                    for (var s = a.children, l = 0, u = s.length; l < u; l++) {
                                        var c = s[l];
                                        o.push(e(c, t, r, i))
                                    }
                                return Promise.all(o)
                            })
                        }(o[l], a, t, i));
                        return Promise.all(s).then(function() {
                            return i.associations = function(e) {
                                var t = new Map,
                                    n = !0,
                                    r = !1,
                                    a = void 0;
                                try {
                                    for (var o, s = i.associations[Symbol.iterator](); !(n = (o = s.next()).done); n = !0) {
                                        var l = (0, O._)(o.value, 2),
                                            u = l[0],
                                            c = l[1];
                                        (u instanceof nh || u instanceof te) && t.set(u, c)
                                    }
                                } catch (e) {
                                    r = !0, a = e
                                } finally {
                                    try {
                                        n || null == s.return || s.return()
                                    } finally {
                                        if (r) throw a
                                    }
                                }
                                return e.traverse(function(e) {
                                    var n = i.associations.get(e);
                                    null != n && t.set(e, n)
                                }), t
                            }(a), a
                        })
                    }
                }]), e
            }();

            function lj(e, t, n) {
                var r = t.attributes,
                    i = [];
                for (var a in r) {
                    var o = lF[a] || a.toLowerCase();
                    o in e.attributes || i.push(function(t, r) {
                        return n.getDependency("accessor", t).then(function(t) {
                            e.setAttribute(r, t)
                        })
                    }(r[a], o))
                }
                if (void 0 !== t.indices && !e.index) {
                    var s = n.getDependency("accessor", t.indices).then(function(t) {
                        e.setIndex(t)
                    });
                    i.push(s)
                }
                return lH(e, t),
                    function(e, t, n) {
                        var r = t.attributes,
                            i = new tu;
                        if (void 0 !== r.POSITION) {
                            var a = n.json.accessors[r.POSITION],
                                o = a.min,
                                s = a.max;
                            if (void 0 === o || void 0 === s) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                            if (i.set(new to(o[0], o[1], o[2]), new to(s[0], s[1], s[2])), a.normalized) {
                                var l = lG(lI[a.componentType]);
                                i.min.multiplyScalar(l), i.max.multiplyScalar(l)
                            }
                            var u = t.targets;
                            if (void 0 !== u) {
                                for (var c = new to, h = new to, d = 0, f = u.length; d < f; d++) {
                                    var p = u[d];
                                    if (void 0 !== p.POSITION) {
                                        var m = n.json.accessors[p.POSITION],
                                            v = m.min,
                                            g = m.max;
                                        if (void 0 !== v && void 0 !== g) {
                                            if (h.setX(Math.max(Math.abs(v[0]), Math.abs(g[0]))), h.setY(Math.max(Math.abs(v[1]), Math.abs(g[1]))), h.setZ(Math.max(Math.abs(v[2]), Math.abs(g[2]))), m.normalized) {
                                                var y = lG(lI[m.componentType]);
                                                h.multiplyScalar(y)
                                            }
                                            c.max(h)
                                        } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                                    }
                                }
                                i.expandByVector(c)
                            }
                            e.boundingBox = i;
                            var _ = new tA;
                            i.getCenter(_.center), _.radius = i.min.distanceTo(i.max) / 2, e.boundingSphere = _
                        }
                    }(e, t, n), Promise.all(i).then(function() {
                        return void 0 !== t.targets ? function(e, t, n) {
                            for (var r = !1, i = !1, a = 0, o = t.length; a < o; a++) {
                                var s = t[a];
                                if (void 0 !== s.POSITION && (r = !0), void 0 !== s.NORMAL && (i = !0), r && i) break
                            }
                            if (!r && !i) return Promise.resolve(e);
                            for (var l = [], u = [], c = 0, h = t.length; c < h; c++) {
                                var d = t[c];
                                if (r) {
                                    var f = void 0 !== d.POSITION ? n.getDependency("accessor", d.POSITION) : e.attributes.position;
                                    l.push(f)
                                }
                                if (i) {
                                    var p = void 0 !== d.NORMAL ? n.getDependency("accessor", d.NORMAL) : e.attributes.normal;
                                    u.push(p)
                                }
                            }
                            return Promise.all([Promise.all(l), Promise.all(u)]).then(function(t) {
                                var n = t[0],
                                    a = t[1];
                                return r && (e.morphAttributes.position = n), i && (e.morphAttributes.normal = a), e.morphTargetsRelative = !0, e
                            })
                        }(e, t.targets, n) : e
                    })
            }

            function lq(e, t) {
                var n = e.getIndex();
                if (null === n) {
                    var r = [],
                        i = e.getAttribute("position");
                    if (void 0 === i) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
                    for (var a = 0; a < i.count; a++) r.push(a);
                    e.setIndex(r), n = e.getIndex()
                }
                var o = n.count - 2,
                    s = [];
                if (2 === t)
                    for (var l = 1; l <= o; l++) s.push(n.getX(0)), s.push(n.getX(l)), s.push(n.getX(l + 1));
                else
                    for (var u = 0; u < o; u++) u % 2 == 0 ? (s.push(n.getX(u)), s.push(n.getX(u + 1)), s.push(n.getX(u + 2))) : (s.push(n.getX(u + 2)), s.push(n.getX(u + 1)), s.push(n.getX(u)));
                s.length / 3 !== o && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                var c = e.clone();
                return c.setIndex(s), c
            }
            var lX = function() {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 4;
                        (0, k._)(this, e), this.pool = t, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0
                    }
                    return (0, A._)(e, [{
                        key: "_initWorker",
                        value: function(e) {
                            if (!this.workers[e]) {
                                var t = this.workerCreator();
                                t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t
                            }
                        }
                    }, {
                        key: "_getIdleWorker",
                        value: function() {
                            for (var e = 0; e < this.pool; e++)
                                if (!(this.workerStatus & 1 << e)) return e;
                            return -1
                        }
                    }, {
                        key: "_onMessage",
                        value: function(e, t) {
                            var n = this.workersResolve[e];
                            if (n && n(t), this.queue.length) {
                                var r = this.queue.shift(),
                                    i = r.resolve,
                                    a = r.msg,
                                    o = r.transfer;
                                this.workersResolve[e] = i, this.workers[e].postMessage(a, o)
                            } else this.workerStatus ^= 1 << e
                        }
                    }, {
                        key: "setWorkerCreator",
                        value: function(e) {
                            this.workerCreator = e
                        }
                    }, {
                        key: "setWorkerLimit",
                        value: function(e) {
                            this.pool = e
                        }
                    }, {
                        key: "postMessage",
                        value: function(e, t) {
                            var n = this;
                            return new Promise(function(r) {
                                var i = n._getIdleWorker(); - 1 !== i ? (n._initWorker(i), n.workerStatus |= 1 << i, n.workersResolve[i] = r, n.workers[i].postMessage(e, t)) : n.queue.push({
                                    resolve: r,
                                    msg: e,
                                    transfer: t
                                })
                            })
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            this.workers.forEach(function(e) {
                                return e.terminate()
                            }), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0
                        }
                    }]), e
                }(),
                lY = new WeakMap,
                lJ = 0,
                lZ = function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t, [e])).transcoderPath = "", n.transcoderBinary = null, n.transcoderPending = null, n.workerPool = new lX, n.workerSourceURL = "", n.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "setTranscoderPath",
                        value: function(e) {
                            return this.transcoderPath = e, this
                        }
                    }, {
                        key: "setWorkerLimit",
                        value: function(e) {
                            return this.workerPool.setWorkerLimit(e), this
                        }
                    }, {
                        key: "detectSupport",
                        value: function(e) {
                            return this.workerConfig = {
                                astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
                                etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
                                etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
                                dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
                                bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
                                pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
                            }, e.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1), this
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            return URL.revokeObjectURL(this.workerSourceURL), this.workerPool.dispose(), lJ--, this
                        }
                    }, {
                        key: "init",
                        value: function() {
                            var e = this;
                            if (!this.transcoderPending) {
                                var n = new s_(this.manager);
                                n.setPath(this.transcoderPath), n.setWithCredentials(this.withCredentials);
                                var r = n.loadAsync("basis_transcoder.js"),
                                    i = new s_(this.manager);
                                i.setPath(this.transcoderPath), i.setResponseType("arraybuffer"), i.setWithCredentials(this.withCredentials);
                                var a = i.loadAsync("basis_transcoder.wasm");
                                this.transcoderPending = Promise.all([r, a]).then(function(n) {
                                    var r = (0, O._)(n, 2),
                                        i = r[0],
                                        a = r[1],
                                        o = t.BasisWorker.toString(),
                                        s = ["/* constants */", "let _EngineFormat = " + JSON.stringify(t.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(t.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(t.BasisFormat), "/* basis_transcoder.js */", i, "/* worker */", o.substring(o.indexOf("{") + 1, o.lastIndexOf("}"))].join("\n");
                                    e.workerSourceURL = URL.createObjectURL(new Blob([s])), e.transcoderBinary = a, e.workerPool.setWorkerCreator(function() {
                                        var t = new Worker(e.workerSourceURL),
                                            n = e.transcoderBinary.slice(0);
                                        return t.postMessage({
                                            type: "init",
                                            config: e.workerConfig,
                                            transcoderBinary: n
                                        }, [n]), t
                                    })
                                }), lJ > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), lJ++
                            }
                            return this.transcoderPending
                        }
                    }, {
                        key: "load",
                        value: function(e, t, n, r) {
                            var i = this;
                            if (null === this.workerConfig) throw Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
                            var a = new s_(this.manager);
                            a.setResponseType("arraybuffer"), a.setWithCredentials(this.withCredentials);
                            var o = new oy;
                            return a.load(e, function(e) {
                                if (lY.has(e)) return lY.get(e).promise.then(t).catch(r);
                                i._createTexture([e]).then(function(e) {
                                    o.copy(e), o.needsUpdate = !0, t && t(o)
                                }).catch(r)
                            }, n, r), o
                        }
                    }, {
                        key: "_createTextureFrom",
                        value: function(e) {
                            var t = e.mipmaps,
                                n = e.width,
                                r = e.height,
                                i = e.format,
                                a = e.type,
                                o = e.error,
                                s = e.dfdTransferFn,
                                l = e.dfdFlags;
                            if ("error" === a) return Promise.reject(o);
                            var u = new oy(t, n, r, i, 1009);
                            return u.minFilter = 1 === t.length ? 1006 : 1008, u.magFilter = 1006, u.generateMipmaps = !1, u.needsUpdate = !0, u.encoding = 2 === s ? 3001 : 3e3, u.premultiplyAlpha = !!(1 & l), u
                        }
                    }, {
                        key: "_createTexture",
                        value: function(e) {
                            var t = this,
                                n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                                r = this.init().then(function() {
                                    return t.workerPool.postMessage({
                                        type: "transcode",
                                        buffers: e,
                                        taskConfig: n
                                    }, e)
                                }).then(function(e) {
                                    return t._createTextureFrom(e.data)
                                });
                            return lY.set(e[0], {
                                promise: r
                            }), r
                        }
                    }]), t
                }(sg);
            lZ.BasisFormat = {
                ETC1S: 0,
                UASTC_4x4: 1
            }, lZ.TranscoderFormat = {
                ETC1: 0,
                ETC2: 1,
                BC1: 2,
                BC3: 3,
                BC4: 4,
                BC5: 5,
                BC7_M6_OPAQUE_ONLY: 6,
                BC7_M5: 7,
                PVRTC1_4_RGB: 8,
                PVRTC1_4_RGBA: 9,
                ASTC_4x4: 10,
                ATC_RGB: 11,
                ATC_RGBA_INTERPOLATED_ALPHA: 12,
                RGBA32: 13,
                RGB565: 14,
                BGR565: 15,
                RGBA4444: 16
            }, lZ.EngineFormat = {
                RGBAFormat: 1023,
                RGBA_ASTC_4x4_Format: 37808,
                RGBA_BPTC_Format: 36492,
                RGBA_ETC2_EAC_Format: 37496,
                RGBA_PVRTC_4BPPV1_Format: 35842,
                RGBA_S3TC_DXT5_Format: 33779,
                RGB_ETC1_Format: 36196,
                RGB_ETC2_Format: 37492,
                RGB_PVRTC_4BPPV1_Format: 35840,
                RGB_S3TC_DXT1_Format: 33776
            }, lZ.BasisWorker = function() {
                var e, t, n, r = _EngineFormat,
                    i = _TranscoderFormat,
                    a = _BasisFormat;
                self.addEventListener("message", function(o) {
                    var c, h = o.data;
                    switch (h.type) {
                        case "init":
                            e = h.config, c = h.transcoderBinary, t = new Promise(function(e) {
                                BASIS(n = {
                                    wasmBinary: c,
                                    onRuntimeInitialized: e
                                })
                            }).then(function() {
                                n.initializeBasis(), void 0 === n.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")
                            });
                            break;
                        case "transcode":
                            t.then(function() {
                                try {
                                    for (var t = function(t) {
                                            var o = new n.KTX2File(new Uint8Array(t));

                                            function c() {
                                                o.close(), o.delete()
                                            }
                                            if (!o.isValid()) throw c(), Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
                                            var h = o.isUASTC() ? a.UASTC_4x4 : a.ETC1S,
                                                d = o.getWidth(),
                                                f = o.getHeight(),
                                                p = o.getLevels(),
                                                m = o.getHasAlpha(),
                                                v = o.getDFDTransferFunc(),
                                                g = o.getDFDFlags(),
                                                y = function(t, n, o, c) {
                                                    for (var h, d, f = t === a.ETC1S ? s : l, p = 0; p < f.length; p++) {
                                                        var m = f[p];
                                                        if (e[m.if] && m.basisFormat.includes(t) && !(c && m.transcoderFormat.length < 2) && (!m.needsPowerOfTwo || u(n) && u(o))) return h = m.transcoderFormat[c ? 1 : 0], d = m.engineFormat[c ? 1 : 0], {
                                                            transcoderFormat: h,
                                                            engineFormat: d
                                                        }
                                                    }
                                                    return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), h = i.RGBA32, d = r.RGBAFormat, {
                                                        transcoderFormat: h,
                                                        engineFormat: d
                                                    }
                                                }(h, d, f, m),
                                                _ = y.transcoderFormat,
                                                x = y.engineFormat;
                                            if (!d || !f || !p) throw c(), Error("THREE.KTX2Loader:	Invalid texture");
                                            if (!o.startTranscoding()) throw c(), Error("THREE.KTX2Loader: .startTranscoding failed");
                                            for (var b = [], w = 0; w < p; w++) {
                                                var M = o.getImageLevelInfo(w, 0, 0),
                                                    S = M.origWidth,
                                                    T = M.origHeight,
                                                    E = new Uint8Array(o.getImageTranscodedSizeInBytes(w, 0, 0, _));
                                                if (!o.transcodeImage(E, w, 0, 0, _, 0, -1, -1)) throw c(), Error("THREE.KTX2Loader: .transcodeImage failed.");
                                                b.push({
                                                    data: E,
                                                    width: S,
                                                    height: T
                                                })
                                            }
                                            return c(), {
                                                width: d,
                                                height: f,
                                                hasAlpha: m,
                                                mipmaps: b,
                                                format: x,
                                                dfdTransferFn: v,
                                                dfdFlags: g
                                            }
                                        }(h.buffers[0]), o = t.width, c = t.height, d = t.hasAlpha, f = t.mipmaps, p = t.format, m = t.dfdTransferFn, v = t.dfdFlags, g = [], y = 0; y < f.length; ++y) g.push(f[y].data.buffer);
                                    self.postMessage({
                                        type: "transcode",
                                        id: h.id,
                                        width: o,
                                        height: c,
                                        hasAlpha: d,
                                        mipmaps: f,
                                        format: p,
                                        dfdTransferFn: m,
                                        dfdFlags: v
                                    }, g)
                                } catch (e) {
                                    console.error(e), self.postMessage({
                                        type: "error",
                                        id: h.id,
                                        error: e.message
                                    })
                                }
                            })
                    }
                });
                var o = [{
                        if: "astcSupported",
                        basisFormat: [a.UASTC_4x4],
                        transcoderFormat: [i.ASTC_4x4, i.ASTC_4x4],
                        engineFormat: [r.RGBA_ASTC_4x4_Format, r.RGBA_ASTC_4x4_Format],
                        priorityETC1S: 1 / 0,
                        priorityUASTC: 1,
                        needsPowerOfTwo: !1
                    }, {
                        if: "bptcSupported",
                        basisFormat: [a.ETC1S, a.UASTC_4x4],
                        transcoderFormat: [i.BC7_M5, i.BC7_M5],
                        engineFormat: [r.RGBA_BPTC_Format, r.RGBA_BPTC_Format],
                        priorityETC1S: 3,
                        priorityUASTC: 2,
                        needsPowerOfTwo: !1
                    }, {
                        if: "dxtSupported",
                        basisFormat: [a.ETC1S, a.UASTC_4x4],
                        transcoderFormat: [i.BC1, i.BC3],
                        engineFormat: [r.RGB_S3TC_DXT1_Format, r.RGBA_S3TC_DXT5_Format],
                        priorityETC1S: 4,
                        priorityUASTC: 5,
                        needsPowerOfTwo: !1
                    }, {
                        if: "etc2Supported",
                        basisFormat: [a.ETC1S, a.UASTC_4x4],
                        transcoderFormat: [i.ETC1, i.ETC2],
                        engineFormat: [r.RGB_ETC2_Format, r.RGBA_ETC2_EAC_Format],
                        priorityETC1S: 1,
                        priorityUASTC: 3,
                        needsPowerOfTwo: !1
                    }, {
                        if: "etc1Supported",
                        basisFormat: [a.ETC1S, a.UASTC_4x4],
                        transcoderFormat: [i.ETC1],
                        engineFormat: [r.RGB_ETC1_Format],
                        priorityETC1S: 2,
                        priorityUASTC: 4,
                        needsPowerOfTwo: !1
                    }, {
                        if: "pvrtcSupported",
                        basisFormat: [a.ETC1S, a.UASTC_4x4],
                        transcoderFormat: [i.PVRTC1_4_RGB, i.PVRTC1_4_RGBA],
                        engineFormat: [r.RGB_PVRTC_4BPPV1_Format, r.RGBA_PVRTC_4BPPV1_Format],
                        priorityETC1S: 5,
                        priorityUASTC: 6,
                        needsPowerOfTwo: !0
                    }],
                    s = o.sort(function(e, t) {
                        return e.priorityETC1S - t.priorityETC1S
                    }),
                    l = o.sort(function(e, t) {
                        return e.priorityUASTC - t.priorityUASTC
                    });

                function u(e) {
                    return e <= 2 || 0 == (e & e - 1) && 0 !== e
                }
            };
            var lK = Symbol("retainerCount"),
                lQ = Symbol("recentlyUsed"),
                l$ = Symbol("evict"),
                l0 = Symbol("evictionThreshold"),
                l1 = Symbol("cache"),
                l2 = function() {
                    function e(t) {
                        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5;
                        (0, k._)(this, e), this[ck] = new Map, this[cA] = [], this[l1] = t, this[l0] = n
                    }
                    return (0, A._)(e, [{
                        key: "evictionThreshold",
                        get: function() {
                            return this[l0]
                        },
                        set: function(e) {
                            this[l0] = e, this[l$]()
                        }
                    }, {
                        key: "cache",
                        get: function() {
                            return this[l1]
                        }
                    }, {
                        key: "retainerCount",
                        value: function(e) {
                            return this[lK].get(e) || 0
                        }
                    }, {
                        key: "reset",
                        value: function() {
                            this[lK].clear(), this[lQ] = []
                        }
                    }, {
                        key: "retain",
                        value: function(e) {
                            this[lK].has(e) || this[lK].set(e, 0), this[lK].set(e, this[lK].get(e) + 1);
                            var t = this[lQ].indexOf(e); - 1 !== t && this[lQ].splice(t, 1), this[lQ].unshift(e), this[l$]()
                        }
                    }, {
                        key: "release",
                        value: function(e) {
                            this[lK].has(e) && this[lK].set(e, Math.max(this[lK].get(e) - 1, 0)), this[l$]()
                        }
                    }, {
                        key: (ck = lK, cA = lQ, l$),
                        value: function() {
                            if (!(this[lQ].length < this[l0]))
                                for (var e = this[lQ].length - 1; e >= this[l0]; --e) {
                                    var t = this[lQ][e];
                                    0 === this[lK].get(t) && (this[l1].delete(t), this[lQ].splice(e, 1))
                                }
                        }
                    }]), e
                }(),
                l3 = function(e) {
                    var t = new Map,
                        n = !0,
                        r = !1,
                        i = void 0,
                        a = !0,
                        o = !1,
                        s = void 0;
                    try {
                        for (var l, u = e.mappings[Symbol.iterator](); !(a = (l = u.next()).done); a = !0) {
                            var c = l.value;
                            try {
                                for (var h, d = c.variants[Symbol.iterator](); !(n = (h = d.next()).done); n = !0) {
                                    var f = h.value;
                                    t.set(f, {
                                        material: null,
                                        gltfMaterialIndex: c.material
                                    })
                                }
                            } catch (e) {
                                r = !0, i = e
                            } finally {
                                try {
                                    n || null == d.return || d.return()
                                } finally {
                                    if (r) throw i
                                }
                            }
                        }
                    } catch (e) {
                        o = !0, s = e
                    } finally {
                        try {
                            a || null == u.return || u.return()
                        } finally {
                            if (o) throw s
                        }
                    }
                    return t
                },
                l4 = function() {
                    function e(t) {
                        (0, k._)(this, e), this.parser = t, this.name = "KHR_materials_variants"
                    }
                    return (0, A._)(e, [{
                        key: "afterRoot",
                        value: function(e) {
                            var t = this,
                                n = this.parser,
                                r = n.json;
                            if (void 0 === r.extensions || void 0 === r.extensions[this.name]) return null;
                            var i = function(e) {
                                    var t = [],
                                        n = new Set,
                                        r = !0,
                                        i = !1,
                                        a = void 0;
                                    try {
                                        for (var o, s = e[Symbol.iterator](); !(r = (o = s.next()).done); r = !0) {
                                            for (var l = o.value, u = l, c = 0; n.has(u);) u = l + "." + ++c;
                                            n.add(u), t.push(u)
                                        }
                                    } catch (e) {
                                        i = !0, a = e
                                    } finally {
                                        try {
                                            r || null == s.return || s.return()
                                        } finally {
                                            if (i) throw a
                                        }
                                    }
                                    return t
                                }((r.extensions[this.name].variants || []).map(function(e) {
                                    return e.name
                                })),
                                a = !0,
                                o = !1,
                                s = void 0;
                            try {
                                for (var l, u = e.scenes[Symbol.iterator](); !(a = (l = u.next()).done); a = !0) l.value.traverse(function(e) {
                                    var i = n.associations.get(e);
                                    if (null != i && null != i.meshes)
                                        for (var a = i.meshes, o = r.meshes[a].primitives, s = ("isMesh" in e) ? [e] : e.children, l = 0; l < o.length; l++) {
                                            var u = o[l].extensions;
                                            u && u[t.name] && (s[l].userData.variantMaterials = l3(u[t.name]))
                                        }
                                })
                            } catch (e) {
                                o = !0, s = e
                            } finally {
                                try {
                                    a || null == u.return || u.return()
                                } finally {
                                    if (o) throw s
                                }
                            }
                            return e.userData.variants = i, Promise.resolve()
                        }
                    }]), e
                }(),
                l5 = new Map,
                l6 = new Map,
                l8 = new(function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t, [e])).decoderPath = "", n.decoderConfig = {}, n.decoderBinary = null, n.decoderPending = null, n.workerLimit = 4, n.workerPool = [], n.workerNextTaskID = 1, n.workerSourceURL = "", n.defaultAttributeIDs = {
                            position: "POSITION",
                            normal: "NORMAL",
                            color: "COLOR",
                            uv: "TEX_COORD"
                        }, n.defaultAttributeTypes = {
                            position: "Float32Array",
                            normal: "Float32Array",
                            color: "Float32Array",
                            uv: "Float32Array"
                        }, n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "setDecoderPath",
                        value: function(e) {
                            return this.decoderPath = e, this
                        }
                    }, {
                        key: "setDecoderConfig",
                        value: function(e) {
                            return this.decoderConfig = e, this
                        }
                    }, {
                        key: "setWorkerLimit",
                        value: function(e) {
                            return this.workerLimit = e, this
                        }
                    }, {
                        key: "load",
                        value: function(e, t, n, r) {
                            var i = this,
                                a = new s_(this.manager);
                            a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(e) {
                                var n = {
                                    attributeIDs: i.defaultAttributeIDs,
                                    attributeTypes: i.defaultAttributeTypes,
                                    useUniqueIDs: !1
                                };
                                i.decodeGeometry(e, n).then(t).catch(r)
                            }, n, r)
                        }
                    }, {
                        key: "decodeDracoFile",
                        value: function(e, t, n, r) {
                            var i = {
                                attributeIDs: n || this.defaultAttributeIDs,
                                attributeTypes: r || this.defaultAttributeTypes,
                                useUniqueIDs: !!n
                            };
                            this.decodeGeometry(e, i).then(t)
                        }
                    }, {
                        key: "decodeGeometry",
                        value: function(e, t) {
                            var n, r = this;
                            for (var i in t.attributeTypes) {
                                var a = t.attributeTypes[i];
                                void 0 !== a.BYTES_PER_ELEMENT && (t.attributeTypes[i] = a.name)
                            }
                            var o = JSON.stringify(t);
                            if (ls.has(e)) {
                                var s = ls.get(e);
                                if (s.key === o) return s.promise;
                                if (0 === e.byteLength) throw Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                            }
                            var l = this.workerNextTaskID++,
                                u = e.byteLength,
                                c = this._getWorker(l, u).then(function(r) {
                                    return n = r, new Promise(function(r, i) {
                                        n._callbacks[l] = {
                                            resolve: r,
                                            reject: i
                                        }, n.postMessage({
                                            type: "decode",
                                            id: l,
                                            taskConfig: t,
                                            buffer: e
                                        }, [e])
                                    })
                                }).then(function(e) {
                                    return r._createGeometry(e.geometry)
                                });
                            return c.catch(function() {
                                return !0
                            }).then(function() {
                                n && l && r._releaseTask(n, l)
                            }), ls.set(e, {
                                key: o,
                                promise: c
                            }), c
                        }
                    }, {
                        key: "_createGeometry",
                        value: function(e) {
                            var t = new nI;
                            e.index && t.setIndex(new nw(e.index.array, 1));
                            for (var n = 0; n < e.attributes.length; n++) {
                                var r = e.attributes[n],
                                    i = r.name,
                                    a = r.array,
                                    o = r.itemSize;
                                t.setAttribute(i, new nw(a, o))
                            }
                            return t
                        }
                    }, {
                        key: "_loadLibrary",
                        value: function(e, t) {
                            var n = new s_(this.manager);
                            return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise(function(t, r) {
                                n.load(e, t, void 0, r)
                            })
                        }
                    }, {
                        key: "preload",
                        value: function() {
                            return this._initDecoder(), this
                        }
                    }, {
                        key: "_initDecoder",
                        value: function() {
                            var e = this;
                            if (this.decoderPending) return this.decoderPending;
                            var t = "object" != ("undefined" == typeof WebAssembly ? "undefined" : (0, U._)(WebAssembly)) || "js" === this.decoderConfig.type,
                                n = [];
                            return t ? n.push(this._loadLibrary("draco_decoder.js", "text")) : (n.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), n.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(n).then(function(n) {
                                var r = n[0];
                                t || (e.decoderConfig.wasmBinary = n[1]);
                                var i = ll.toString(),
                                    a = ["/* draco decoder */", r, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                                e.workerSourceURL = URL.createObjectURL(new Blob([a]))
                            }), this.decoderPending
                        }
                    }, {
                        key: "_getWorker",
                        value: function(e, t) {
                            var n = this;
                            return this._initDecoder().then(function() {
                                if (n.workerPool.length < n.workerLimit) {
                                    var r = new Worker(n.workerSourceURL);
                                    r._callbacks = {}, r._taskCosts = {}, r._taskLoad = 0, r.postMessage({
                                        type: "init",
                                        decoderConfig: n.decoderConfig
                                    }), r.onmessage = function(e) {
                                        var t = e.data;
                                        switch (t.type) {
                                            case "decode":
                                                r._callbacks[t.id].resolve(t);
                                                break;
                                            case "error":
                                                r._callbacks[t.id].reject(t);
                                                break;
                                            default:
                                                console.error('THREE.DRACOLoader: Unexpected message, "' + t.type + '"')
                                        }
                                    }, n.workerPool.push(r)
                                } else n.workerPool.sort(function(e, t) {
                                    return e._taskLoad > t._taskLoad ? -1 : 1
                                });
                                var i = n.workerPool[n.workerPool.length - 1];
                                return i._taskCosts[e] = t, i._taskLoad += t, i
                            })
                        }
                    }, {
                        key: "_releaseTask",
                        value: function(e, t) {
                            e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
                        }
                    }, {
                        key: "debug",
                        value: function() {
                            console.log("Task load: ", this.workerPool.map(function(e) {
                                return e._taskLoad
                            }))
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            for (var e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
                            return this.workerPool.length = 0, this
                        }
                    }]), t
                }(sg)),
                l7 = new lZ,
                l9 = Symbol("loader"),
                ue = Symbol("evictionPolicy"),
                ut = Symbol("GLTFInstance"),
                un = function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t))[cC] = (new lu).register(function(e) {
                            return new l4(e)
                        }), n[ut] = e, n[l9].setDRACOLoader(l8), n[l9].setKTX2Loader(l7), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: (cR = ue, cC = l9, ue),
                        get: function() {
                            return this.constructor[ue]
                        }
                    }, {
                        key: "preload",
                        value: function(e, t) {
                            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function() {},
                                r = this;
                            return (0, T._)(function() {
                                var i, a, o, s, l;
                                return (0, z.YH)(this, function(u) {
                                    switch (u.label) {
                                        case 0:
                                            if (r.dispatchEvent({
                                                    type: "preload",
                                                    element: t,
                                                    src: e
                                                }), l5.has(e)) return [3, 3];
                                            if (!(null != cD)) return [3, 2];
                                            return a = (i = r[l9]).setMeshoptDecoder, [4, cD];
                                        case 1:
                                            a.apply(i, [u.sent()]), u.label = 2;
                                        case 2:
                                            o = function(e, t) {
                                                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function() {},
                                                    r = function(e) {
                                                        var t = e.loaded / e.total;
                                                        n(Math.max(0, Math.min(1, isFinite(t) ? t : 1)))
                                                    };
                                                return new Promise(function(n, i) {
                                                    t.load(e, n, r, i)
                                                })
                                            }(e, r[l9], function(e) {
                                                n(.8 * e)
                                            }), s = r[ut], l = o.then(function(e) {
                                                return s.prepare(e)
                                            }).then(function(e) {
                                                return n(.9), new s(e)
                                            }), l5.set(e, l), u.label = 3;
                                        case 3:
                                            return [4, l5.get(e)];
                                        case 4:
                                            return u.sent(), l6.set(e, !0), n && n(1), [2]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "load",
                        value: function(e, t) {
                            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function() {},
                                r = this;
                            return (0, T._)(function() {
                                var i;
                                return (0, z.YH)(this, function(a) {
                                    switch (a.label) {
                                        case 0:
                                            return [4, r.preload(e, t, n)];
                                        case 1:
                                            return a.sent(), [4, l5.get(e)];
                                        case 2:
                                            return [4, a.sent().clone()];
                                        case 3:
                                            var o, s;
                                            return i = a.sent(), [2, (r[ue].retain(e), i.dispose = (o = i.dispose, s = !1, function() {
                                                s || (s = !0, o.apply(i), r[ue].release(e))
                                            }), i)]
                                    }
                                })
                            })()
                        }
                    }], [{
                        key: "setDRACODecoderLocation",
                        value: function(e) {
                            cL = e, l8.setDecoderPath(e)
                        }
                    }, {
                        key: "getDRACODecoderLocation",
                        value: function() {
                            return cL
                        }
                    }, {
                        key: "setKTX2TranscoderLocation",
                        value: function(e) {
                            cP = e, l7.setTranscoderPath(e)
                        }
                    }, {
                        key: "getKTX2TranscoderLocation",
                        value: function() {
                            return cP
                        }
                    }, {
                        key: "setMeshoptDecoderLocation",
                        value: function(e) {
                            cI !== e && (cI = e, cD = new Promise(function(t, n) {
                                var r = document.createElement("script");
                                document.body.appendChild(r), r.onload = t, r.onerror = n, r.async = !0, r.src = e
                            }).then(function() {
                                return MeshoptDecoder.ready
                            }).then(function() {
                                return MeshoptDecoder
                            }))
                        }
                    }, {
                        key: "getMeshoptDecoderLocation",
                        value: function() {
                            return cI
                        }
                    }, {
                        key: "initializeKTX2Loader",
                        value: function(e) {
                            l7.detectSupport(e)
                        }
                    }, {
                        key: "cache",
                        get: function() {
                            return l5
                        }
                    }, {
                        key: "clearCache",
                        value: function() {
                            var e = this;
                            l5.forEach(function(t, n) {
                                e.delete(n)
                            }), this[ue].reset()
                        }
                    }, {
                        key: "has",
                        value: function(e) {
                            return l5.has(e)
                        }
                    }, {
                        key: "delete",
                        value: function(e) {
                            var t = this;
                            return (0, T._)(function() {
                                var n;
                                return (0, z.YH)(this, function(r) {
                                    switch (r.label) {
                                        case 0:
                                            if (!t.has(e)) return [2];
                                            return n = l5.get(e), l6.delete(e), l5.delete(e), [4, n];
                                        case 1:
                                            return r.sent().dispose(), [2]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "hasFinishedLoading",
                        value: function(e) {
                            return !!l6.get(e)
                        }
                    }]), t
                }(eW);
            un[cR] = new l2(un);
            var ur = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document.createElement("div");
                    return (0, k._)(this, t), (e = (0, E._)(this, t)).element = n, e.element.style.position = "absolute", e.element.style.userSelect = "none", e.element.setAttribute("draggable", !1), e.addEventListener("removed", function() {
                        this.traverse(function(e) {
                            e.element instanceof Element && null !== e.element.parentNode && e.element.parentNode.removeChild(e.element)
                        })
                    }), e
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "copy",
                    value: function(e, n) {
                        return L((0, C._)(t.prototype), "copy", this).call(this, e, n), this.element = e.element.cloneNode(!0), this
                    }
                }]), t
            }(t7);
            ur.prototype.isCSS2DObject = !0;
            var ui = new to,
                ua = new tF,
                uo = new tF,
                us = new to,
                ul = new to,
                uu = function e() {
                    var t, n, r, i, a = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    (0, k._)(this, e);
                    var o = this,
                        s = {
                            objects: new WeakMap
                        },
                        l = void 0 !== a.element ? a.element : document.createElement("div");
                    l.style.overflow = "hidden", this.domElement = l, this.getSize = function() {
                        return {
                            width: t,
                            height: n
                        }
                    }, this.render = function(e, t) {
                        !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), ua.copy(t.matrixWorldInverse), uo.multiplyMatrices(t.projectionMatrix, ua),
                            function e(t, n, a) {
                                if (t.isCSS2DObject) {
                                    t.onBeforeRender(o, n, a), ui.setFromMatrixPosition(t.matrixWorld), ui.applyMatrix4(uo);
                                    var u = t.element;
                                    /apple/i.test(navigator.vendor) ? u.style.transform = "translate(-50%,-50%) translate(" + Math.round(ui.x * r + r) + "px," + Math.round(-ui.y * i + i) + "px)" : u.style.transform = "translate(-50%,-50%) translate(" + (ui.x * r + r) + "px," + (-ui.y * i + i) + "px)", u.style.display = t.visible && ui.z >= -1 && ui.z <= 1 ? "" : "none";
                                    var c = {
                                        distanceToCameraSquared: (us.setFromMatrixPosition(a.matrixWorld), ul.setFromMatrixPosition(t.matrixWorld), us.distanceToSquared(ul))
                                    };
                                    s.objects.set(t, c), u.parentNode !== l && l.appendChild(u), t.onAfterRender(o, n, a)
                                }
                                for (var h = 0, d = t.children.length; h < d; h++) e(t.children[h], n, a)
                            }(e, e, t),
                            function(e) {
                                for (var t, n = (t = [], e.traverse(function(e) {
                                        e.isCSS2DObject && t.push(e)
                                    }), t).sort(function(e, t) {
                                        return s.objects.get(e).distanceToCameraSquared - s.objects.get(t).distanceToCameraSquared
                                    }), r = n.length, i = 0, a = n.length; i < a; i++) n[i].element.style.zIndex = r - i
                            }(e)
                    }, this.setSize = function(e, a) {
                        t = e, n = a, r = t / 2, i = n / 2, l.style.width = e + "px", l.style.height = a + "px"
                    }
                },
                uc = function(e) {
                    return e && "null" !== e ? ud(e) : null
                },
                uh = function() {
                    if (!s8) {
                        var e = [];
                        throw s6 || e.push("WebXR Device API"), s8 || e.push("WebXR Hit Test API"), Error("The following APIs are required for AR, but are missing in this browser: ".concat(e.join(", ")))
                    }
                },
                ud = function(e) {
                    return new URL(e, window.location.toString()).toString()
                },
                uf = function(e, t) {
                    var n = null;
                    return function() {
                        for (var r = arguments.length, i = Array(r), a = 0; a < r; a++) i[a] = arguments[a];
                        null != n && self.clearTimeout(n), n = self.setTimeout(function() {
                            n = null, e.apply(void 0, (0, F._)(i))
                        }, t)
                    }
                },
                up = function(e, t, n) {
                    return Math.max(t, Math.min(n, e))
                },
                um = function() {
                    var e = function() {
                        var e = null != document.head ? Array.from(document.head.querySelectorAll("meta")) : [],
                            t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = e[Symbol.iterator](); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                if ("viewport" === o.name) return !0
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                        return !1
                    }();
                    return e || console.warn('No <meta name="viewport"> detected; <model-viewer> will cap pixel density at 1.'),
                        function() {
                            return e ? window.devicePixelRatio : 1
                        }
                }(),
                uv = function() {
                    var e = RegExp("[?&]model-viewer-debug-mode(&|$)");
                    return function() {
                        return self.ModelViewerElement && self.ModelViewerElement.debugMode || self.location && self.location.search && self.location.search.match(e)
                    }
                }(),
                ug = function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                    return new Promise(function(t) {
                        return setTimeout(t, e)
                    })
                },
                uy = function() {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 50;
                        (0, k._)(this, e), this.velocity = 0, this.naturalFrequency = 0, this.setDecayTime(t)
                    }
                    return (0, A._)(e, [{
                        key: "setDecayTime",
                        value: function(e) {
                            this.naturalFrequency = 1 / Math.max(.001, e)
                        }
                    }, {
                        key: "update",
                        value: function(e, t, n, r) {
                            var i = 2e-4 * this.naturalFrequency;
                            if (null == e || 0 === r || e === t && 0 === this.velocity) return t;
                            if (n < 0) return e;
                            var a = e - t,
                                o = this.velocity + this.naturalFrequency * a,
                                s = a + n * o,
                                l = Math.exp(-this.naturalFrequency * n),
                                u = (o - this.naturalFrequency * s) * l,
                                c = -this.naturalFrequency * (u + o * l);
                            return Math.abs(u) < i * Math.abs(r) && c * a >= 0 ? (this.velocity = 0, t) : (this.velocity = u, t + s * l)
                        }
                    }]), e
                }(),
                u_ = function(e, t) {
                    return {
                        type: "number",
                        number: e,
                        unit: t
                    }
                },
                ux = function() {
                    var e = {};
                    return function(t) {
                        var n = t;
                        if (n in e) return e[n];
                        for (var r = [], i = 0; t;) {
                            if (++i > 1e3) {
                                t = "";
                                break
                            }
                            var a = ub(t),
                                o = a.nodes[0];
                            if (null == o || 0 === o.terms.length) break;
                            r.push(o), t = a.remainingInput
                        }
                        return e[n] = r
                    }
                }(),
                ub = function() {
                    var e = /^(\-\-|[a-z\u0240-\uffff])/i,
                        t = /^([\*\+\/]|[\-]\s)/i,
                        n = /^[\),]/;
                    return function(r) {
                        for (var i = []; r.length && (r = r.trim(), !n.test(r));)
                            if ("(" === r[0]) {
                                var a = uT(r),
                                    o = a.nodes;
                                r = a.remainingInput, i.push({
                                    type: "function",
                                    name: {
                                        type: "ident",
                                        value: "calc"
                                    },
                                    arguments: o
                                })
                            } else if (e.test(r)) {
                            var s = uw(r),
                                l = s.nodes[0];
                            if ("(" === (r = s.remainingInput)[0]) {
                                var u = uT(r),
                                    c = u.nodes,
                                    h = u.remainingInput;
                                i.push({
                                    type: "function",
                                    name: l,
                                    arguments: c
                                }), r = h
                            } else i.push(l)
                        } else if (t.test(r)) i.push({
                            type: "operator",
                            value: r[0]
                        }), r = r.slice(1);
                        else {
                            var d = "#" === r[0] ? uS(r) : uM(r),
                                f = d.nodes,
                                p = d.remainingInput;
                            if (0 === f.length) break;
                            i.push(f[0]), r = p
                        }
                        return {
                            nodes: [{
                                type: "expression",
                                terms: i
                            }],
                            remainingInput: r
                        }
                    }
                }(),
                uw = function() {
                    var e = /[^a-z0-9_\-\u0240-\uffff]/i;
                    return function(t) {
                        var n = t.match(e);
                        return {
                            nodes: [{
                                type: "ident",
                                value: null == n ? t : t.substr(0, n.index)
                            }],
                            remainingInput: null == n ? "" : t.substr(n.index)
                        }
                    }
                }(),
                uM = function() {
                    var e = /[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/,
                        t = /^[a-z%]+/i,
                        n = /^(m|mm|cm|rad|deg|[%])$/;
                    return function(r) {
                        var i = r.match(e),
                            a = null == i ? "0" : i[0],
                            o = (r = null == a ? r : r.slice(a.length)).match(t),
                            s = null != o && "" !== o[0] ? o[0] : null,
                            l = null == o ? r : r.slice(s.length);
                        return null == s || n.test(s) || (s = null), {
                            nodes: [{
                                type: "number",
                                number: parseFloat(a) || 0,
                                unit: s
                            }],
                            remainingInput: l
                        }
                    }
                }(),
                uS = function() {
                    var e = /^[a-f0-9]*/i;
                    return function(t) {
                        var n = (t = t.slice(1).trim()).match(e);
                        return {
                            nodes: null == n ? [] : [{
                                type: "hex",
                                value: n[0]
                            }],
                            remainingInput: null == n ? t : t.slice(n[0].length)
                        }
                    }
                }(),
                uT = function(e) {
                    var t = [];
                    for (e = e.slice(1).trim(); e.length;) {
                        var n = ub(e);
                        if (t.push(n.nodes[0]), "," === (e = n.remainingInput.trim())[0]) e = e.slice(1).trim();
                        else if (")" === e[0]) {
                            e = e.slice(1);
                            break
                        }
                    }
                    return {
                        nodes: t,
                        remainingInput: e
                    }
                },
                uE = Symbol("visitedTypes"),
                uk = function() {
                    function e(t) {
                        (0, k._)(this, e), this[uE] = t
                    }
                    return (0, A._)(e, [{
                        key: "walk",
                        value: function(e, t) {
                            for (var n = e.slice(); n.length;) {
                                var r = n.shift();
                                switch (this[uE].indexOf(r.type) > -1 && t(r), r.type) {
                                    case "expression":
                                        n.unshift.apply(n, (0, F._)(r.terms));
                                        break;
                                    case "function":
                                        n.unshift.apply(n, [r.name].concat((0, F._)(r.arguments)))
                                }
                            }
                        }
                    }]), e
                }(),
                uA = Object.freeze({
                    type: "number",
                    number: 0,
                    unit: null
                }),
                uR = function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        n = e.number,
                        r = e.unit;
                    if (isFinite(n)) {
                        if ("rad" === e.unit || null == e.unit) return e
                    } else n = t, r = "rad";
                    return {
                        type: "number",
                        number: ("deg" === r && null != n ? n : 0) * Math.PI / 180,
                        unit: "rad"
                    }
                },
                uC = function(e) {
                    var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        r = e.number,
                        i = e.unit;
                    if (isFinite(r)) {
                        if ("m" === e.unit) return e
                    } else r = n, i = "m";
                    switch (i) {
                        default: t = 1;
                        break;
                        case "cm":
                                t = .01;
                            break;
                        case "mm":
                                t = .001
                    }
                    return {
                        type: "number",
                        number: t * r,
                        unit: "m"
                    }
                },
                uL = function() {
                    var e = function(e) {
                            return e
                        },
                        t = {
                            rad: e,
                            deg: uR,
                            m: e,
                            mm: uC,
                            cm: uC
                        };
                    return function(e) {
                        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : uA;
                        isFinite(e.number) || (e.number = n.number, e.unit = n.unit);
                        var r = e.unit;
                        if (null == r) return e;
                        var i = t[r];
                        return null == i ? n : i(e)
                    }
                }(),
                uP = function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t, [document.createElement("div")])).normal = new to(0, 1, 0), n.initialized = !1, n.referenceCount = 1, n.pivot = document.createElement("div"), n.slot = document.createElement("slot"), n.element.classList.add("annotation-wrapper"), n.slot.name = e.name, n.element.appendChild(n.pivot), n.pivot.appendChild(n.slot), n.updatePosition(e.position), n.updateNormal(e.normal), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "facingCamera",
                        get: function() {
                            return !this.element.classList.contains("hide")
                        }
                    }, {
                        key: "show",
                        value: function() {
                            this.facingCamera && this.initialized || this.updateVisibility(!0)
                        }
                    }, {
                        key: "hide",
                        value: function() {
                            !this.facingCamera && this.initialized || this.updateVisibility(!1)
                        }
                    }, {
                        key: "increment",
                        value: function() {
                            this.referenceCount++
                        }
                    }, {
                        key: "decrement",
                        value: function() {
                            return this.referenceCount > 0 && --this.referenceCount, 0 === this.referenceCount
                        }
                    }, {
                        key: "updatePosition",
                        value: function(e) {
                            if (null != e) {
                                for (var t = ux(e)[0].terms, n = 0; n < 3; ++n) this.position.setComponent(n, uL(t[n]).number);
                                this.updateMatrixWorld()
                            }
                        }
                    }, {
                        key: "updateNormal",
                        value: function(e) {
                            if (null != e)
                                for (var t = ux(e)[0].terms, n = 0; n < 3; ++n) this.normal.setComponent(n, uL(t[n]).number)
                        }
                    }, {
                        key: "orient",
                        value: function(e) {
                            this.pivot.style.transform = "rotate(".concat(e, "rad)")
                        }
                    }, {
                        key: "updateVisibility",
                        value: function(e) {
                            e ? this.element.classList.remove("hide") : this.element.classList.add("hide"), this.slot.assignedNodes().forEach(function(t) {
                                if (t.nodeType === Node.ELEMENT_NODE) {
                                    var n = t.dataset.visibilityAttribute;
                                    if (null != n) {
                                        var r = "data-".concat(n);
                                        e ? t.setAttribute(r, "") : t.removeAttribute(r)
                                    }
                                    t.dispatchEvent(new CustomEvent("hotspot-visibility", {
                                        detail: {
                                            visible: e
                                        }
                                    }))
                                }
                            }), this.initialized = !0
                        }
                    }]), t
                }(ur),
                uI = function(e, t, n) {
                    var r = n,
                        i = new to;
                    return e.traverse(function(e) {
                        e.updateWorldMatrix(!1, !1);
                        var n, a, o = e.geometry;
                        if (void 0 !== o) {
                            if (o.isGeometry) {
                                var s = o.vertices;
                                for (n = 0, a = s.length; n < a; n++) i.copy(s[n]), i.applyMatrix4(e.matrixWorld), r = t(r, i)
                            } else if (o.isBufferGeometry) {
                                var l = o.attributes.position;
                                if (void 0 !== l) {
                                    var u = function(e) {
                                        if (!e.normalized) return 1;
                                        var t = e.array;
                                        return t instanceof Int8Array ? 1 / 127 : t instanceof Uint8Array ? 1 / 255 : t instanceof Int16Array ? 1 / 32767 : t instanceof Uint16Array ? 1 / 65535 : 1
                                    }(l);
                                    for (n = 0, a = l.count; n < a; n++) i.fromBufferAttribute(l, n), i.multiplyScalar(u), i.applyMatrix4(e.matrixWorld), r = t(r, i)
                                }
                            }
                        }
                    }), r
                },
                uD = function(e) {
                    function t(e, n, r) {
                        var i;
                        return (0, k._)(this, t), (i = (0, E._)(this, t)).shadowMaterial = new o7, i.boundingBox = new tu, i.size = new to, i.shadowScale = 1, i.isAnimated = !1, i.side = "bottom", i.needsUpdate = !1, i.intensity = 0, i.castShadow = !0, i.frustumCulled = !1, i.floor = new nK(new rl, i.shadowMaterial), i.floor.rotateX(-Math.PI / 2), i.floor.receiveShadow = !0, i.floor.castShadow = !1, i.floor.frustumCulled = !1, i.add(i.floor), e.target.add(i), i.target = e.target, i.setScene(e, n, r), i
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "setScene",
                        value: function(e, t, n) {
                            if (this.side = n, this.isAnimated = e.animationNames.length > 0, this.boundingBox.copy(e.boundingBox), this.size.copy(e.size), "back" === this.side) {
                                var r, i, a, o = this.boundingBox,
                                    s = o.min,
                                    l = o.max;
                                r = [s.z, s.y], s.y = r[0], s.z = r[1], i = [l.z, l.y], l.y = i[0], l.z = i[1], a = [this.size.z, this.size.y], this.size.y = a[0], this.size.z = a[1], this.rotation.x = Math.PI / 2, this.rotation.y = Math.PI
                            } else this.rotation.x = 0, this.rotation.y = 0;
                            var u = this.boundingBox,
                                c = this.size;
                            if (this.isAnimated) {
                                var h = 2 * Math.max(c.x, c.y, c.z);
                                c.y = h, u.expandByVector(c.subScalar(h).multiplyScalar(-.5)), u.max.y = u.min.y + h, c.set(h, h, h)
                            }
                            u.getCenter(this.floor.position);
                            var d = u.max.y + .002 * c.y;
                            "bottom" === n ? (this.position.y = d, this.position.z = 0) : (this.position.y = 0, this.position.z = d), this.setSoftness(t)
                        }
                    }, {
                        key: "setSoftness",
                        value: function(e) {
                            var t = Math.pow(2, 9 - 3 * e);
                            this.setMapSize(t)
                        }
                    }, {
                        key: "setMapSize",
                        value: function(e) {
                            var t = this.shadow,
                                n = t.camera,
                                r = t.mapSize,
                                i = t.map,
                                a = this.size,
                                o = this.boundingBox;
                            null != i && (i.dispose(), this.shadow.map = null), this.isAnimated && (e *= 2);
                            var s = Math.floor(a.x > a.z ? e : e * a.x / a.z),
                                l = Math.floor(a.x > a.z ? e * a.z / a.x : e);
                            r.set(s, l);
                            var u = 2.5 * a.x / s,
                                c = 2.5 * a.z / l;
                            n.left = -o.max.x - u, n.right = -o.min.x + u, n.bottom = o.min.z - c, n.top = o.max.z + c, this.setScaleAndOffset(this.shadowScale, 0), this.floor.scale.set(a.x + 2 * u, a.z + 2 * c, 1), this.needsUpdate = !0, this.shadow.needsUpdate = !0
                        }
                    }, {
                        key: "setIntensity",
                        value: function(e) {
                            this.shadowMaterial.opacity = e, e > 0 ? (this.visible = !0, this.floor.visible = !0) : (this.visible = !1, this.floor.visible = !1)
                        }
                    }, {
                        key: "getIntensity",
                        value: function() {
                            return this.shadowMaterial.opacity
                        }
                    }, {
                        key: "setRotation",
                        value: function(e) {
                            if ("bottom" !== this.side) return this.shadow.camera.up.set(0, 1, 0), void this.shadow.updateMatrices(this);
                            this.shadow.camera.up.set(Math.sin(e), 0, Math.cos(e)), this.shadow.updateMatrices(this)
                        }
                    }, {
                        key: "setScaleAndOffset",
                        value: function(e, t) {
                            var n = this.size.y,
                                r = this.shadow.camera;
                            this.shadowScale = e, r.near = 0, r.far = n - t / e, r.updateProjectionMatrix(), r.scale.setScalar(e), this.floor.position.y = .002 * n * 2 - r.far
                        }
                    }]), t
                }(sF),
                uO = new to,
                uN = new to,
                uF = new to,
                uU = new(function() {
                    function e(t, n) {
                        var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0;
                        (0, k._)(this, e), this.ray = new tN(t, n), this.near = r, this.far = i, this.camera = null, this.layers = new tY, this.params = {
                            Mesh: {},
                            Line: {
                                threshold: 1
                            },
                            LOD: {},
                            Points: {
                                threshold: 1
                            },
                            Sprite: {}
                        }
                    }
                    return (0, A._)(e, [{
                        key: "set",
                        value: function(e, t) {
                            this.ray.set(e, t)
                        }
                    }, {
                        key: "setFromCamera",
                        value: function(e, t) {
                            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
                        }
                    }, {
                        key: "intersectObject",
                        value: function(e) {
                            var t = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1],
                                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                            return sQ(e, this, n, t), n.sort(sK), n
                        }
                    }, {
                        key: "intersectObjects",
                        value: function(e) {
                            for (var t = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1], n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], r = 0, i = e.length; r < i; r++) sQ(e[r], this, n, t);
                            return n.sort(sK), n
                        }
                    }]), e
                }()),
                uB = new to,
                uz = new e4,
                uH = function(e) {
                    function t(e) {
                        var n, r = e.canvas,
                            i = e.element,
                            a = e.width,
                            o = e.height;
                        (0, k._)(this, t), (n = (0, E._)(this, t)).context = null, n.annotationRenderer = new uu, n.schemaElement = document.createElement("script"), n.width = 1, n.height = 1, n.aspect = 1, n.renderCount = 0, n.externalRenderer = null, n.camera = new n5(45, 1, .1, 100), n.xrCamera = null, n.url = null, n.target = new t7, n.modelContainer = new t7, n.animationNames = [], n.boundingBox = new tu, n.size = new to, n.idealAspect = 0, n.framedFoVDeg = 45, n.boundingRadius = 0, n.shadow = null, n.shadowIntensity = 0, n.shadowSoftness = 1, n.exposure = 1, n.canScale = !0, n.tightBounds = !1, n.isDirty = !1, n.goalTarget = new to, n.targetDamperX = new uy, n.targetDamperY = new uy, n.targetDamperZ = new uy, n._currentGLTF = null, n.cancelPendingSourceChange = null, n.animationsByName = new Map, n.currentAnimationAction = null, n.name = "ModelScene", n.element = i, n.canvas = r, n.camera = new n5(45, 1, .1, 100), n.camera.name = "MainCamera", n.add(n.target), n.setSize(a, o), n.target.name = "Target", n.modelContainer.name = "ModelContainer", n.target.add(n.modelContainer), n.mixer = new sZ(n.modelContainer);
                        var s = n.annotationRenderer.domElement,
                            l = s.style;
                        return l.display = "none", l.pointerEvents = "none", l.position = "absolute", l.top = "0", n.element.shadowRoot.querySelector(".default").appendChild(s), n.schemaElement.setAttribute("type", "application/ld+json"), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "createContext",
                        value: function() {
                            this.context = this.canvas.getContext("2d")
                        }
                    }, {
                        key: "getCamera",
                        value: function() {
                            return null != this.xrCamera ? this.xrCamera : this.camera
                        }
                    }, {
                        key: "queueRender",
                        value: function() {
                            this.isDirty = !0
                        }
                    }, {
                        key: "shouldRender",
                        value: function() {
                            return this.isDirty
                        }
                    }, {
                        key: "hasRendered",
                        value: function() {
                            this.isDirty = !1
                        }
                    }, {
                        key: "setObject",
                        value: function(e) {
                            var t = this;
                            return (0, T._)(function() {
                                return (0, z.YH)(this, function(n) {
                                    switch (n.label) {
                                        case 0:
                                            return t.reset(), t.modelContainer.add(e), [4, t.setupScene()];
                                        case 1:
                                            return n.sent(), [2]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "setSource",
                        value: function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function() {},
                                n = this;
                            return (0, T._)(function() {
                                var r, i, a, o, s, l, u, c, h, d, f, p;
                                return (0, z.YH)(this, function(m) {
                                    switch (m.label) {
                                        case 0:
                                            if (!e || e === n.url) return [2, void t(1)];
                                            if (n.reset(), n.url = e, null == n.externalRenderer) return [3, 2];
                                            return [4, n.externalRenderer.load(t)];
                                        case 1:
                                            return r = m.sent(), [2, (n.boundingRadius = r.framedRadius, n.idealAspect = r.fieldOfViewAspect, void n.dispatchEvent({
                                                type: "model-load",
                                                url: n.url
                                            }))];
                                        case 2:
                                            null != n.cancelPendingSourceChange && (n.cancelPendingSourceChange(), n.cancelPendingSourceChange = null), m.label = 3;
                                        case 3:
                                            var v;
                                            return m.trys.push([3, 5, , 6]), [4, new Promise((v = (0, T._)(function(r, i) {
                                                return (0, z.YH)(this, function(a) {
                                                    switch (a.label) {
                                                        case 0:
                                                            n.cancelPendingSourceChange = function() {
                                                                return i()
                                                            }, a.label = 1;
                                                        case 1:
                                                            return a.trys.push([1, 3, , 4]), [4, n.element[ho].loader.load(e, n.element, t)];
                                                        case 2:
                                                            return r.apply(void 0, [a.sent()]), [3, 4];
                                                        case 3:
                                                            return i(a.sent()), [3, 4];
                                                        case 4:
                                                            return [2]
                                                    }
                                                })
                                            }), function(e, t) {
                                                return v.apply(this, arguments)
                                            }))];
                                        case 4:
                                            return i = m.sent(), [3, 6];
                                        case 5:
                                            if (null == (a = m.sent())) return [2];
                                            throw a;
                                        case 6:
                                            n.reset(), n.url = e, n._currentGLTF = i, null != i && n.modelContainer.add(i.scene), o = i.animations, s = new Map, l = [], u = !0, c = !1, h = void 0;
                                            try {
                                                for (d = o[Symbol.iterator](); !(u = (f = d.next()).done); u = !0) p = f.value, s.set(p.name, p), l.push(p.name)
                                            } catch (e) {
                                                c = !0, h = e
                                            } finally {
                                                try {
                                                    u || null == d.return || d.return()
                                                } finally {
                                                    if (c) throw h
                                                }
                                            }
                                            return n.animations = o, n.animationsByName = s, n.animationNames = l, [4, n.setupScene()];
                                        case 7:
                                            return m.sent(), [2]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "setupScene",
                        value: function() {
                            var e = this;
                            return (0, T._)(function() {
                                return (0, z.YH)(this, function(t) {
                                    switch (t.label) {
                                        case 0:
                                            return e.updateBoundingBox(), [4, e.updateFraming()];
                                        case 1:
                                            return t.sent(), e.updateShadow(), e.setShadowIntensity(e.shadowIntensity), e.dispatchEvent({
                                                type: "model-load",
                                                url: e.url
                                            }), [2]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "reset",
                        value: function() {
                            this.url = null, this.queueRender(), null != this.shadow && this.shadow.setIntensity(0);
                            var e = this._currentGLTF;
                            if (null != e) {
                                var t = !0,
                                    n = !1,
                                    r = void 0;
                                try {
                                    for (var i, a = this.modelContainer.children[Symbol.iterator](); !(t = (i = a.next()).done); t = !0) {
                                        var o = i.value;
                                        this.modelContainer.remove(o)
                                    }
                                } catch (e) {
                                    n = !0, r = e
                                } finally {
                                    try {
                                        t || null == a.return || a.return()
                                    } finally {
                                        if (n) throw r
                                    }
                                }
                                e.dispose(), this._currentGLTF = null
                            }
                            null != this.currentAnimationAction && (this.currentAnimationAction.stop(), this.currentAnimationAction = null), this.mixer.stopAllAction(), this.mixer.uncacheRoot(this)
                        }
                    }, {
                        key: "currentGLTF",
                        get: function() {
                            return this._currentGLTF
                        }
                    }, {
                        key: "setSize",
                        value: function(e, t) {
                            if (this.width !== e || this.height !== t) {
                                if (this.width = Math.max(e, 1), this.height = Math.max(t, 1), this.annotationRenderer.setSize(e, t), this.aspect = this.width / this.height, null != this.externalRenderer) {
                                    var n = um();
                                    this.externalRenderer.resize(e * n, t * n)
                                }
                                this.queueRender()
                            }
                        }
                    }, {
                        key: "updateBoundingBox",
                        value: function() {
                            (this.target.remove(this.modelContainer), !0 === this.tightBounds) ? this.boundingBox = uI(this.modelContainer, function(e, t) {
                                return e.expandByPoint(t)
                            }, new tu): this.boundingBox.setFromObject(this.modelContainer), this.boundingBox.getSize(this.size), this.target.add(this.modelContainer)
                        }
                    }, {
                        key: "updateFraming",
                        value: function() {
                            var e = this;
                            return (0, T._)(function() {
                                var t;
                                return (0, z.YH)(this, function(n) {
                                    switch (n.label) {
                                        case 0:
                                            if (e.target.remove(e.modelContainer), t = e.boundingBox.getCenter(new to), !0 !== e.tightBounds) return [3, 2];
                                            return [4, e.element.requestUpdate("cameraTarget")];
                                        case 1:
                                            n.sent(), t = e.getTarget(), n.label = 2;
                                        case 2:
                                            return e.boundingRadius = Math.sqrt(uI(e.modelContainer, function(e, n) {
                                                return Math.max(e, t.distanceToSquared(n))
                                            }, 0)), e.idealAspect = uI(e.modelContainer, function(n, r) {
                                                return r.sub(t), Math.max(n, Math.sqrt(r.x * r.x + r.z * r.z) / (e.idealCameraDistance() - Math.abs(r.y)))
                                            }, 0) / Math.tan(e.framedFoVDeg / 2 * Math.PI / 180), e.target.add(e.modelContainer), [2]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "idealCameraDistance",
                        value: function() {
                            var e = this.framedFoVDeg / 2 * Math.PI / 180;
                            return this.boundingRadius / Math.sin(e)
                        }
                    }, {
                        key: "adjustedFoV",
                        value: function(e) {
                            return 2 * Math.atan(Math.tan(e / 2 * Math.PI / 180) * Math.max(1, this.idealAspect / this.aspect)) * 180 / Math.PI
                        }
                    }, {
                        key: "getNDC",
                        value: function(e, t) {
                            if (null != this.xrCamera) uz.set(e / window.screen.width, t / window.screen.height);
                            else {
                                var n = this.element.getBoundingClientRect();
                                uz.set((e - n.x) / this.width, (t - n.y) / this.height)
                            }
                            return uz.multiplyScalar(2).subScalar(1), uz.y *= -1, uz
                        }
                    }, {
                        key: "getSize",
                        value: function() {
                            return {
                                width: this.width,
                                height: this.height
                            }
                        }
                    }, {
                        key: "setTarget",
                        value: function(e, t, n) {
                            this.goalTarget.set(-e, -t, -n)
                        }
                    }, {
                        key: "setTargetDamperDecayTime",
                        value: function(e) {
                            this.targetDamperX.setDecayTime(e), this.targetDamperY.setDecayTime(e), this.targetDamperZ.setDecayTime(e)
                        }
                    }, {
                        key: "getTarget",
                        value: function() {
                            return uB.copy(this.goalTarget).multiplyScalar(-1)
                        }
                    }, {
                        key: "jumpToGoal",
                        value: function() {
                            this.updateTarget(1e4)
                        }
                    }, {
                        key: "updateTarget",
                        value: function(e) {
                            var t = this.goalTarget,
                                n = this.target.position;
                            if (!t.equals(n)) {
                                var r = this.boundingRadius / 10,
                                    i = n.x,
                                    a = n.y,
                                    o = n.z;
                                i = this.targetDamperX.update(i, t.x, e, r), a = this.targetDamperY.update(a, t.y, e, r), o = this.targetDamperZ.update(o, t.z, e, r), this.target.position.set(i, a, o), this.target.updateMatrixWorld(), this.setShadowRotation(this.yaw), this.queueRender()
                            }
                        }
                    }, {
                        key: "pointTowards",
                        value: function(e, t) {
                            var n = this.position,
                                r = n.x,
                                i = n.z;
                            this.yaw = Math.atan2(e - r, t - i)
                        }
                    }, {
                        key: "yaw",
                        get: function() {
                            return this.rotation.y
                        },
                        set: function(e) {
                            this.rotation.y = e, this.updateMatrixWorld(!0), this.setShadowRotation(e), this.queueRender()
                        }
                    }, {
                        key: "animationTime",
                        get: function() {
                            if (null != this.currentAnimationAction) {
                                var e = Math.max(this.currentAnimationAction._loopCount, 0);
                                return 2202 === this.currentAnimationAction.loop && 1 == (1 & e) ? this.duration - this.currentAnimationAction.time : this.currentAnimationAction.time
                            }
                            return 0
                        },
                        set: function(e) {
                            this.mixer.setTime(e)
                        }
                    }, {
                        key: "duration",
                        get: function() {
                            return null != this.currentAnimationAction && this.currentAnimationAction.getClip() ? this.currentAnimationAction.getClip().duration : 0
                        }
                    }, {
                        key: "hasActiveAnimation",
                        get: function() {
                            return null != this.currentAnimationAction
                        }
                    }, {
                        key: "playAnimation",
                        value: function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2201,
                                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0;
                            if (null != this._currentGLTF) {
                                var i = this.animations;
                                if (null == i || 0 === i.length) return void console.warn("Cannot play animation (model does not have any animations)");
                                var a = null;
                                null != e && (a = this.animationsByName.get(e)), null == a && (a = i[0]);
                                try {
                                    var o = this.currentAnimationAction,
                                        s = this.mixer.clipAction(a, this);
                                    this.currentAnimationAction = s, this.element.paused ? this.mixer.stopAllAction() : null != o && s !== o && s.crossFadeFrom(o, t, !1), s.setLoop(n, r), s.enabled = !0, s.play()
                                } catch (e) {
                                    console.error(e)
                                }
                            }
                        }
                    }, {
                        key: "stopAnimation",
                        value: function() {
                            this.currentAnimationAction = null, this.mixer.stopAllAction()
                        }
                    }, {
                        key: "updateAnimation",
                        value: function(e) {
                            this.mixer.update(e)
                        }
                    }, {
                        key: "subscribeMixerEvent",
                        value: function(e, t) {
                            this.mixer.addEventListener(e, t)
                        }
                    }, {
                        key: "updateShadow",
                        value: function() {
                            var e = this.shadow;
                            if (null != e) {
                                var t = "wall" === this.element.arPlacement ? "back" : "bottom";
                                e.setScene(this, this.shadowSoftness, t), e.setRotation(this.yaw)
                            }
                        }
                    }, {
                        key: "setShadowIntensity",
                        value: function(e) {
                            if (this.shadowIntensity = e, null != this._currentGLTF && !(e <= 0 && null == this.shadow)) {
                                if (null == this.shadow) {
                                    var t = "wall" === this.element.arPlacement ? "back" : "bottom";
                                    this.shadow = new uD(this, this.shadowSoftness, t), this.shadow.setRotation(this.yaw)
                                }
                                this.shadow.setIntensity(e)
                            }
                        }
                    }, {
                        key: "setShadowSoftness",
                        value: function(e) {
                            this.shadowSoftness = e;
                            var t = this.shadow;
                            null != t && t.setSoftness(e)
                        }
                    }, {
                        key: "setShadowRotation",
                        value: function(e) {
                            var t = this.shadow;
                            null != t && t.setRotation(e)
                        }
                    }, {
                        key: "isShadowDirty",
                        value: function() {
                            var e = this.shadow;
                            if (null == e) return !1;
                            var t = e.needsUpdate;
                            return e.needsUpdate = !1, t
                        }
                    }, {
                        key: "setShadowScaleAndOffset",
                        value: function(e, t) {
                            var n = this.shadow;
                            null != n && n.setScaleAndOffset(e, t)
                        }
                    }, {
                        key: "raycaster",
                        get: function() {
                            return uU
                        }
                    }, {
                        key: "positionAndNormalFromPoint",
                        value: function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this;
                            this.raycaster.setFromCamera(e, this.getCamera());
                            var n = this.raycaster.intersectObject(t, !0);
                            if (0 === n.length) return null;
                            var r = n[0];
                            return null == r.face ? null : null == r.uv ? {
                                position: r.point,
                                normal: r.face.normal,
                                uv: null
                            } : (r.face.normal.applyNormalMatrix((new e5).getNormalMatrix(r.object.matrixWorld)), {
                                position: r.point,
                                normal: r.face.normal,
                                uv: r.uv
                            })
                        }
                    }, {
                        key: "addHotspot",
                        value: function(e) {
                            this.target.add(e), this.annotationRenderer.domElement.appendChild(e.element)
                        }
                    }, {
                        key: "removeHotspot",
                        value: function(e) {
                            this.target.remove(e)
                        }
                    }, {
                        key: "forHotspots",
                        value: function(e) {
                            for (var t = this.target.children, n = 0, r = t.length; n < r; n++) {
                                var i = t[n];
                                i instanceof uP && e(i)
                            }
                        }
                    }, {
                        key: "updateHotspots",
                        value: function(e) {
                            var t = this;
                            this.forHotspots(function(n) {
                                uO.copy(e), uN.setFromMatrixPosition(n.matrixWorld), uO.sub(uN), uF.copy(n.normal).transformDirection(t.target.matrixWorld), 0 > uO.dot(uF) ? n.hide() : n.show()
                            })
                        }
                    }, {
                        key: "orientHotspots",
                        value: function(e) {
                            this.forHotspots(function(t) {
                                t.orient(e)
                            })
                        }
                    }, {
                        key: "setHotspotsVisibility",
                        value: function(e) {
                            this.forHotspots(function(t) {
                                t.visible = e
                            })
                        }
                    }, {
                        key: "updateSchema",
                        value: function(e) {
                            var t, n = this.schemaElement,
                                r = this.element,
                                i = r.alt,
                                a = r.poster,
                                o = r.iosSrc;
                            if (null != e) {
                                var s = [{
                                    "@type": "MediaObject",
                                    contentUrl: e,
                                    encodingFormat: "gltf" === (null === (t = e.split(".").pop()) || void 0 === t ? void 0 : t.toLowerCase()) ? "model/gltf+json" : "model/gltf-binary"
                                }];
                                o && s.push({
                                    "@type": "MediaObject",
                                    contentUrl: o,
                                    encodingFormat: "model/vnd.usdz+zip"
                                }), n.textContent = JSON.stringify({
                                    "@context": "http://schema.org/",
                                    "@type": "3DModel",
                                    image: null != a ? a : void 0,
                                    name: null != i ? i : void 0,
                                    encoding: s
                                }), document.head.appendChild(n)
                            } else null != n.parentElement && n.parentElement.removeChild(n)
                        }
                    }]), t
                }(aC),
                uV = function(e, t, n, r) {
                    for (var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r, s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o);
                    return a > 3 && o && Object.defineProperty(t, n, o), o
                },
                uG = Symbol("currentEnvironmentMap"),
                uW = Symbol("applyEnvironmentMap"),
                uj = Symbol("updateEnvironment"),
                uq = Symbol("cancelEnvironmentUpdate"),
                uX = Symbol("onPreload"),
                uY = function() {
                    function e(t, n, r, i, a) {
                        var o = this;
                        (0, k._)(this, e), this.xrLight = t, this.renderer = n, this.lightProbe = r, this.xrWebGLBinding = null, this.estimationStartCallback = a, this.frameCallback = this.onXRFrame.bind(this);
                        var s = n.xr.getSession();
                        if (i && "XRWebGLBinding" in window) {
                            var l = new n7(16);
                            t.environment = l.texture;
                            var u = n.getContext();
                            switch (s.preferredReflectionFormat) {
                                case "srgba8":
                                    u.getExtension("EXT_sRGB");
                                    break;
                                case "rgba16f":
                                    u.getExtension("OES_texture_half_float")
                            }
                            this.xrWebGLBinding = new XRWebGLBinding(s, u), this.lightProbe.addEventListener("reflectionchange", function() {
                                o.updateReflection()
                            })
                        }
                        s.requestAnimationFrame(this.frameCallback)
                    }
                    return (0, A._)(e, [{
                        key: "updateReflection",
                        value: function() {
                            var e = this.renderer.properties.get(this.xrLight.environment);
                            if (e) {
                                var t = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);
                                t && (e.__webglTexture = t)
                            }
                        }
                    }, {
                        key: "onXRFrame",
                        value: function(e, t) {
                            if (this.xrLight) {
                                t.session.requestAnimationFrame(this.frameCallback);
                                var n = t.getLightEstimate(this.lightProbe);
                                if (n) {
                                    this.xrLight.lightProbe.sh.fromArray(n.sphericalHarmonicsCoefficients), this.xrLight.lightProbe.intensity = 1;
                                    var r = Math.max(1, Math.max(n.primaryLightIntensity.x, Math.max(n.primaryLightIntensity.y, n.primaryLightIntensity.z)));
                                    this.xrLight.directionalLight.color.setRGB(n.primaryLightIntensity.x / r, n.primaryLightIntensity.y / r, n.primaryLightIntensity.z / r), this.xrLight.directionalLight.intensity = r, this.xrLight.directionalLight.position.copy(n.primaryLightDirection), this.estimationStartCallback && (this.estimationStartCallback(), this.estimationStartCallback = null)
                                }
                            }
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            this.xrLight = null, this.renderer = null, this.lightProbe = null, this.xrWebGLBinding = null
                        }
                    }]), e
                }(),
                uJ = function(e) {
                    function t(e) {
                        var n, r = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
                        (0, k._)(this, t), (n = (0, E._)(this, t)).lightProbe = new sB, n.lightProbe.intensity = 0, n.add(n.lightProbe), n.directionalLight = new sF, n.directionalLight.intensity = 0, n.add(n.directionalLight), n.environment = null;
                        var i = null,
                            a = !1;
                        return e.xr.addEventListener("sessionstart", function() {
                            var t = e.xr.getSession();
                            "requestLightProbe" in t && t.requestLightProbe({
                                reflectionFormat: t.preferredReflectionFormat
                            }).then(function(t) {
                                i = new uY(n, e, t, r, function() {
                                    a = !0, n.dispatchEvent({
                                        type: "estimationstart"
                                    })
                                })
                            })
                        }), e.xr.addEventListener("sessionend", function() {
                            i && (i.dispose(), i = null), a && n.dispatchEvent({
                                type: "estimationend"
                            })
                        }), n.dispose = function() {
                            i && (i.dispose(), i = null), n.remove(n.lightProbe), n.lightProbe = null, n.remove(n.directionalLight), n.directionalLight = null, n.environment = null
                        }, n
                    }
                    return (0, P._)(t, e), t
                }(aM),
                uZ = Math.PI / 24,
                uK = new e4,
                uQ = function(e, t, n) {
                    for (var r = t > 0 ? n > 0 ? 0 : -Math.PI / 2 : n > 0 ? Math.PI / 2 : Math.PI, i = 0; i <= 12; ++i) e.push(t + .17 * Math.cos(r), n + .17 * Math.sin(r), 0, t + .2 * Math.cos(r), n + .2 * Math.sin(r), 0), r += uZ
                },
                u$ = function(e) {
                    function t(e, n) {
                        (0, k._)(this, t);
                        var r, i = new nI,
                            a = [],
                            o = [],
                            s = e.size,
                            l = e.boundingBox,
                            u = s.x / 2,
                            c = ("back" === n ? s.y : s.z) / 2;
                        uQ(o, u, c), uQ(o, -u, c), uQ(o, -u, -c), uQ(o, u, -c);
                        for (var h = o.length / 3, d = 0; d < h - 2; d += 2) a.push(d, d + 1, d + 3, d, d + 3, d + 2);
                        var f = h - 2;
                        a.push(f, f + 1, 1, f, 1, 0), i.setAttribute("position", new nT(o, 3)), i.setIndex(a), (r = (0, E._)(this, t, [i])).side = n;
                        var p = r.material;
                        switch (p.side = 0, p.transparent = !0, p.opacity = 0, r.goalOpacity = 0, r.opacityDamper = new uy, r.hitPlane = new nK(new rl(2 * (u + .2), 2 * (c + .2))), r.hitPlane.visible = !1, r.add(r.hitPlane), l.getCenter(r.position), n) {
                            case "bottom":
                                r.rotateX(-Math.PI / 2), r.shadowHeight = l.min.y, r.position.y = r.shadowHeight;
                                break;
                            case "back":
                                r.shadowHeight = l.min.z, r.position.z = r.shadowHeight
                        }
                        return e.target.add(r), r
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "getHit",
                        value: function(e, t, n) {
                            uK.set(t, -n), this.hitPlane.visible = !0;
                            var r = e.positionAndNormalFromPoint(uK, this.hitPlane);
                            return this.hitPlane.visible = !1, null == r ? null : r.position
                        }
                    }, {
                        key: "getExpandedHit",
                        value: function(e, t, n) {
                            this.hitPlane.scale.set(1e3, 1e3, 1e3);
                            var r = this.getHit(e, t, n);
                            return this.hitPlane.scale.set(1, 1, 1), r
                        }
                    }, {
                        key: "offsetHeight",
                        get: function() {
                            return "back" === this.side ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight
                        },
                        set: function(e) {
                            "back" === this.side ? this.position.z = this.shadowHeight + e : this.position.y = this.shadowHeight + e
                        }
                    }, {
                        key: "show",
                        set: function(e) {
                            this.goalOpacity = e ? .75 : 0
                        }
                    }, {
                        key: "updateOpacity",
                        value: function(e) {
                            var t = this.material;
                            t.opacity = this.opacityDamper.update(t.opacity, this.goalOpacity, e, 1), this.visible = t.opacity > 0
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            var e, t = this.hitPlane,
                                n = t.geometry,
                                r = t.material;
                            n.dispose(), r.dispose(), this.geometry.dispose(), this.material.dispose(), null === (e = this.parent) || void 0 === e || e.remove(this)
                        }
                    }]), t
                }(nK),
                u0 = "not-presenting",
                u1 = "session-started",
                u2 = "tracking",
                u3 = new to,
                u4 = new tF,
                u5 = new to,
                u6 = new n5(45, 1, .1, 100),
                u8 = function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t)).renderer = e, n.currentSession = null, n.placeOnWall = !1, n.placementBox = null, n.lastTick = null, n.turntableRotation = null, n.oldShadowIntensity = null, n.oldBackground = null, n.oldEnvironment = null, n.frame = null, n.initialHitSource = null, n.transientHitTestSource = null, n.inputSource = null, n._presentedScene = null, n.resolveCleanup = null, n.exitWebXRButtonContainer = null, n.overlay = null, n.xrLight = null, n.tracking = !0, n.frames = 0, n.initialized = !1, n.oldTarget = new to, n.placementComplete = !1, n.isTranslating = !1, n.isRotating = !1, n.isTwoFingering = !1, n.lastDragPosition = new to, n.firstRatio = 0, n.lastAngle = 0, n.goalPosition = new to, n.goalYaw = 0, n.goalScale = 1, n.xDamper = new uy, n.yDamper = new uy, n.zDamper = new uy, n.yawDamper = new uy, n.scaleDamper = new uy, n.onExitWebXRButtonContainerClick = function() {
                            return n.stopPresenting()
                        }, n.onUpdateScene = function() {
                            null != n.placementBox && n.isPresenting && (n.placementBox.dispose(), n.placementBox = new u$(n.presentedScene, n.placeOnWall ? "back" : "bottom"))
                        }, n.onSelectStart = function(e) {
                            var t = n.transientHitTestSource;
                            if (null != t) {
                                var r = n.frame.getHitTestResultsForTransientInput(t),
                                    i = n.presentedScene,
                                    a = n.placementBox;
                                if (1 === r.length) {
                                    n.inputSource = e.inputSource;
                                    var o = n.inputSource.gamepad.axes,
                                        s = a.getHit(n.presentedScene, o[0], o[1]);
                                    a.show = !0, null != s ? (n.isTranslating = !0, n.lastDragPosition.copy(s)) : !1 === n.placeOnWall && (n.isRotating = !0, n.lastAngle = 1.5 * o[0])
                                } else if (2 === r.length) {
                                    a.show = !0, n.isTwoFingering = !0;
                                    var l = n.fingerPolar(r).separation;
                                    n.firstRatio = l / i.scale.x
                                }
                            }
                        }, n.onSelectEnd = function() {
                            n.isTranslating = !1, n.isRotating = !1, n.isTwoFingering = !1, n.inputSource = null, n.goalPosition.y += n.placementBox.offsetHeight * n.presentedScene.scale.x, n.placementBox.show = !1
                        }, n.threeRenderer = e.threeRenderer, n.threeRenderer.xr.enabled = !0, n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "resolveARSession",
                        value: function() {
                            var e = this;
                            return (0, T._)(function() {
                                var t;
                                return (0, z.YH)(this, function(n) {
                                    switch (n.label) {
                                        case 0:
                                            return uh(), [4, navigator.xr.requestSession("immersive-ar", {
                                                requiredFeatures: ["hit-test"],
                                                optionalFeatures: ["dom-overlay", "light-estimation"],
                                                domOverlay: {
                                                    root: e.overlay
                                                }
                                            })];
                                        case 1:
                                            return t = n.sent(), e.threeRenderer.xr.setReferenceSpaceType("local"), [4, e.threeRenderer.xr.setSession(t)];
                                        case 2:
                                            return [2, (n.sent(), e.threeRenderer.xr.cameraAutoUpdate = !1, t)]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "presentedScene",
                        get: function() {
                            return this._presentedScene
                        }
                    }, {
                        key: "supportsPresentation",
                        value: function() {
                            return (0, T._)(function() {
                                var e;
                                return (0, z.YH)(this, function(t) {
                                    switch (t.label) {
                                        case 0:
                                            return t.trys.push([0, 2, , 3]), uh(), [4, navigator.xr.isSessionSupported("immersive-ar")];
                                        case 1:
                                            return [2, t.sent()];
                                        case 2:
                                            return e = t.sent(), [2, (console.warn("Request to present in WebXR denied:"), console.warn(e), console.warn("Falling back to next ar-mode"), !1)];
                                        case 3:
                                            return [2]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "present",
                        value: function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                n = this;
                            return (0, T._)(function() {
                                var r, i, a, o, s, l;
                                return (0, z.YH)(this, function(u) {
                                    switch (u.label) {
                                        case 0:
                                            return n.isPresenting && console.warn("Cannot present while a model is already presenting"), r = new Promise(function(e, t) {
                                                requestAnimationFrame(function() {
                                                    return e()
                                                })
                                            }), e.setHotspotsVisibility(!1), e.queueRender(), [4, r];
                                        case 1:
                                            return u.sent(), n._presentedScene = e, n.overlay = e.element.shadowRoot.querySelector("div.default"), !0 === t && (n.xrLight = new uJ(n.threeRenderer), n.xrLight.addEventListener("estimationstart", function() {
                                                if (n.isPresenting && null != n.xrLight) {
                                                    var e = n.presentedScene;
                                                    e.add(n.xrLight), n.oldEnvironment = e.environment, e.environment = n.xrLight.environment
                                                }
                                            })), [4, n.resolveARSession()];
                                        case 2:
                                            return (i = u.sent()).addEventListener("end", function() {
                                                n.postSessionCleanup()
                                            }, {
                                                once: !0
                                            }), (a = e.element.shadowRoot.querySelector(".slot.exit-webxr-ar-button")).classList.add("enabled"), a.addEventListener("click", n.onExitWebXRButtonContainerClick), n.exitWebXRButtonContainer = a, [4, i.requestReferenceSpace("viewer")];
                                        case 3:
                                            return o = u.sent(), n.tracking = !0, n.frames = 0, n.initialized = !1, n.turntableRotation = e.yaw, n.goalYaw = e.yaw, n.goalScale = 1, n.oldBackground = e.background, e.background = null, n.oldShadowIntensity = e.shadowIntensity, e.setShadowIntensity(.01), n.oldTarget.copy(e.getTarget()), e.addEventListener("model-load", n.onUpdateScene), s = 20 * Math.PI / 180, l = !0 === n.placeOnWall ? void 0 : new XRRay(new DOMPoint(0, 0, 0), {
                                                x: 0,
                                                y: -Math.sin(s),
                                                z: -Math.cos(s)
                                            }), i.requestHitTestSource({
                                                space: o,
                                                offsetRay: l
                                            }).then(function(e) {
                                                n.initialHitSource = e
                                            }), n.currentSession = i, n.placementBox = new u$(e, n.placeOnWall ? "back" : "bottom"), n.placementComplete = !1, n.lastTick = performance.now(), n.dispatchEvent({
                                                type: "status",
                                                status: u1
                                            }), [2]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "stopPresenting",
                        value: function() {
                            var e = this;
                            return (0, T._)(function() {
                                var t, n;
                                return (0, z.YH)(this, function(r) {
                                    switch (r.label) {
                                        case 0:
                                            if (!e.isPresenting) return [2];
                                            t = new Promise(function(t) {
                                                e.resolveCleanup = t
                                            }), r.label = 1;
                                        case 1:
                                            return r.trys.push([1, 4, , 5]), [4, e.currentSession.end()];
                                        case 2:
                                            return r.sent(), [4, t];
                                        case 3:
                                            return r.sent(), [3, 5];
                                        case 4:
                                            return n = r.sent(), console.warn("Error while trying to end WebXR AR session"), console.warn(n), e.postSessionCleanup(), [3, 5];
                                        case 5:
                                            return [2]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "isPresenting",
                        get: function() {
                            return null != this.presentedScene
                        }
                    }, {
                        key: "target",
                        get: function() {
                            return this.oldTarget
                        }
                    }, {
                        key: "updateTarget",
                        value: function() {
                            var e = this.presentedScene;
                            if (null != e) {
                                var t = e.getTarget();
                                this.oldTarget.copy(t), this.placeOnWall ? t.z = e.boundingBox.min.z : t.y = e.boundingBox.min.y, e.setTarget(t.x, t.y, t.z)
                            }
                        }
                    }, {
                        key: "postSessionCleanup",
                        value: function() {
                            var e = this.currentSession;
                            null != e && (e.removeEventListener("selectstart", this.onSelectStart), e.removeEventListener("selectend", this.onSelectEnd), this.currentSession = null);
                            var t = this.presentedScene;
                            if (null != t) {
                                var n = t.element;
                                null != this.xrLight && (t.remove(this.xrLight), null != this.oldEnvironment && (t.environment = this.oldEnvironment, this.oldEnvironment = null), this.xrLight.dispose(), this.xrLight = null), t.position.set(0, 0, 0), t.scale.set(1, 1, 1), t.setShadowScaleAndOffset(1, 0);
                                var r = this.turntableRotation;
                                null != r && (t.yaw = r);
                                var i = this.oldShadowIntensity;
                                null != i && t.setShadowIntensity(i);
                                var a = this.oldBackground;
                                null != a && (t.background = a);
                                var o = this.oldTarget;
                                t.setTarget(o.x, o.y, o.z), t.xrCamera = null, t.removeEventListener("model-load", this.onUpdateScene), t.orientHotspots(0), n.requestUpdate("cameraTarget"), n.requestUpdate("maxCameraOrbit"), n[ha](n.getBoundingClientRect())
                            }
                            this.renderer.height = 0;
                            var s = this.exitWebXRButtonContainer;
                            null != s && (s.classList.remove("enabled"), s.removeEventListener("click", this.onExitWebXRButtonContainerClick), this.exitWebXRButtonContainer = null);
                            var l = this.transientHitTestSource;
                            null != l && (l.cancel(), this.transientHitTestSource = null);
                            var u = this.initialHitSource;
                            null != u && (u.cancel(), this.initialHitSource = null), null != this.placementBox && (this.placementBox.dispose(), this.placementBox = null), this.lastTick = null, this.turntableRotation = null, this.oldShadowIntensity = null, this.oldBackground = null, this._presentedScene = null, this.frame = null, this.inputSource = null, this.overlay = null, null != this.resolveCleanup && this.resolveCleanup(), this.dispatchEvent({
                                type: "status",
                                status: u0
                            })
                        }
                    }, {
                        key: "updateView",
                        value: function(e) {
                            var t = this.presentedScene,
                                n = this.threeRenderer.xr;
                            n.updateCamera(u6), t.xrCamera = n.getCamera();
                            var r = t.getCamera().matrixWorld.elements;
                            if (t.orientHotspots(Math.atan2(r[1], r[5])), this.initialized || (this.placeInitially(), this.initialized = !0), e.requestViewportScale && e.recommendedViewportScale) {
                                var i = e.recommendedViewportScale;
                                e.requestViewportScale(Math.max(i, .25))
                            }
                            var a = this.currentSession.renderState.baseLayer.getViewport(e);
                            this.threeRenderer.setViewport(a.x, a.y, a.width, a.height)
                        }
                    }, {
                        key: "placeInitially",
                        value: function() {
                            var e = this,
                                t = this.presentedScene,
                                n = t.position,
                                r = t.element,
                                i = t.getCamera(),
                                a = this.overlay.getBoundingClientRect(),
                                o = a.width,
                                s = a.height;
                            t.setSize(o, s), i.projectionMatrixInverse.copy(i.projectionMatrix).invert();
                            var l = r.getCameraOrbit(),
                                u = l.theta,
                                c = l.radius,
                                h = i.getWorldDirection(u3);
                            t.yaw = Math.atan2(-h.x, -h.z) - u, this.goalYaw = t.yaw, n.copy(i.position).add(h.multiplyScalar(c)), this.updateTarget();
                            var d = t.getTarget();
                            n.add(d).sub(this.oldTarget), this.goalPosition.copy(n), t.setHotspotsVisibility(!0);
                            var f = this.frame.session;
                            f.addEventListener("selectstart", this.onSelectStart), f.addEventListener("selectend", this.onSelectEnd), f.requestHitTestSourceForTransientInput({
                                profile: "generic-touchscreen"
                            }).then(function(t) {
                                e.transientHitTestSource = t
                            })
                        }
                    }, {
                        key: "getTouchLocation",
                        value: function() {
                            var e = this.inputSource.gamepad.axes,
                                t = this.placementBox.getExpandedHit(this.presentedScene, e[0], e[1]);
                            return null != t && (u3.copy(t).sub(this.presentedScene.getCamera().position), u3.length() > 10) ? null : t
                        }
                    }, {
                        key: "getHitPoint",
                        value: function(e) {
                            var t = this.threeRenderer.xr.getReferenceSpace(),
                                n = e.getPose(t);
                            if (null == n) return null;
                            var r = u4.fromArray(n.transform.matrix);
                            return !0 === this.placeOnWall && (this.goalYaw = Math.atan2(r.elements[4], r.elements[6])), r.elements[5] > .75 !== this.placeOnWall ? u5.setFromMatrixPosition(r) : null
                        }
                    }, {
                        key: "moveToFloor",
                        value: function(e) {
                            var t = this.initialHitSource;
                            if (null != t) {
                                var n = e.getHitTestResults(t);
                                if (0 != n.length) {
                                    var r = n[0],
                                        i = this.getHitPoint(r);
                                    null != i && (this.placementBox.show = !0, this.isTranslating || (this.placeOnWall ? this.goalPosition.copy(i) : this.goalPosition.y = i.y), t.cancel(), this.initialHitSource = null, this.dispatchEvent({
                                        type: "status",
                                        status: "object-placed"
                                    }))
                                }
                            }
                        }
                    }, {
                        key: "fingerPolar",
                        value: function(e) {
                            var t = e[0].inputSource.gamepad.axes,
                                n = e[1].inputSource.gamepad.axes,
                                r = n[0] - t[0],
                                i = n[1] - t[1],
                                a = Math.atan2(i, r),
                                o = this.lastAngle - a;
                            return o > Math.PI ? o -= 2 * Math.PI : o < -Math.PI && (o += 2 * Math.PI), this.lastAngle = a, {
                                separation: Math.sqrt(r * r + i * i),
                                deltaYaw: o
                            }
                        }
                    }, {
                        key: "processInput",
                        value: function(e) {
                            var t = this,
                                n = this.transientHitTestSource;
                            if (null != n && (this.isTranslating || this.isTwoFingering || this.isRotating)) {
                                var r = e.getHitTestResultsForTransientInput(n),
                                    i = this.presentedScene,
                                    a = i.scale.x;
                                if (this.isTwoFingering) {
                                    if (r.length < 2) this.isTwoFingering = !1;
                                    else {
                                        var o = this.fingerPolar(r),
                                            s = o.separation,
                                            l = o.deltaYaw;
                                        if (!1 === this.placeOnWall && (this.goalYaw += l), i.canScale) {
                                            var u = s / this.firstRatio;
                                            this.goalScale = u < 1.3 && u > .7692307692307692 ? 1 : u
                                        }
                                    }
                                } else if (2 !== r.length) {
                                    if (this.isRotating) {
                                        var c = 1.5 * this.inputSource.gamepad.axes[0];
                                        this.goalYaw += c - this.lastAngle, this.lastAngle = c
                                    } else this.isTranslating && r.forEach(function(e) {
                                        if (e.inputSource === t.inputSource) {
                                            var n = null;
                                            if (e.results.length > 0 && (n = t.getHitPoint(e.results[0])), null == n && (n = t.getTouchLocation()), null != n) {
                                                if (t.goalPosition.sub(t.lastDragPosition), !1 === t.placeOnWall) {
                                                    var r = n.y - t.lastDragPosition.y;
                                                    if (r < 0) {
                                                        t.placementBox.offsetHeight = r / a, t.presentedScene.setShadowScaleAndOffset(a, r);
                                                        var o = u3.copy(i.getCamera().position),
                                                            s = -r / (o.y - n.y);
                                                        o.multiplyScalar(s), n.multiplyScalar(1 - s).add(o)
                                                    }
                                                }
                                                t.goalPosition.add(n), t.lastDragPosition.copy(n)
                                            }
                                        }
                                    })
                                } else {
                                    this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !0;
                                    var h = this.fingerPolar(r).separation;
                                    this.firstRatio = h / a
                                }
                            }
                        }
                    }, {
                        key: "moveScene",
                        value: function(e) {
                            var t = this.presentedScene,
                                n = t.position,
                                r = t.yaw,
                                i = t.boundingRadius,
                                a = this.goalPosition,
                                o = t.scale.x,
                                s = this.placementBox;
                            if (!a.equals(n) || this.goalScale !== o) {
                                var l = n.x,
                                    u = n.y,
                                    c = n.z;
                                l = this.xDamper.update(l, a.x, e, i), u = this.yDamper.update(u, a.y, e, i), c = this.zDamper.update(c, a.z, e, i), n.set(l, u, c);
                                var h = this.scaleDamper.update(o, this.goalScale, e, 1);
                                if (t.scale.set(h, h, h), !this.isTranslating) {
                                    var d = a.y - u;
                                    this.placementComplete && !1 === this.placeOnWall ? (s.offsetHeight = d / h, t.setShadowScaleAndOffset(h, d)) : 0 === d && (this.placementComplete = !0, s.show = !1, t.setShadowIntensity(.3))
                                }
                            }
                            s.updateOpacity(e), t.updateTarget(e), t.yaw = this.yawDamper.update(r, this.goalYaw, e, Math.PI)
                        }
                    }, {
                        key: "onWebXRFrame",
                        value: function(e, t) {
                            this.frame = t, ++this.frames;
                            var n = this.threeRenderer.xr.getReferenceSpace(),
                                r = t.getViewerPose(n);
                            null == r && !0 === this.tracking && this.frames > 30 && (this.tracking = !1, this.dispatchEvent({
                                type: "tracking",
                                status: "not-tracking"
                            }));
                            var i = this.presentedScene;
                            if (null == r || null == i || !i.element[hh]()) return void this.threeRenderer.clear();
                            !1 === this.tracking && (this.tracking = !0, this.dispatchEvent({
                                type: "tracking",
                                status: u2
                            }));
                            var a = !0,
                                o = !0,
                                s = !1,
                                l = void 0;
                            try {
                                for (var u, c = r.views[Symbol.iterator](); !(o = (u = c.next()).done); o = !0) {
                                    var h = u.value;
                                    if (this.updateView(h), a) {
                                        this.moveToFloor(t), this.processInput(t);
                                        var d = e - this.lastTick;
                                        this.moveScene(d), this.renderer.preRender(i, e, d), this.lastTick = e
                                    }
                                    var f = this.threeRenderer.getContext();
                                    f.depthMask(!1), f.clear(f.DEPTH_BUFFER_BIT), f.depthMask(!0), this.threeRenderer.render(i, i.getCamera()), a = !1
                                }
                            } catch (e) {
                                s = !0, l = e
                            } finally {
                                try {
                                    o || null == c.return || c.return()
                                } finally {
                                    if (s) throw l
                                }
                            }
                        }
                    }]), t
                }(eW),
                u7 = function() {
                    function e(t) {
                        (0, k._)(this, e), t.threeRenderer.debug = {
                            checkShaderErrors: !0
                        }, Promise.resolve().then(function() {
                            self.dispatchEvent(new CustomEvent("model-viewer-renderer-debug", {
                                detail: {
                                    renderer: t,
                                    THREE: {
                                        ShaderMaterial: n3,
                                        Texture: te,
                                        Mesh: nK,
                                        Scene: aC,
                                        PlaneBufferGeometry: rl,
                                        OrthographicCamera: ry,
                                        WebGLRenderTarget: tr
                                    }
                                }
                            }))
                        })
                    }
                    return (0, A._)(e, [{
                        key: "addScene",
                        value: function(e) {
                            self.dispatchEvent(new CustomEvent("model-viewer-scene-added-debug", {
                                detail: {
                                    scene: e
                                }
                            }))
                        }
                    }, {
                        key: "removeScene",
                        value: function(e) {
                            self.dispatchEvent(new CustomEvent("model-viewer-scene-removed-debug", {
                                detail: {
                                    scene: e
                                }
                            }))
                        }
                    }]), e
                }(),
                u9 = Symbol("prepared"),
                ce = Symbol("prepare"),
                ct = Symbol("preparedGLTF"),
                cn = Symbol("clone"),
                cr = function() {
                    function e(t) {
                        (0, k._)(this, e), this[ct] = t
                    }
                    return (0, A._)(e, [{
                        key: "parser",
                        get: function() {
                            return this[ct].parser
                        }
                    }, {
                        key: "animations",
                        get: function() {
                            return this[ct].animations
                        }
                    }, {
                        key: "scene",
                        get: function() {
                            return this[ct].scene
                        }
                    }, {
                        key: "scenes",
                        get: function() {
                            return this[ct].scenes
                        }
                    }, {
                        key: "cameras",
                        get: function() {
                            return this[ct].cameras
                        }
                    }, {
                        key: "asset",
                        get: function() {
                            return this[ct].asset
                        }
                    }, {
                        key: "userData",
                        get: function() {
                            return this[ct].userData
                        }
                    }, {
                        key: "clone",
                        value: function() {
                            return new this.constructor(this[cn]())
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            this.scenes.forEach(function(e) {
                                e.traverse(function(e) {
                                    e.isMesh && ((Array.isArray(e.material) ? e.material : [e.material]).forEach(function(e) {
                                        for (var t in e) {
                                            var n = e[t];
                                            n instanceof te && n.dispose()
                                        }
                                        e.dispose()
                                    }), e.geometry.dispose())
                                })
                            })
                        }
                    }, {
                        key: cn,
                        value: function() {
                            var e, t, n, r, i = this[ct],
                                a = (e = this.scene, t = new Map, n = new Map, r = e.clone(), function e(t, n, r) {
                                    r(t, n);
                                    for (var i = 0; i < t.children.length; i++) e(t.children[i], n.children[i], r)
                                }(e, r, function(e, r) {
                                    t.set(r, e), n.set(e, r)
                                }), r.traverse(function(e) {
                                    if (e.isSkinnedMesh) {
                                        var r = t.get(e),
                                            i = r.skeleton.bones;
                                        e.skeleton = r.skeleton.clone(), e.bindMatrix.copy(r.bindMatrix), e.skeleton.bones = i.map(function(e) {
                                            return n.get(e)
                                        }), e.bind(e.skeleton, e.bindMatrix)
                                    }
                                }), r);
                            ci(a, this.scene);
                            var o = [a],
                                s = i.userData ? Object.assign({}, i.userData) : {};
                            return Object.assign(Object.assign({}, i), {
                                scene: a,
                                scenes: o,
                                userData: s
                            })
                        }
                    }], [{
                        key: "prepare",
                        value: function(e) {
                            if (null == e.scene) throw Error("Model does not have a scene");
                            if (e[u9]) return e;
                            var t = this[ce](e);
                            return t[u9] = !0, t
                        }
                    }, {
                        key: ce,
                        value: function(e) {
                            var t = e.scene,
                                n = [t];
                            return Object.assign(Object.assign({}, e), {
                                scene: t,
                                scenes: n
                            })
                        }
                    }]), e
                }(),
                ci = function(e, t) {
                    ca(e, t, function(e, t) {
                        void 0 !== t.userData.variantMaterials && (e.userData.variantMaterials = new Map(t.userData.variantMaterials)), void 0 !== t.userData.variantData && (e.userData.variantData = t.userData.variantData), void 0 !== t.userData.originalMaterial && (e.userData.originalMaterial = t.userData.originalMaterial)
                    })
                },
                ca = function(e, t, n) {
                    n(e, t);
                    for (var r = 0; r < e.children.length; r++) ca(e.children[r], t.children[r], n)
                },
                co = Symbol("threeGLTF"),
                cs = Symbol("gltf"),
                cl = Symbol("gltfElementMap"),
                cu = Symbol("threeObjectMap"),
                cc = Symbol("parallelTraverseThreeScene"),
                ch = Symbol("correlateOriginalThreeGLTF"),
                cd = Symbol("correlateCloneThreeGLTF"),
                cf = function() {
                    function e(t, n, r, i) {
                        (0, k._)(this, e), this[co] = t, this[cs] = n, this[cl] = i, this[cu] = r
                    }
                    return (0, A._)(e, [{
                        key: "threeGLTF",
                        get: function() {
                            return this[co]
                        }
                    }, {
                        key: "gltf",
                        get: function() {
                            return this[cs]
                        }
                    }, {
                        key: "gltfElementMap",
                        get: function() {
                            return this[cl]
                        }
                    }, {
                        key: "threeObjectMap",
                        get: function() {
                            return this[cu]
                        }
                    }], [{
                        key: "from",
                        value: function(e, t) {
                            return null != t ? this[cd](e, t) : this[ch](e)
                        }
                    }, {
                        key: ch,
                        value: function(t) {
                            var n = t.parser.json,
                                r = t.parser.associations,
                                i = new Map,
                                a = {
                                    name: "Default"
                                },
                                o = {
                                    index: -1
                                },
                                s = !0,
                                l = !1,
                                u = void 0;
                            try {
                                for (var c, h = r.keys()[Symbol.iterator](); !(s = (c = h.next()).done); s = !0) {
                                    var d = c.value;
                                    d instanceof nh && null == r.get(d) && (o.index < 0 && (null == n.materials && (n.materials = []), o.index = n.materials.length, n.materials.push(a)), d.name = a.name, r.set(d, {
                                        materials: o.index
                                    }))
                                }
                            } catch (e) {
                                l = !0, u = e
                            } finally {
                                try {
                                    s || null == h.return || h.return()
                                } finally {
                                    if (l) throw u
                                }
                            }
                            var f = !0,
                                p = !1,
                                m = void 0;
                            try {
                                for (var v, g = r[Symbol.iterator](); !(f = (v = g.next()).done); f = !0) {
                                    var y = (0, O._)(v.value, 2),
                                        _ = y[0],
                                        x = y[1];
                                    for (var b in x && (_.userData = _.userData || {}, _.userData.associations = x), x)
                                        if (null != b && "primitives" !== b) {
                                            var w = (n[b] || [])[x[b]];
                                            if (null == w) continue;
                                            var M = i.get(w);
                                            null == M && (M = new Set, i.set(w, M)), M.add(_)
                                        }
                                }
                            } catch (e) {
                                p = !0, m = e
                            } finally {
                                try {
                                    f || null == g.return || g.return()
                                } finally {
                                    if (p) throw m
                                }
                            }
                            return new e(t, n, r, i)
                        }
                    }, {
                        key: cd,
                        value: function(t, n) {
                            for (var r = n.threeGLTF, i = JSON.parse(JSON.stringify(n.gltf)), a = new Map, o = new Map, s = 0; s < r.scenes.length; s++) this[cc](r.scenes[s], t.scenes[s], function(e, t) {
                                var r = n.threeObjectMap.get(e);
                                if (null != r) {
                                    for (var s in r)
                                        if (null != s && "primitives" !== s) {
                                            var l = r[s],
                                                u = i[s][l],
                                                c = a.get(t) || {};
                                            c[s] = l, a.set(t, c);
                                            var h = o.get(u) || new Set;
                                            h.add(t), o.set(u, h)
                                        }
                                }
                            });
                            return new e(t, i, a, o)
                        }
                    }, {
                        key: cc,
                        value: function(e, t, n) {
                            var r = function(e, t) {
                                if (n(e, t), e.isObject3D) {
                                    if (e.isMesh) {
                                        if (Array.isArray(e.material))
                                            for (var i = 0; i < e.material.length; ++i) r(e.material[i], t.material[i]);
                                        else r(e.material, t.material)
                                    }
                                    for (var a = 0; a < e.children.length; ++a) r(e.children[a], t.children[a])
                                }
                            };
                            r(e, t)
                        }
                    }]), e
                }(),
                cp = Symbol("correlatedSceneGraph"),
                cm = function(e) {
                    function t() {
                        return (0, k._)(this, t), (0, E._)(this, t, arguments)
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "correlatedSceneGraph",
                        get: function() {
                            return this[ct][cp]
                        }
                    }, {
                        key: cn,
                        value: function() {
                            var e = L((0, C._)(t.prototype), cn, this).call(this),
                                n = new Map;
                            return e.scene.traverse(function(e) {
                                if (e.isMesh) {
                                    var t = e.material;
                                    if (null != t) {
                                        if (n.has(t.uuid)) return void(e.material = n.get(t.uuid));
                                        e.material = t.clone(), n.set(t.uuid, e.material)
                                    }
                                }
                            }), e[cp] = cf.from(e, this.correlatedSceneGraph), e
                        }
                    }], [{
                        key: ce,
                        value: function(e) {
                            var n = L((0, C._)(t), ce, this).call(this, e);
                            null == n[cp] && (n[cp] = cf.from(n));
                            var r = n.scene,
                                i = new tA(void 0, 1 / 0);
                            return r.traverse(function(e) {
                                e.renderOrder = 1e3, e.frustumCulled = !1, e.name || (e.name = e.uuid), e.isMesh && (e.castShadow = !0, e.isSkinnedMesh && (e.geometry.boundingSphere = i, e.geometry.boundingBox = null), e.material.shadowSide = 0)
                            }), n
                        }
                    }]), t
                }(cr),
                cv = function(e) {
                    function t() {
                        (0, k._)(this, t), (e = (0, E._)(this, t)).position.y = -3.5;
                        var e, n = new n$;
                        n.deleteAttribute("uv");
                        var r = new o9({
                                metalness: 0,
                                side: 1
                            }),
                            i = new o9({
                                metalness: 0
                            }),
                            a = new sO(0xffffff, 500, 28, 2);
                        a.position.set(.418, 16.199, .3), e.add(a);
                        var o = new nK(n, r);
                        o.position.set(-.757, 13.219, .717), o.scale.set(31.713, 28.305, 28.591), e.add(o);
                        var s = new nK(n, i);
                        s.position.set(-10.906, 2.009, 1.846), s.rotation.set(0, -.195, 0), s.scale.set(2.328, 7.905, 4.651), e.add(s);
                        var l = new nK(n, i);
                        l.position.set(-5.607, -.754, -.758), l.rotation.set(0, .994, 0), l.scale.set(1.97, 1.534, 3.955), e.add(l);
                        var u = new nK(n, i);
                        u.position.set(6.167, .857, 7.803), u.rotation.set(0, .561, 0), u.scale.set(3.927, 6.285, 3.687), e.add(u);
                        var c = new nK(n, i);
                        c.position.set(-2.017, .018, 6.124), c.rotation.set(0, .333, 0), c.scale.set(2.002, 4.566, 2.064), e.add(c);
                        var h = new nK(n, i);
                        h.position.set(2.291, -.756, -2.621), h.rotation.set(0, -.286, 0), h.scale.set(1.546, 1.552, 1.496), e.add(h);
                        var d = new nK(n, i);
                        d.position.set(-2.193, -.369, -5.547), d.rotation.set(0, .516, 0), d.scale.set(3.875, 3.487, 2.986), e.add(d);
                        var f = new nK(n, e.createAreaLightMaterial(50));
                        f.position.set(-16.116, 14.37, 8.208), f.scale.set(.1, 2.428, 2.739), e.add(f);
                        var p = new nK(n, e.createAreaLightMaterial(50));
                        p.position.set(-16.109, 18.021, -8.207), p.scale.set(.1, 2.425, 2.751), e.add(p);
                        var m = new nK(n, e.createAreaLightMaterial(17));
                        m.position.set(14.904, 12.198, -1.832), m.scale.set(.15, 4.265, 6.331), e.add(m);
                        var v = new nK(n, e.createAreaLightMaterial(43));
                        v.position.set(-.462, 8.89, 14.52), v.scale.set(4.38, 5.441, .088), e.add(v);
                        var g = new nK(n, e.createAreaLightMaterial(20));
                        g.position.set(3.235, 11.486, -12.541), g.scale.set(2.5, 2, .1), e.add(g);
                        var y = new nK(n, e.createAreaLightMaterial(100));
                        return y.position.set(0, 20, 0), y.scale.set(1, .1, 1), e.add(y), e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "createAreaLightMaterial",
                        value: function(e) {
                            var t = new n_;
                            return t.color.setScalar(e), t
                        }
                    }]), t
                }(aC),
                cg = function(e) {
                    function t() {
                        (0, k._)(this, t), (e = (0, E._)(this, t)).position.y = -3.5;
                        var e, n = new n$;
                        n.deleteAttribute("uv");
                        var r = new o9({
                                metalness: 0,
                                side: 1
                            }),
                            i = new o9({
                                metalness: 0
                            }),
                            a = new sO(0xffffff, 400, 28, 2);
                        a.position.set(.5, 14, .5), e.add(a);
                        var o = new nK(n, r);
                        o.position.set(0, 13.2, 0), o.scale.set(31.5, 28.5, 31.5), e.add(o);
                        var s = new nK(n, i);
                        s.position.set(-10.906, -1, 1.846), s.rotation.set(0, -.195, 0), s.scale.set(2.328, 7.905, 4.651), e.add(s);
                        var l = new nK(n, i);
                        l.position.set(-5.607, -.754, -.758), l.rotation.set(0, .994, 0), l.scale.set(1.97, 1.534, 3.955), e.add(l);
                        var u = new nK(n, i);
                        u.position.set(6.167, -.16, 7.803), u.rotation.set(0, .561, 0), u.scale.set(3.927, 6.285, 3.687), e.add(u);
                        var c = new nK(n, i);
                        c.position.set(-2.017, .018, 6.124), c.rotation.set(0, .333, 0), c.scale.set(2.002, 4.566, 2.064), e.add(c);
                        var h = new nK(n, i);
                        h.position.set(2.291, -.756, -2.621), h.rotation.set(0, -.286, 0), h.scale.set(1.546, 1.552, 1.496), e.add(h);
                        var d = new nK(n, i);
                        d.position.set(-2.193, -.369, -5.547), d.rotation.set(0, .516, 0), d.scale.set(3.875, 3.487, 2.986), e.add(d);
                        var f = new nK(n, e.createAreaLightMaterial(80));
                        f.position.set(-14, 10, 8), f.scale.set(.1, 2.5, 2.5), e.add(f);
                        var p = new nK(n, e.createAreaLightMaterial(80));
                        p.position.set(-14, 14, -4), p.scale.set(.1, 2.5, 2.5), e.add(p);
                        var m = new nK(n, e.createAreaLightMaterial(23));
                        m.position.set(14, 12, 0), m.scale.set(.1, 5, 5), e.add(m);
                        var v = new nK(n, e.createAreaLightMaterial(16));
                        v.position.set(0, 9, 14), v.scale.set(5, 5, .1), e.add(v);
                        var g = new nK(n, e.createAreaLightMaterial(80));
                        g.position.set(7, 8, -14), g.scale.set(2.5, 2.5, .1), e.add(g);
                        var y = new nK(n, e.createAreaLightMaterial(80));
                        y.position.set(-7, 16, -14), y.scale.set(2.5, 2.5, .1), e.add(y);
                        var _ = new nK(n, e.createAreaLightMaterial(1));
                        return _.position.set(0, 20, 0), _.scale.set(.1, .1, .1), e.add(_), e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "createAreaLightMaterial",
                        value: function(e) {
                            var t = new n_;
                            return t.color.setScalar(e), t
                        }
                    }]), t
                }(aC),
                cy = /\.hdr(\.js)?$/,
                c_ = new sM,
                cx = new(function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t, [e])).type = 1016, n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "parse",
                        value: function(e) {
                            var t = function(e, t) {
                                    switch (e) {
                                        case 1:
                                            console.error("THREE.RGBELoader Read Error: " + (t || ""));
                                            break;
                                        case 2:
                                            console.error("THREE.RGBELoader Write Error: " + (t || ""));
                                            break;
                                        case 3:
                                            console.error("THREE.RGBELoader Bad File Format: " + (t || ""));
                                            break;
                                        default:
                                            console.error("THREE.RGBELoader: Error: " + (t || ""))
                                    }
                                    return -1
                                },
                                n = function(e, t, n) {
                                    t = t || 1024;
                                    for (var r = e.pos, i = -1, a = 0, o = "", s = String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128))); 0 > (i = s.indexOf("\n")) && a < t && r < e.byteLength;) o += s, a += s.length, r += 128, s += String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));
                                    return -1 < i && (!1 !== n && (e.pos += a + i + 1), o + s.slice(0, i))
                                },
                                r = new Uint8Array(e);
                            r.pos = 0;
                            var i = function(e) {
                                var r, i, a = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                                    o = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                                    s = /^\s*FORMAT=(\S+)\s*$/,
                                    l = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                                    u = {
                                        valid: 0,
                                        string: "",
                                        comments: "",
                                        programtype: "RGBE",
                                        format: "",
                                        gamma: 1,
                                        exposure: 1,
                                        width: 0,
                                        height: 0
                                    };
                                if (e.pos >= e.byteLength || !(r = n(e))) return t(1, "no header found");
                                if (!(i = r.match(/^#\?(\S+)/))) return t(3, "bad initial token");
                                for (u.valid |= 1, u.programtype = i[1], u.string += r + "\n"; !1 !== (r = n(e));)
                                    if (u.string += r + "\n", "#" !== r.charAt(0)) {
                                        if ((i = r.match(a)) && (u.gamma = parseFloat(i[1], 10)), (i = r.match(o)) && (u.exposure = parseFloat(i[1], 10)), (i = r.match(s)) && (u.valid |= 2, u.format = i[1]), (i = r.match(l)) && (u.valid |= 4, u.height = parseInt(i[1], 10), u.width = parseInt(i[2], 10)), 2 & u.valid && 4 & u.valid) break
                                    } else u.comments += r + "\n";
                                return 2 & u.valid ? 4 & u.valid ? u : t(3, "missing image size specifier") : t(3, "missing format specifier")
                            }(r);
                            if (-1 !== i) {
                                var a, o, s, l, u = i.width,
                                    c = i.height,
                                    h = function(e, n, r) {
                                        if (n < 8 || n > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2]) return new Uint8Array(e);
                                        if (n !== (e[2] << 8 | e[3])) return t(3, "wrong scanline width");
                                        var i = new Uint8Array(4 * n * r);
                                        if (!i.length) return t(4, "unable to allocate buffer space");
                                        for (var a = 0, o = 0, s = 4 * n, l = new Uint8Array(4), u = new Uint8Array(s), c = r; c > 0 && o < e.byteLength;) {
                                            if (o + 4 > e.byteLength) return t(1);
                                            if (l[0] = e[o++], l[1] = e[o++], l[2] = e[o++], l[3] = e[o++], 2 != l[0] || 2 != l[1] || (l[2] << 8 | l[3]) != n) return t(3, "bad rgbe scanline format");
                                            for (var h = void 0, d = 0; d < s && o < e.byteLength;) {
                                                var f = (h = e[o++]) > 128;
                                                if (f && (h -= 128), 0 === h || d + h > s) return t(3, "bad scanline data");
                                                if (f)
                                                    for (var p = e[o++], m = 0; m < h; m++) u[d++] = p;
                                                else u.set(e.subarray(o, o + h), d), d += h, o += h
                                            }
                                            for (var v = 0; v < n; v++) {
                                                var g = 0;
                                                i[a] = u[v + g], g += n, i[a + 1] = u[v + g], g += n, i[a + 2] = u[v + g], g += n, i[a + 3] = u[v + g], a += 4
                                            }
                                            c--
                                        }
                                        return i
                                    }(r.subarray(r.pos), u, c);
                                if (-1 !== h) {
                                    switch (this.type) {
                                        case 1015:
                                            for (var d = new Float32Array(3 * (l = h.length / 4)), f = 0; f < l; f++) ! function(e, t, n, r) {
                                                var i = Math.pow(2, e[t + 3] - 128) / 255;
                                                n[r + 0] = e[t + 0] * i, n[r + 1] = e[t + 1] * i, n[r + 2] = e[t + 2] * i
                                            }(h, 4 * f, d, 3 * f);
                                            a = d, o = 1022, s = 1015;
                                            break;
                                        case 1016:
                                            for (var p = new Uint16Array(3 * (l = h.length / 4)), m = 0; m < l; m++) ! function(e, t, n, r) {
                                                var i = Math.pow(2, e[t + 3] - 128) / 255;
                                                n[r + 0] = s5.toHalfFloat(Math.min(e[t + 0] * i, 65504)), n[r + 1] = s5.toHalfFloat(Math.min(e[t + 1] * i, 65504)), n[r + 2] = s5.toHalfFloat(Math.min(e[t + 2] * i, 65504))
                                            }(h, 4 * m, p, 3 * m);
                                            a = p, o = 1022, s = 1016;
                                            break;
                                        default:
                                            console.error("THREE.RGBELoader: unsupported type: ", this.type)
                                    }
                                    return {
                                        width: u,
                                        height: c,
                                        data: a,
                                        header: i.string,
                                        gamma: i.gamma,
                                        exposure: i.exposure,
                                        format: o,
                                        type: s
                                    }
                                }
                            }
                            return null
                        }
                    }, {
                        key: "setDataType",
                        value: function(e) {
                            return this.type = e, this
                        }
                    }, {
                        key: "load",
                        value: function(e, n, r, i) {
                            return L((0, C._)(t.prototype), "load", this).call(this, e, function(e, t) {
                                switch (e.type) {
                                    case 1015:
                                    case 1016:
                                        e.encoding = 3e3, e.minFilter = 1006, e.magFilter = 1006, e.generateMipmaps = !1, e.flipY = !0
                                }
                                n && n(e, t)
                            }, r, i)
                        }
                    }]), t
                }(sw));
            cx.setDataType(1016);
            var cb = function(e) {
                    function t(e) {
                        var n;
                        return (0, k._)(this, t), (n = (0, E._)(this, t)).threeRenderer = e, n.generatedEnvironmentMap = null, n.generatedEnvironmentMapAlt = null, n.skyboxCache = new Map, n.blurMaterial = null, n.blurScene = null, n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "load",
                        value: function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function() {};
                            return (0, T._)(function() {
                                var n, r, i;
                                return (0, z.YH)(this, function(a) {
                                    switch (a.label) {
                                        case 0:
                                            return a.trys.push([0, , 2, 3]), r = (n = cy.test(e)) ? cx : c_, [4, new Promise(function(n, i) {
                                                return r.load(e, n, function(e) {
                                                    t(e.loaded / e.total * .9)
                                                }, i)
                                            })];
                                        case 1:
                                            return i = a.sent(), [2, (t(1), i.name = e, i.mapping = 303, n || (i.encoding = 3001), i)];
                                        case 2:
                                            return t && t(1), [7];
                                        case 3:
                                            return [2]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "generateEnvironmentMapAndSkybox",
                        value: function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                                r = this;
                            return (0, T._)(function() {
                                var i, a, o, s, l, u;
                                return (0, z.YH)(this, function(c) {
                                    switch (c.label) {
                                        case 0:
                                            return i = n.progressTracker, !0 == (a = "neutral" === t) && (t = null), t = uc(t), o = Promise.resolve(null), e && (o = r.loadEquirectFromUrl(e, i)), [4, Promise.all([t ? r.loadEquirectFromUrl(t, i) : e ? r.loadEquirectFromUrl(e, i) : !0 === a ? r.loadGeneratedEnvironmentMapAlt() : r.loadGeneratedEnvironmentMap(), o])];
                                        case 1:
                                            if (l = (s = O._.apply(void 0, [c.sent(), 2]))[0], u = s[1], null == l) throw Error("Failed to load environment map.");
                                            return [2, {
                                                environmentMap: l,
                                                skybox: u
                                            }]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "loadEquirectFromUrl",
                        value: function(e, t) {
                            var n = this;
                            return (0, T._)(function() {
                                var r, i;
                                return (0, z.YH)(this, function(a) {
                                    return n.skyboxCache.has(e) || (r = t ? t.beginActivity() : function() {}, i = n.load(e, r), n.skyboxCache.set(e, i)), [2, n.skyboxCache.get(e)]
                                })
                            })()
                        }
                    }, {
                        key: "GenerateEnvironmentMap",
                        value: function(e, t) {
                            var n = this;
                            return (0, T._)(function() {
                                var r, i, a, o, s, l;
                                return (0, z.YH)(this, function(u) {
                                    switch (u.label) {
                                        case 0:
                                            return [4, ug()];
                                        case 1:
                                            return u.sent(), r = n.threeRenderer, (o = (a = new n6(.1, 100, i = new n7(256, {
                                                generateMipmaps: !1,
                                                type: 1016,
                                                format: 1023,
                                                encoding: 3e3,
                                                depthBuffer: !0
                                            }))).renderTarget.texture).name = t, o.isRenderTargetTexture = !1, o.images = [1, 1, 1, 1, 1, 1], e.scale.setComponent(0, -1), s = r.outputEncoding, l = r.toneMapping, r.toneMapping = 0, r.outputEncoding = 3e3, a.update(r, e), [4, n.blurCubemap(i, .04)];
                                        case 2:
                                            return [2, (u.sent(), r.toneMapping = l, r.outputEncoding = s, o)]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "loadGeneratedEnvironmentMap",
                        value: function() {
                            var e = this;
                            return (0, T._)(function() {
                                return (0, z.YH)(this, function(t) {
                                    return [2, (null == e.generatedEnvironmentMap && (e.generatedEnvironmentMap = e.GenerateEnvironmentMap(new cv, "default")), e.generatedEnvironmentMap)]
                                })
                            })()
                        }
                    }, {
                        key: "loadGeneratedEnvironmentMapAlt",
                        value: function() {
                            var e = this;
                            return (0, T._)(function() {
                                return (0, z.YH)(this, function(t) {
                                    return [2, (null == e.generatedEnvironmentMapAlt && (e.generatedEnvironmentMapAlt = e.GenerateEnvironmentMap(new cg, "neutral")), e.generatedEnvironmentMapAlt)]
                                })
                            })()
                        }
                    }, {
                        key: "blurCubemap",
                        value: function(e, t) {
                            var n = this;
                            return (0, T._)(function() {
                                var r, i;
                                return (0, z.YH)(this, function(a) {
                                    return null == n.blurMaterial && (n.blurMaterial = n.getBlurShader(20), r = new nK(new n$, n.blurMaterial), n.blurScene = new aC, n.blurScene.add(r)), i = e.clone(), n.halfblur(e, i, t, "latitudinal"), n.halfblur(i, e, t, "longitudinal"), [2]
                                })
                            })()
                        }
                    }, {
                        key: "halfblur",
                        value: function(e, t, n, r) {
                            var i = this;
                            return (0, T._)(function() {
                                var a, o, s, l, u, c, h, d, f, p, m;
                                return (0, z.YH)(this, function(v) {
                                    for (a = e.width, o = isFinite(n) ? Math.PI / (2 * a) : 2 * Math.PI / 39, s = n / o, (l = isFinite(n) ? 1 + Math.floor(3 * s) : 20) > 20 && console.warn("sigmaRadians, ".concat(n, ", is too large and will clip, as it requested ").concat(l, " samples when the maximum is set to 20")), u = [], c = 0, h = 0; h < 20; ++h) f = Math.exp(-(d = h / s) * d / 2), u.push(f), 0 == h ? c += f : h < l && (c += 2 * f);
                                    for (p = 0; p < u.length; p++) u[p] = u[p] / c;
                                    return (m = i.blurMaterial.uniforms).envMap.value = e.texture, m.samples.value = l, m.weights.value = u, m.latitudinal.value = "latitudinal" === r, m.dTheta.value = o, new n6(.1, 100, t).update(i.threeRenderer, i.blurScene), [2]
                                })
                            })()
                        }
                    }, {
                        key: "getBlurShader",
                        value: function(e) {
                            var t = new Float32Array(e);
                            return new n3({
                                name: "SphericalGaussianBlur",
                                defines: {
                                    n: e
                                },
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    samples: {
                                        value: 1
                                    },
                                    weights: {
                                        value: t
                                    },
                                    latitudinal: {
                                        value: !1
                                    },
                                    dTheta: {
                                        value: 0
                                    },
                                    poleAxis: {
                                        value: new to(0, 1, 0)
                                    }
                                },
                                vertexShader: "\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    ",
                                fragmentShader: "\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      ",
                                blending: 0,
                                depthTest: !1,
                                depthWrite: !1,
                                side: 1
                            })
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            var e = this;
                            return (0, T._)(function() {
                                var t, n, r, i, a, o;
                                return (0, z.YH)(this, function(s) {
                                    switch (s.label) {
                                        case 0:
                                            t = !0, n = !1, r = void 0, s.label = 1;
                                        case 1:
                                            s.trys.push([1, 6, 7, 8]), i = e.skyboxCache[Symbol.iterator](), s.label = 2;
                                        case 2:
                                            if (t = (a = i.next()).done) return [3, 5];
                                            return [4, (0, O._)(a.value, 2)[1]];
                                        case 3:
                                            s.sent().dispose(), s.label = 4;
                                        case 4:
                                            return t = !0, [3, 2];
                                        case 5:
                                            return [3, 8];
                                        case 6:
                                            return o = s.sent(), n = !0, r = o, [3, 8];
                                        case 7:
                                            try {
                                                t || null == i.return || i.return()
                                            } finally {
                                                if (n) throw r
                                            }
                                            return [7];
                                        case 8:
                                            if (!(null != e.generatedEnvironmentMap)) return [3, 10];
                                            return [4, e.generatedEnvironmentMap];
                                        case 9:
                                            s.sent().dispose(), e.generatedEnvironmentMap = null, s.label = 10;
                                        case 10:
                                            if (!(null != e.generatedEnvironmentMapAlt)) return [3, 12];
                                            return [4, e.generatedEnvironmentMapAlt];
                                        case 11:
                                            s.sent().dispose(), e.generatedEnvironmentMapAlt = null, s.label = 12;
                                        case 12:
                                            return null != e.blurMaterial && e.blurMaterial.dispose(), [2]
                                    }
                                })
                            })()
                        }
                    }]), t
                }(eW),
                cw = [1, .79, .62, .5, .4, .31, .25],
                cM = function(e) {
                    function t(e) {
                        var n;
                        (0, k._)(this, t), (n = (0, E._)(this, t)).loader = new un(cm), n.width = 0, n.height = 0, n.dpr = 1, n.debugger = null, n.scenes = new Set, n.multipleScenesVisible = !1, n.scaleStep = 0, n.lastStep = 3, n.avgFrameDuration = 22, n.onWebGLContextLost = function(e) {
                            n.dispatchEvent({
                                type: "contextlost",
                                sourceEvent: e
                            })
                        }, n.onWebGLContextRestored = function() {
                            null === (i = n.textureUtils) || void 0 === i || i.dispose(), n.textureUtils = new cb(n.threeRenderer);
                            var e = !0,
                                t = !1,
                                r = void 0;
                            try {
                                for (var i, a, o = n.scenes[Symbol.iterator](); !(e = (a = o.next()).done); e = !0) a.value.element[uj]()
                            } catch (e) {
                                t = !0, r = e
                            } finally {
                                try {
                                    e || null == o.return || o.return()
                                } finally {
                                    if (t) throw r
                                }
                            }
                            n.threeRenderer.shadowMap.needsUpdate = !0
                        }, n.dpr = um(), n.canvas3D = document.createElement("canvas"), n.canvas3D.id = "webgl-canvas";
                        try {
                            n.threeRenderer = new aR({
                                canvas: n.canvas3D,
                                alpha: !0,
                                antialias: !0,
                                powerPreference: e.powerPreference,
                                preserveDrawingBuffer: !0
                            }), n.threeRenderer.autoClear = !0, n.threeRenderer.outputEncoding = 3001, n.threeRenderer.physicallyCorrectLights = !0, n.threeRenderer.setPixelRatio(1), n.threeRenderer.shadowMap.enabled = !0, n.threeRenderer.shadowMap.type = 2, n.threeRenderer.shadowMap.autoUpdate = !1, n.debugger = e.debug ? new u7(n) : null, n.threeRenderer.debug = {
                                checkShaderErrors: !!n.debugger
                            }, n.threeRenderer.toneMapping = 4
                        } catch (e) {
                            console.warn(e)
                        }
                        return n.arRenderer = new u8(n), n.textureUtils = n.canRender ? new cb(n.threeRenderer) : null, un.initializeKTX2Loader(n.threeRenderer), n.canvas3D.addEventListener("webglcontextlost", n.onWebGLContextLost), n.canvas3D.addEventListener("webglcontextrestored", n.onWebGLContextRestored), n.updateRendererSize(), n.lastTick = performance.now(), n.avgFrameDuration = 0, n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "canRender",
                        get: function() {
                            return null != this.threeRenderer
                        }
                    }, {
                        key: "scaleFactor",
                        get: function() {
                            return cw[this.scaleStep]
                        }
                    }, {
                        key: "minScale",
                        set: function(e) {
                            for (var t = 1; t < cw.length && !(cw[t] < e);) ++t;
                            this.lastStep = t - 1
                        }
                    }, {
                        key: "updateRendererSize",
                        value: function() {
                            var e = um(),
                                t = !0,
                                n = !1,
                                r = void 0;
                            if (e !== this.dpr) try {
                                for (var i, a = this.scenes[Symbol.iterator](); !(t = (i = a.next()).done); t = !0) {
                                    var o = i.value.element;
                                    o[c0](o.getBoundingClientRect())
                                }
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == a.return || a.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                            var s = 0,
                                l = 0,
                                u = !0,
                                c = !1,
                                h = void 0;
                            try {
                                for (var d, f = this.scenes[Symbol.iterator](); !(u = (d = f.next()).done); u = !0) {
                                    var p = d.value;
                                    s = Math.max(s, p.width), l = Math.max(l, p.height)
                                }
                            } catch (e) {
                                c = !0, h = e
                            } finally {
                                try {
                                    u || null == f.return || f.return()
                                } finally {
                                    if (c) throw h
                                }
                            }
                            if (s !== this.width || l !== this.height || e !== this.dpr) {
                                this.width = s, this.height = l, this.dpr = e, this.canRender && this.threeRenderer.setSize(s * e, l * e, !1);
                                var m = this.scaleFactor,
                                    v = s / m,
                                    g = l / m;
                                this.canvas3D.style.width = "".concat(v, "px"), this.canvas3D.style.height = "".concat(g, "px");
                                var y = !0,
                                    _ = !1,
                                    x = void 0;
                                try {
                                    for (var b, w = this.scenes[Symbol.iterator](); !(y = (b = w.next()).done); y = !0) {
                                        var M = b.value,
                                            S = M.canvas;
                                        S.width = Math.round(s * e), S.height = Math.round(l * e), S.style.width = "".concat(v, "px"), S.style.height = "".concat(g, "px"), M.queueRender()
                                    }
                                } catch (e) {
                                    _ = !0, x = e
                                } finally {
                                    try {
                                        y || null == w.return || w.return()
                                    } finally {
                                        if (_) throw x
                                    }
                                }
                            }
                        }
                    }, {
                        key: "updateRendererScale",
                        value: function() {
                            var e = this.scaleStep;
                            if (this.avgFrameDuration > 26 ? ++this.scaleStep : this.avgFrameDuration < 18 && this.scaleStep > 0 && --this.scaleStep, this.scaleStep = Math.min(this.scaleStep, this.lastStep), e != this.scaleStep) {
                                var t = this.scaleFactor;
                                this.avgFrameDuration = 22;
                                var n = this.width / t,
                                    r = this.height / t;
                                this.canvas3D.style.width = "".concat(n, "px"), this.canvas3D.style.height = "".concat(r, "px");
                                var i = !0,
                                    a = !1,
                                    o = void 0;
                                try {
                                    for (var s, l = this.scenes[Symbol.iterator](); !(i = (s = l.next()).done); i = !0) {
                                        var u = s.value,
                                            c = u.canvas.style;
                                        c.width = "".concat(n, "px"), c.height = "".concat(r, "px"), u.queueRender()
                                    }
                                } catch (e) {
                                    a = !0, o = e
                                } finally {
                                    try {
                                        i || null == l.return || l.return()
                                    } finally {
                                        if (a) throw o
                                    }
                                }
                            }
                        }
                    }, {
                        key: "registerScene",
                        value: function(e) {
                            var t = this;
                            this.scenes.add(e);
                            var n = e.canvas,
                                r = this.scaleFactor;
                            n.width = Math.round(this.width * this.dpr), n.height = Math.round(this.height * this.dpr), n.style.width = this.width / r + "px", n.style.height = this.height / r + "px", this.multipleScenesVisible && n.classList.add("show"), e.queueRender(), this.canRender && this.scenes.size > 0 && this.threeRenderer.setAnimationLoop(function(e, n) {
                                return t.render(e, n)
                            }), null != this.debugger && this.debugger.addScene(e)
                        }
                    }, {
                        key: "unregisterScene",
                        value: function(e) {
                            this.scenes.delete(e), this.canRender && 0 === this.scenes.size && this.threeRenderer.setAnimationLoop(null), null != this.debugger && this.debugger.removeScene(e)
                        }
                    }, {
                        key: "displayCanvas",
                        value: function(e) {
                            return this.multipleScenesVisible ? e.element[he] : this.canvas3D
                        }
                    }, {
                        key: "selectCanvas",
                        value: function() {
                            var e = 0,
                                t = null,
                                n = !0,
                                r = !1,
                                i = void 0;
                            try {
                                for (var a, o = this.scenes[Symbol.iterator](); !(n = (a = o.next()).done); n = !0) {
                                    var s = a.value;
                                    s.element.modelIsVisible && null == s.externalRenderer && (++e, t = s.canvas)
                                }
                            } catch (e) {
                                r = !0, i = e
                            } finally {
                                try {
                                    n || null == o.return || o.return()
                                } finally {
                                    if (r) throw i
                                }
                            }
                            if (null != t) {
                                var l = e > 1,
                                    u = this.canvas3D;
                                if (l !== this.multipleScenesVisible || !l && u.parentElement !== t.parentElement) {
                                    this.multipleScenesVisible = l, l && u.classList.remove("show");
                                    var c = !0,
                                        h = !1,
                                        d = void 0;
                                    try {
                                        for (var f, p = this.scenes[Symbol.iterator](); !(c = (f = p.next()).done); c = !0) {
                                            var m = f.value;
                                            if (null == m.externalRenderer) {
                                                var v = m.element[he];
                                                l ? (v.classList.add("show"), m.queueRender()) : m.canvas === t && (m.canvas.parentElement.appendChild(u), u.classList.add("show"), v.classList.remove("show"), m.queueRender())
                                            }
                                        }
                                    } catch (e) {
                                        h = !0, d = e
                                    } finally {
                                        try {
                                            c || null == p.return || p.return()
                                        } finally {
                                            if (h) throw d
                                        }
                                    }
                                }
                            }
                        }
                    }, {
                        key: "orderedScenes",
                        value: function() {
                            for (var e = [], t = !0, n = !1, r = void 0, i = 0, a = [!1, !0]; i < a.length; i++) {
                                var o = a[i];
                                try {
                                    for (var s, l = this.scenes[Symbol.iterator](); !(t = (s = l.next()).done); t = !0) {
                                        var u = s.value;
                                        u.element.modelIsVisible === o && e.push(u)
                                    }
                                } catch (e) {
                                    n = !0, r = e
                                } finally {
                                    try {
                                        t || null == l.return || l.return()
                                    } finally {
                                        if (n) throw r
                                    }
                                }
                            }
                            return e
                        }
                    }, {
                        key: "isPresenting",
                        get: function() {
                            return this.arRenderer.isPresenting
                        }
                    }, {
                        key: "preRender",
                        value: function(e, t, n) {
                            var r = e.element,
                                i = e.exposure;
                            r[hr](t, n);
                            var a = "number" == typeof i && !self.isNaN(i);
                            this.threeRenderer.toneMappingExposure = a ? i : 1, e.isShadowDirty() && (this.threeRenderer.shadowMap.needsUpdate = !0)
                        }
                    }, {
                        key: "render",
                        value: function(e, t) {
                            if (null != t) return void this.arRenderer.onWebXRFrame(e, t);
                            var n = e - this.lastTick;
                            if (this.lastTick = e, this.canRender && !this.isPresenting) {
                                this.avgFrameDuration += up(.2 * (n - this.avgFrameDuration), -2, 2), this.selectCanvas(), this.updateRendererSize(), this.updateRendererScale();
                                var r = this.dpr,
                                    i = this.scaleFactor,
                                    a = !0,
                                    o = !1,
                                    s = void 0;
                                try {
                                    for (var l, u = this.orderedScenes()[Symbol.iterator](); !(a = (l = u.next()).done); a = !0) {
                                        var c = l.value,
                                            h = c.element;
                                        if ((h.modelIsVisible || !(c.renderCount > 0)) && (this.preRender(c, e, n), c.shouldRender())) {
                                            if (null != c.externalRenderer) {
                                                var d = c.getCamera();
                                                d.updateMatrix();
                                                var f = d.matrix,
                                                    p = d.projectionMatrix,
                                                    m = f.elements.slice(),
                                                    v = c.getTarget();
                                                m[12] += v.x, m[13] += v.y, m[14] += v.z, c.externalRenderer.render({
                                                    viewMatrix: m,
                                                    projectionMatrix: p.elements
                                                });
                                                continue
                                            }
                                            var g = !0,
                                                y = !1,
                                                _ = void 0;
                                            if (!h.modelIsVisible && !this.multipleScenesVisible) try {
                                                for (var x, b = this.scenes[Symbol.iterator](); !(g = (x = b.next()).done); g = !0) {
                                                    var w = x.value;
                                                    w.element.modelIsVisible && w.queueRender()
                                                }
                                            } catch (e) {
                                                y = !0, _ = e
                                            } finally {
                                                try {
                                                    g || null == b.return || b.return()
                                                } finally {
                                                    if (y) throw _
                                                }
                                            }
                                            var M = Math.min(Math.ceil(c.width * i * r), this.canvas3D.width),
                                                S = Math.min(Math.ceil(c.height * i * r), this.canvas3D.height);
                                            if (this.threeRenderer.setRenderTarget(null), this.threeRenderer.setViewport(0, Math.floor(this.height * r) - S, M, S), this.threeRenderer.render(c, c.camera), this.multipleScenesVisible) {
                                                null == c.context && c.createContext();
                                                var T = c.context;
                                                T.clearRect(0, 0, M, S), T.drawImage(this.canvas3D, 0, 0, M, S, 0, 0, M, S)
                                            }
                                            c.hasRendered(), h.loaded && ++c.renderCount
                                        }
                                    }
                                } catch (e) {
                                    o = !0, s = e
                                } finally {
                                    try {
                                        a || null == u.return || u.return()
                                    } finally {
                                        if (o) throw s
                                    }
                                }
                            }
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            null != this.textureUtils && this.textureUtils.dispose(), null != this.threeRenderer && this.threeRenderer.dispose(), this.textureUtils = null, this.threeRenderer = null;
                            var e = [],
                                t = !0,
                                n = !1,
                                r = void 0;
                            try {
                                for (var i, a = this.scenes[Symbol.iterator](); !(t = (i = a.next()).done); t = !0) {
                                    var o = i.value;
                                    e.push(o.element)
                                }
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == a.return || a.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                            return this.canvas3D.removeEventListener("webglcontextlost", this.onWebGLContextLost), this.canvas3D.removeEventListener("webglcontextrestored", this.onWebGLContextRestored), e
                        }
                    }], [{
                        key: "singleton",
                        get: function() {
                            return this._singleton
                        }
                    }, {
                        key: "resetSingleton",
                        value: function() {
                            var e = this._singleton.dispose(),
                                n = !0,
                                r = !1,
                                i = void 0;
                            try {
                                for (var a, o = e[Symbol.iterator](); !(n = (a = o.next()).done); n = !0) a.value.disconnectedCallback()
                            } catch (e) {
                                r = !0, i = e
                            } finally {
                                try {
                                    n || null == o.return || o.return()
                                } finally {
                                    if (r) throw i
                                }
                            }
                            this._singleton = new t({
                                powerPreference: (self.ModelViewerElement || {}).powerPreference || "high-performance",
                                debug: uv()
                            });
                            var s = !0,
                                l = !1,
                                u = void 0;
                            try {
                                for (var c, h = e[Symbol.iterator](); !(s = (c = h.next()).done); s = !0) c.value.connectedCallback()
                            } catch (e) {
                                l = !0, u = e
                            } finally {
                                try {
                                    s || null == h.return || h.return()
                                } finally {
                                    if (l) throw u
                                }
                            }
                        }
                    }]), t
                }(eW);
            cM._singleton = new cM({
                powerPreference: (self.ModelViewerElement || {}).powerPreference || "high-performance",
                debug: uv()
            });
            var cS, cT, cE, ck, cA, cR, cC, cL, cP, cI, cD, cO, cN, cF, cU, cB, cz, cH, cV, cG, cW, cj = function(e) {
                    function t() {
                        var e;
                        return (0, k._)(this, t), e = (0, E._)(this, t, arguments), e.ongoingActivities = new Set, e.totalProgress = 0, e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "ongoingActivityCount",
                        get: function() {
                            return this.ongoingActivities.size
                        }
                    }, {
                        key: "beginActivity",
                        value: function() {
                            var e = this,
                                t = {
                                    progress: 0,
                                    completed: !1
                                };
                            return this.ongoingActivities.add(t), 1 === this.ongoingActivityCount && this.announceTotalProgress(t, 0),
                                function(n) {
                                    var r;
                                    return (r = Math.max(up(n, 0, 1), t.progress)) !== t.progress && e.announceTotalProgress(t, r), t.progress
                                }
                        }
                    }, {
                        key: "announceTotalProgress",
                        value: function(e, t) {
                            var n = 0,
                                r = 0;
                            1 == t && (e.completed = !0);
                            var i = !0,
                                a = !1,
                                o = void 0;
                            try {
                                for (var s, l = this.ongoingActivities[Symbol.iterator](); !(i = (s = l.next()).done); i = !0) {
                                    var u = s.value,
                                        c = u.progress;
                                    n += 1 - c, !0 === u.completed && r++
                                }
                            } catch (e) {
                                a = !0, o = e
                            } finally {
                                try {
                                    i || null == l.return || l.return()
                                } finally {
                                    if (a) throw o
                                }
                            }
                            var h = e.progress;
                            e.progress = t, this.totalProgress += (t - h) * (1 - this.totalProgress) / n;
                            var d = r === this.ongoingActivityCount ? 1 : this.totalProgress;
                            this.dispatchEvent(new CustomEvent("progress", {
                                detail: {
                                    totalProgress: d
                                }
                            })), r === this.ongoingActivityCount && (this.totalProgress = 0, this.ongoingActivities.clear())
                        }
                    }]), t
                }((0, B._)(EventTarget)),
                cq = function(e, t, n, r) {
                    for (var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r, s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o);
                    return a > 3 && o && Object.defineProperty(t, n, o), o
                },
                cX = document.createElement("canvas"),
                cY = Symbol("fallbackResizeHandler"),
                cJ = Symbol("defaultAriaLabel"),
                cZ = Symbol("resizeObserver"),
                cK = Symbol("clearModelTimeout"),
                cQ = Symbol("onContextLost"),
                c$ = Symbol("loaded"),
                c0 = Symbol("updateSize"),
                c1 = Symbol("intersectionObserver"),
                c2 = Symbol("isElementInViewport"),
                c3 = Symbol("announceModelVisibility"),
                c4 = Symbol("ariaLabel"),
                c5 = Symbol("loadedTime"),
                c6 = Symbol("updateSource"),
                c8 = Symbol("markLoaded"),
                c7 = Symbol("container"),
                c9 = Symbol("input"),
                he = Symbol("canvas"),
                ht = Symbol("scene"),
                hn = Symbol("needsRender"),
                hr = Symbol("tick"),
                hi = Symbol("onModelLoad"),
                ha = Symbol("onResize"),
                ho = Symbol("renderer"),
                hs = Symbol("progressTracker"),
                hl = Symbol("getLoaded"),
                hu = Symbol("getModelIsVisible"),
                hc = Symbol("shouldAttemptPreload"),
                hh = Symbol("sceneIsReady"),
                hd = Symbol("hasTransitioned"),
                hf = function(e) {
                    return {
                        x: e.x,
                        y: e.y,
                        z: e.z,
                        toString: function() {
                            return "".concat(this.x, "m ").concat(this.y, "m ").concat(this.z, "m")
                        }
                    }
                },
                hp = function(e) {
                    function t() {
                        (0, k._)(this, t), (n = (0, E._)(this, t)).alt = null, n.src = null, n[cO] = !1, n[cN] = !1, n[cF] = 0, n[cU] = null, n[cB] = uf(function() {
                            var e = n.getBoundingClientRect();
                            n[c0](e)
                        }, 50), n[cz] = uf(function(e) {
                            var t = n.modelIsVisible;
                            t !== e && n.dispatchEvent(new CustomEvent("model-visibility", {
                                detail: {
                                    visible: t
                                }
                            }))
                        }, 0), n[cH] = null, n[cV] = null, n[cG] = new cj, n[cW] = function(e) {
                            n.dispatchEvent(new CustomEvent("error", {
                                detail: {
                                    type: "webglcontextlost",
                                    sourceError: e.sourceEvent
                                }
                            }))
                        }, n.attachShadow({
                            mode: "open"
                        });
                        var e, n, r, i, a = n.shadowRoot;
                        if (eE(lo, a), n[c7] = a.querySelector(".container"), n[c9] = a.querySelector(".userInput"), n[he] = a.querySelector("canvas"), n[cJ] = n[c9].getAttribute("aria-label"), n.isConnected) {
                            var o = n.getBoundingClientRect();
                            r = o.width, i = o.height
                        } else r = 300, i = 150;
                        return n[ht] = new uH({
                            canvas: n[he],
                            element: n,
                            width: r,
                            height: i
                        }), n[ht].addEventListener("model-load", (e = (0, T._)(function(e) {
                            return (0, z.YH)(this, function(t) {
                                switch (t.label) {
                                    case 0:
                                        return n[c8](), n[hi](), [4, ug()];
                                    case 1:
                                        return t.sent(), n.dispatchEvent(new CustomEvent("load", {
                                            detail: {
                                                url: e.url
                                            }
                                        })), [2]
                                }
                            })
                        }), function(t) {
                            return e.apply(this, arguments)
                        })), Promise.resolve().then(function() {
                            n[c0](n.getBoundingClientRect())
                        }), s7 && (n[cZ] = new ResizeObserver(function(e) {
                            var t = !0,
                                r = !1,
                                i = void 0;
                            if (!n[ho].isPresenting) try {
                                for (var a, o = e[Symbol.iterator](); !(t = (a = o.next()).done); t = !0) {
                                    var s = a.value;
                                    s.target === n && n[c0](s.contentRect)
                                }
                            } catch (e) {
                                r = !0, i = e
                            } finally {
                                try {
                                    t || null == o.return || o.return()
                                } finally {
                                    if (r) throw i
                                }
                            }
                        })), s9 ? n[c1] = new IntersectionObserver(function(e) {
                            var t = !0,
                                r = !1,
                                i = void 0;
                            try {
                                for (var a, o = e[Symbol.iterator](); !(t = (a = o.next()).done); t = !0) {
                                    var s = a.value;
                                    if (s.target === n) {
                                        var l = n.modelIsVisible;
                                        n[c2] = s.isIntersecting, n[c3](l), n[c2] && !n[hh]() && n[c6]()
                                    }
                                }
                            } catch (e) {
                                r = !0, i = e
                            } finally {
                                try {
                                    t || null == o.return || o.return()
                                } finally {
                                    if (r) throw i
                                }
                            }
                        }, {
                            root: null,
                            rootMargin: "0px",
                            threshold: 0
                        }) : n[c2] = !0, n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "loaded",
                        get: function() {
                            return this[hl]()
                        }
                    }, {
                        key: (cO = c2, cN = c$, cF = c5, cU = cK, cB = cY, cz = c3, cH = cZ, cV = c1, cG = hs, ho),
                        get: function() {
                            return cM.singleton
                        }
                    }, {
                        key: "modelIsVisible",
                        get: function() {
                            return this[hu]()
                        }
                    }, {
                        key: "connectedCallback",
                        value: function() {
                            L((0, C._)(t.prototype), "connectedCallback", this) && L((0, C._)(t.prototype), "connectedCallback", this).call(this), s7 ? this[cZ].observe(this) : self.addEventListener("resize", this[cY]), s9 && this[c1].observe(this);
                            var e = this[ho];
                            e.addEventListener("contextlost", this[cQ]), e.registerScene(this[ht]), null != this[cK] && (self.clearTimeout(this[cK]), this[cK] = null, this.requestUpdate("src", null))
                        }
                    }, {
                        key: "disconnectedCallback",
                        value: function() {
                            var e = this;
                            L((0, C._)(t.prototype), "disconnectedCallback", this) && L((0, C._)(t.prototype), "disconnectedCallback", this).call(this), s7 ? this[cZ].unobserve(this) : self.removeEventListener("resize", this[cY]), s9 && this[c1].unobserve(this);
                            var n = this[ho];
                            n.removeEventListener("contextlost", this[cQ]), n.unregisterScene(this[ht]), this[cK] = self.setTimeout(function() {
                                e[ht].reset()
                            }, 1e3)
                        }
                    }, {
                        key: "updated",
                        value: function(e) {
                            if (L((0, C._)(t.prototype), "updated", this).call(this, e), e.has("src") && (null == this.src ? (this[c$] = !1, this[c5] = 0, this[ht].reset()) : this.src !== this[ht].url && (this[c$] = !1, this[c5] = 0, this[c6]())), e.has("alt")) {
                                var n = null == this.alt ? this[cJ] : this.alt;
                                this[c9].setAttribute("aria-label", n)
                            }
                        }
                    }, {
                        key: "toDataURL",
                        value: function(e, t) {
                            return this[ho].displayCanvas(this[ht]).toDataURL(e, t)
                        }
                    }, {
                        key: "toBlob",
                        value: function(e) {
                            var t = this;
                            return (0, T._)(function() {
                                var n, r, i, a, o, s, l, u, c, h, d, f, p, m, v;
                                return (0, z.YH)(this, function(g) {
                                    n = e ? e.mimeType : void 0, r = e ? e.qualityArgument : void 0, i = e ? e.idealAspect : void 0, o = (a = t[ht]).width, s = a.height, l = a.idealAspect, u = a.aspect, h = (c = t[ho]).dpr, f = o * (d = c.scaleFactor) * h, p = s * d * h, m = 0, v = 0, !0 === i && (l > u ? v = (p - (p = Math.round(f / l))) / 2 : m = (f - (f = Math.round(p * l))) / 2), cX.width = f, cX.height = p;
                                    try {
                                        var y;
                                        return [2, new Promise((y = (0, T._)(function(e, i) {
                                            var a, o;
                                            return (0, z.YH)(this, function(s) {
                                                switch (s.label) {
                                                    case 0:
                                                        if (cX.getContext("2d").drawImage(t[ho].displayCanvas(t[ht]), m, v, f, p, 0, 0, f, p), !(!cX.msToBlob || n && "image/png" !== n)) return [3, 4];
                                                        if (!cX.toBlob) return [3, 1];
                                                        return o = void cX.toBlob(function(t) {
                                                            if (!t) return i(Error("Unable to retrieve canvas blob"));
                                                            e(t)
                                                        }, n, r), [3, 3];
                                                    case 1:
                                                        var l;
                                                        return [4, (l = (0, T._)(function(e) {
                                                            return (0, z.YH)(this, function(t) {
                                                                return [2, new Promise(function(t, n) {
                                                                    var r = e.match(/data:(.*);/);
                                                                    if (!r) return n(Error("".concat(e, " is not a valid data Url")));
                                                                    for (var i = r[1], a = e.replace(/data:image\/\w+;base64,/, ""), o = atob(a), s = [], l = 0; l < o.length; l += 512) {
                                                                        for (var u = o.slice(l, l + 512), c = Array(u.length), h = 0; h < u.length; h++) c[h] = u.charCodeAt(h);
                                                                        var d = new Uint8Array(c);
                                                                        s.push(d)
                                                                    }
                                                                    t(new Blob(s, {
                                                                        type: i
                                                                    }))
                                                                })]
                                                            })
                                                        }), function(e) {
                                                            return l.apply(this, arguments)
                                                        })(cX.toDataURL(n, r))];
                                                    case 2:
                                                        o = e.apply(void 0, [s.sent()]), s.label = 3;
                                                    case 3:
                                                        return a = o, [3, 5];
                                                    case 4:
                                                        a = e(cX.msToBlob()), s.label = 5;
                                                    case 5:
                                                        return [2, a]
                                                }
                                            })
                                        }), function(e, t) {
                                            return y.apply(this, arguments)
                                        }))]
                                    } finally {
                                        t[c0]({
                                            width: o,
                                            height: s
                                        })
                                    }
                                    return [2]
                                })
                            })()
                        }
                    }, {
                        key: "registerRenderer",
                        value: function(e) {
                            this[ht].externalRenderer = e
                        }
                    }, {
                        key: "unregisterRenderer",
                        value: function() {
                            this[ht].externalRenderer = null
                        }
                    }, {
                        key: c4,
                        get: function() {
                            return null == this.alt || "null" === this.alt ? this[cJ] : this.alt
                        }
                    }, {
                        key: hl,
                        value: function() {
                            return this[c$]
                        }
                    }, {
                        key: hu,
                        value: function() {
                            return this.loaded && this[c2]
                        }
                    }, {
                        key: hd,
                        value: function() {
                            return this.modelIsVisible
                        }
                    }, {
                        key: hc,
                        value: function() {
                            return !!this.src && this[c2]
                        }
                    }, {
                        key: hh,
                        value: function() {
                            return this[c$]
                        }
                    }, {
                        key: c0,
                        value: function(e) {
                            var t = e.width,
                                n = e.height;
                            this[c7].style.width = "".concat(t, "px"), this[c7].style.height = "".concat(n, "px"), this[ha]({
                                width: parseFloat(t),
                                height: parseFloat(n)
                            })
                        }
                    }, {
                        key: hr,
                        value: function(e, t) {}
                    }, {
                        key: c8,
                        value: function() {
                            this[c$] || (this[c$] = !0, this[c5] = performance.now())
                        }
                    }, {
                        key: hn,
                        value: function() {
                            this[ht].queueRender()
                        }
                    }, {
                        key: hi,
                        value: function() {}
                    }, {
                        key: ha,
                        value: function(e) {
                            this[ht].setSize(e.width, e.height)
                        }
                    }, {
                        key: (cW = cQ, c6),
                        value: function() {
                            var e = this;
                            return (0, T._)(function() {
                                var t, n, r, i;
                                return (0, z.YH)(this, function(a) {
                                    switch (a.label) {
                                        case 0:
                                            if (e.loaded || !e[hc]()) return [2];
                                            t = e[hs].beginActivity(), n = e.src, a.label = 1;
                                        case 1:
                                            return a.trys.push([1, 3, 4, 5]), [4, e[ht].setSource(n, function(e) {
                                                return t(.95 * e)
                                            })];
                                        case 2:
                                            return a.sent(), r = {
                                                url: n
                                            }, e.dispatchEvent(new CustomEvent("preload", {
                                                detail: r
                                            })), [3, 5];
                                        case 3:
                                            return i = a.sent(), e.dispatchEvent(new CustomEvent("error", {
                                                detail: i
                                            })), [3, 5];
                                        case 4:
                                            return requestAnimationFrame(function() {
                                                requestAnimationFrame(function() {
                                                    t(1)
                                                })
                                            }), [7];
                                        case 5:
                                            return [2]
                                    }
                                })
                            })()
                        }
                    }], [{
                        key: "is",
                        get: function() {
                            return "model-viewer"
                        }
                    }, {
                        key: "modelCacheSize",
                        get: function() {
                            return un[ue].evictionThreshold
                        },
                        set: function(e) {
                            un[ue].evictionThreshold = e
                        }
                    }, {
                        key: "minimumRenderScale",
                        get: function() {
                            return cM.singleton.minScale
                        },
                        set: function(e) {
                            e > 1 && console.warn("<model-viewer> minimumRenderScale has been clamped to a maximum value of 1."), e <= 0 && console.warn("<model-viewer> minimumRenderScale has been clamped to a minimum value of 0.25."), cM.singleton.minScale = e
                        }
                    }]), t
                }(eF);
            cq([eU({
                type: String
            })], hp.prototype, "alt", void 0), cq([eU({
                type: String
            })], hp.prototype, "src", void 0);
            var hm = function(e, t, n, r) {
                    for (var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r, s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o);
                    return a > 3 && o && Object.defineProperty(t, n, o), o
                },
                hv = Symbol("changeAnimation"),
                hg = Symbol("paused"),
                hy = {
                    repetitions: 1 / 0,
                    pingpong: !1
                },
                h_ = Symbol("hotspotMap"),
                hx = Symbol("mutationCallback"),
                hb = Symbol("observer"),
                hw = Symbol("addHotspot"),
                hM = Symbol("removeHotspot"),
                hS = new tF,
                hT = new e5,
                hE = function(e) {
                    return URL.createObjectURL(new Blob([e], {
                        type: "text/javascript"
                    }))
                };
            try {
                URL.revokeObjectURL(hE(""))
            } catch (e) {
                hE = function(e) {
                    return "data:application/javascript;charset=UTF-8," + encodeURI(e)
                }
            }
            var hk = Uint8Array,
                hA = Uint16Array,
                hR = Uint32Array,
                hC = new hk([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
                hL = new hk([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
                hP = new hk([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
                hI = function(e, t) {
                    for (var n = new hA(31), r = 0; r < 31; ++r) n[r] = t += 1 << e[r - 1];
                    var i = new hR(n[30]);
                    for (r = 1; r < 30; ++r)
                        for (var a = n[r]; a < n[r + 1]; ++a) i[a] = a - n[r] << 5 | r;
                    return [n, i]
                },
                hD = hI(hC, 2),
                hO = hD[0],
                hN = hD[1];
            hO[28] = 258, hN[258] = 28;
            for (var hF = hI(hL, 0)[1], hU = new hA(32768), hB = 0; hB < 32768; ++hB) {
                var hz = (43690 & hB) >>> 1 | (21845 & hB) << 1;
                hz = (61680 & (hz = (52428 & hz) >>> 2 | (13107 & hz) << 2)) >>> 4 | (3855 & hz) << 4, hU[hB] = ((65280 & hz) >>> 8 | (255 & hz) << 8) >>> 1
            }
            var hH = function(e, t, n) {
                    for (var r = e.length, i = 0, a = new hA(t); i < r; ++i) ++a[e[i] - 1];
                    var o, s = new hA(t);
                    for (i = 0; i < t; ++i) s[i] = s[i - 1] + a[i - 1] << 1;
                    if (n) {
                        o = new hA(1 << t);
                        var l = 15 - t;
                        for (i = 0; i < r; ++i)
                            if (e[i])
                                for (var u = i << 4 | e[i], c = t - e[i], h = s[e[i] - 1]++ << c, d = h | (1 << c) - 1; h <= d; ++h) o[hU[h] >>> l] = u
                    } else
                        for (o = new hA(r), i = 0; i < r; ++i) e[i] && (o[i] = hU[s[e[i] - 1]++] >>> 15 - e[i]);
                    return o
                },
                hV = new hk(288);
            for (hB = 0; hB < 144; ++hB) hV[hB] = 8;
            for (hB = 144; hB < 256; ++hB) hV[hB] = 9;
            for (hB = 256; hB < 280; ++hB) hV[hB] = 7;
            for (hB = 280; hB < 288; ++hB) hV[hB] = 8;
            var hG = new hk(32);
            for (hB = 0; hB < 32; ++hB) hG[hB] = 5;
            var hW = hH(hV, 9, 0),
                hj = hH(hG, 5, 0),
                hq = function(e) {
                    return (e / 8 | 0) + (7 & e && 1)
                },
                hX = function(e, t, n) {
                    (null == t || t < 0) && (t = 0), (null == n || n > e.length) && (n = e.length);
                    var r = new(e instanceof hA ? hA : e instanceof hR ? hR : hk)(n - t);
                    return r.set(e.subarray(t, n)), r
                },
                hY = function(e, t, n) {
                    n <<= 7 & t;
                    var r = t / 8 | 0;
                    e[r] |= n, e[r + 1] |= n >>> 8
                },
                hJ = function(e, t, n) {
                    n <<= 7 & t;
                    var r = t / 8 | 0;
                    e[r] |= n, e[r + 1] |= n >>> 8, e[r + 2] |= n >>> 16
                },
                hZ = function(e, t) {
                    for (var n = [], r = 0; r < e.length; ++r) e[r] && n.push({
                        s: r,
                        f: e[r]
                    });
                    var i = n.length,
                        a = n.slice();
                    if (!i) return [h3, 0];
                    if (1 == i) {
                        var o = new hk(n[0].s + 1);
                        return o[n[0].s] = 1, [o, 1]
                    }
                    n.sort(function(e, t) {
                        return e.f - t.f
                    }), n.push({
                        s: -1,
                        f: 25001
                    });
                    var s = n[0],
                        l = n[1],
                        u = 0,
                        c = 1,
                        h = 2;
                    for (n[0] = {
                            s: -1,
                            f: s.f + l.f,
                            l: s,
                            r: l
                        }; c != i - 1;) s = n[n[u].f < n[h].f ? u++ : h++], l = n[u != c && n[u].f < n[h].f ? u++ : h++], n[c++] = {
                        s: -1,
                        f: s.f + l.f,
                        l: s,
                        r: l
                    };
                    var d = a[0].s;
                    for (r = 1; r < i; ++r) a[r].s > d && (d = a[r].s);
                    var f = new hA(d + 1),
                        p = hK(n[c - 1], f, 0);
                    if (p > t) {
                        r = 0;
                        var m = 0,
                            v = p - t,
                            g = 1 << v;
                        for (a.sort(function(e, t) {
                                return f[t.s] - f[e.s] || e.f - t.f
                            }); r < i; ++r) {
                            var y = a[r].s;
                            if (!(f[y] > t)) break;
                            m += g - (1 << p - f[y]), f[y] = t
                        }
                        for (m >>>= v; m > 0;) {
                            var _ = a[r].s;
                            f[_] < t ? m -= 1 << t - f[_]++ - 1 : ++r
                        }
                        for (; r >= 0 && m; --r) {
                            var x = a[r].s;
                            f[x] == t && (--f[x], ++m)
                        }
                        p = t
                    }
                    return [new hk(f), p]
                },
                hK = function(e, t, n) {
                    return -1 == e.s ? Math.max(hK(e.l, t, n + 1), hK(e.r, t, n + 1)) : t[e.s] = n
                },
                hQ = function(e) {
                    for (var t = e.length; t && !e[--t];);
                    for (var n = new hA(++t), r = 0, i = e[0], a = 1, o = function(e) {
                            n[r++] = e
                        }, s = 1; s <= t; ++s)
                        if (e[s] == i && s != t) ++a;
                        else {
                            if (!i && a > 2) {
                                for (; a > 138; a -= 138) o(32754);
                                a > 2 && (o(a > 10 ? a - 11 << 5 | 28690 : a - 3 << 5 | 12305), a = 0)
                            } else if (a > 3) {
                                for (o(i), --a; a > 6; a -= 6) o(8304);
                                a > 2 && (o(a - 3 << 5 | 8208), a = 0)
                            }
                            for (; a--;) o(i);
                            a = 1, i = e[s]
                        }
                    return [n.subarray(0, r), t]
                },
                h$ = function(e, t) {
                    for (var n = 0, r = 0; r < t.length; ++r) n += e[r] * t[r];
                    return n
                },
                h0 = function(e, t, n) {
                    var r = n.length,
                        i = hq(t + 2);
                    e[i] = 255 & r, e[i + 1] = r >>> 8, e[i + 2] = 255 ^ e[i], e[i + 3] = 255 ^ e[i + 1];
                    for (var a = 0; a < r; ++a) e[i + a + 4] = n[a];
                    return 8 * (i + 4 + r)
                },
                h1 = function(e, t, n, r, i, a, o, s, l, u, c) {
                    hY(t, c++, n), ++i[256];
                    for (var h = hZ(i, 15), d = h[0], f = h[1], p = hZ(a, 15), m = p[0], v = p[1], g = hQ(d), y = g[0], _ = g[1], x = hQ(m), b = x[0], w = x[1], M = new hA(19), S = 0; S < y.length; ++S) M[31 & y[S]]++;
                    for (S = 0; S < b.length; ++S) M[31 & b[S]]++;
                    for (var T = hZ(M, 7), E = T[0], k = T[1], A = 19; A > 4 && !E[hP[A - 1]]; --A);
                    var R, C, L, P, I = u + 5 << 3,
                        D = h$(i, hV) + h$(a, hG) + o,
                        O = h$(i, d) + h$(a, m) + o + 14 + 3 * A + h$(M, E) + (2 * M[16] + 3 * M[17] + 7 * M[18]);
                    if (I <= D && I <= O) return h0(t, c, e.subarray(l, l + u));
                    if (hY(t, c, 1 + (O < D)), c += 2, O < D) {
                        R = hH(d, f, 0), C = d, L = hH(m, v, 0), P = m;
                        var N = hH(E, k, 0);
                        for (hY(t, c, _ - 257), hY(t, c + 5, w - 1), hY(t, c + 10, A - 4), c += 14, S = 0; S < A; ++S) hY(t, c + 3 * S, E[hP[S]]);
                        c += 3 * A;
                        for (var F = [y, b], U = 0; U < 2; ++U) {
                            var B = F[U];
                            for (S = 0; S < B.length; ++S) {
                                var z = 31 & B[S];
                                hY(t, c, N[z]), c += E[z], z > 15 && (hY(t, c, B[S] >>> 5 & 127), c += B[S] >>> 12)
                            }
                        }
                    } else R = hW, C = hV, L = hj, P = hG;
                    for (S = 0; S < s; ++S)
                        if (r[S] > 255) {
                            hJ(t, c, R[(z = r[S] >>> 18 & 31) + 257]), c += C[z + 257], z > 7 && (hY(t, c, r[S] >>> 23 & 31), c += hC[z]);
                            var H = 31 & r[S];
                            hJ(t, c, L[H]), c += P[H], H > 3 && (hJ(t, c, r[S] >>> 5 & 8191), c += hL[H])
                        } else hJ(t, c, R[r[S]]), c += C[r[S]];
                    return hJ(t, c, R[256]), c + C[256]
                },
                h2 = new hR([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
                h3 = new hk(0),
                h4 = function() {
                    for (var e = new hR(256), t = 0; t < 256; ++t) {
                        for (var n = t, r = 9; --r;) n = (1 & n && 0xedb88320) ^ n >>> 1;
                        e[t] = n
                    }
                    return e
                }(),
                h5 = function() {
                    var e = -1;
                    return {
                        p: function(t) {
                            for (var n = e, r = 0; r < t.length; ++r) n = h4[255 & n ^ t[r]] ^ n >>> 8;
                            e = n
                        },
                        d: function() {
                            return ~e
                        }
                    }
                },
                h6 = function(e, t) {
                    var n = {};
                    for (var r in e) n[r] = e[r];
                    for (var r in t) n[r] = t[r];
                    return n
                },
                h8 = function(e, t, n) {
                    for (; n; ++t) e[t] = n, n >>>= 8
                },
                h7 = function(e, t, n, r) {
                    for (var i in e) {
                        var a = e[i],
                            o = t + i;
                        a instanceof hk ? n[o] = [a, r] : Array.isArray(a) ? n[o] = [a[0], h6(r, a[1])] : h7(a, o + "/", n, r)
                    }
                },
                h9 = "undefined" != typeof TextEncoder && new TextEncoder,
                de = "undefined" != typeof TextDecoder && new TextDecoder;
            try {
                de.decode(h3, {
                    stream: !0
                })
            } catch (e) {}

            function dt(e, t) {
                if (t) {
                    for (var n = new hk(e.length), r = 0; r < e.length; ++r) n[r] = e.charCodeAt(r);
                    return n
                }
                if (h9) return h9.encode(e);
                var i = e.length,
                    a = new hk(e.length + (e.length >> 1)),
                    o = 0,
                    s = function(e) {
                        a[o++] = e
                    };
                for (r = 0; r < i; ++r) {
                    if (o + 5 > a.length) {
                        var l = new hk(o + 8 + (i - r << 1));
                        l.set(a), a = l
                    }
                    var u = e.charCodeAt(r);
                    u < 128 || t ? s(u) : (u < 2048 ? s(192 | u >> 6) : (u > 55295 && u < 57344 ? (s(240 | (u = 65536 + (1047552 & u) | 1023 & e.charCodeAt(++r)) >> 18), s(128 | u >> 12 & 63)) : s(224 | u >> 12), s(128 | u >> 6 & 63)), s(128 | 63 & u))
                }
                return hX(a, 0, o)
            }
            var dn = function(e) {
                    var t = 0;
                    if (e)
                        for (var n in e) {
                            var r = e[n].length;
                            if (r > 65535) throw "extra field too long";
                            t += r + 4
                        }
                    return t
                },
                dr = function(e, t, n, r, i, a, o, s) {
                    var l = r.length,
                        u = n.extra,
                        c = s && s.length,
                        h = dn(u);
                    h8(e, t, null != o ? 0x2014b50 : 0x4034b50), t += 4, null != o && (e[t++] = 20, e[t++] = n.os), e[t] = 20, t += 2, e[t++] = n.flag << 1 | (null == a && 8), e[t++] = i && 8, e[t++] = 255 & n.compression, e[t++] = n.compression >> 8;
                    var d = new Date(null == n.mtime ? Date.now() : n.mtime),
                        f = d.getFullYear() - 1980;
                    if (f < 0 || f > 119) throw "date not in range 1980-2099";
                    if (h8(e, t, f << 25 | d.getMonth() + 1 << 21 | d.getDate() << 16 | d.getHours() << 11 | d.getMinutes() << 5 | d.getSeconds() >>> 1), t += 4, null != a && (h8(e, t, n.crc), h8(e, t + 4, a), h8(e, t + 8, n.size)), h8(e, t + 12, l), h8(e, t + 14, h), t += 16, null != o && (h8(e, t, c), h8(e, t + 6, n.attrs), h8(e, t + 10, o), t += 14), e.set(r, t), t += l, h)
                        for (var p in u) {
                            var m = u[p],
                                v = m.length;
                            h8(e, t, +p), h8(e, t + 2, v), e.set(m, t + 4), t += 4 + v
                        }
                    return c && (e.set(s, t), t += c), t
                },
                di = function() {
                    function e() {
                        (0, k._)(this, e)
                    }
                    return (0, A._)(e, [{
                        key: "parse",
                        value: function(e) {
                            return (0, T._)(function() {
                                var t, n, r, i, a, o, s, l, u, c, h, d, f;
                                return (0, z.YH)(this, function(p) {
                                    switch (p.label) {
                                        case 0:
                                            for (s in t = function(e) {
                                                    var t, r, i, o, s, l, u;
                                                    return (0, z.YH)(this, function(c) {
                                                        switch (c.label) {
                                                            case 0:
                                                                return t = a[e], r = e.split("_")[1], i = 1023 === t.format, o = function(e, t) {
                                                                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                                                                        var n = 1024 / Math.max(e.width, e.height),
                                                                            r = document.createElement("canvas");
                                                                        r.width = e.width * Math.min(1, n), r.height = e.height * Math.min(1, n);
                                                                        var i = r.getContext("2d");
                                                                        if (i.drawImage(e, 0, 0, r.width, r.height), void 0 !== t) {
                                                                            for (var a = parseInt(t, 16), o = (a >> 16 & 255) / 255, s = (a >> 8 & 255) / 255, l = (255 & a) / 255, u = i.getImageData(0, 0, r.width, r.height), c = u.data, h = 0; h < c.length; h += 4) c[h + 0] = c[h + 0] * o, c[h + 1] = c[h + 1] * s, c[h + 2] = c[h + 2] * l;
                                                                            i.putImageData(u, 0, 0)
                                                                        }
                                                                        return r
                                                                    }
                                                                }(t.image, r), [4, new Promise(function(e) {
                                                                    return o.toBlob(e, i ? "image/png" : "image/jpeg", 1)
                                                                })];
                                                            case 1:
                                                                return s = c.sent(), l = "textures/Texture_".concat(e, ".").concat(i ? "png" : "jpg"), u = Uint8Array.bind, [4, s.arrayBuffer()];
                                                            case 2:
                                                                return n[l] = new(u.apply(Uint8Array, [void 0, c.sent()])), [2]
                                                        }
                                                    })
                                                }, (n = {})["model.usda"] = null, r = da(), i = {}, a = {}, e.traverseVisible(function(e) {
                                                    if (e.isMesh) {
                                                        if (e.material.isMeshStandardMaterial) {
                                                            var t, a, o, s, l, u, c = e.geometry,
                                                                h = e.material,
                                                                d = "geometries/Geometry_" + c.id + ".usd";
                                                            if (!(d in n)) {
                                                                var f, p, m, v, g, y, _ = (f = c, '\ndef "Geometry"\n{\n  '.concat((v = (m = (p = f).attributes).position.count, '\n    def Mesh "'.concat("Geometry", '"\n    {\n        int[] faceVertexCounts = [').concat(Array((null !== (g = p).index ? g.index.count : g.attributes.position.count) / 3).fill(3).join(", "), "]\n        int[] faceVertexIndices = [").concat(function(e) {
                                                                    var t = e.index,
                                                                        n = [];
                                                                    if (null !== t)
                                                                        for (var r = 0; r < t.count; r++) n.push(t.getX(r));
                                                                    else
                                                                        for (var i = e.attributes.position.count, a = 0; a < i; a++) n.push(a);
                                                                    return n.join(", ")
                                                                }(p), "]\n        normal3f[] normals = [").concat(dl(m.normal, v), '] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [').concat(dl(m.position, v), "]\n        float2[] primvars:st = [").concat(function(e, t) {
                                                                    if (void 0 === e) return console.warn("USDZExporter: UVs missing."), Array(t).fill("(0, 0)").join(", ");
                                                                    for (var n = [], r = 0; r < e.count; r++) {
                                                                        var i = e.getX(r),
                                                                            a = e.getY(r);
                                                                        n.push("(".concat(i.toPrecision(7), ", ").concat(1 - a.toPrecision(7), ")"))
                                                                    }
                                                                    return n.join(", ")
                                                                }(m.uv, v), '] (\n            interpolation = "vertex"\n        )\n        uniform token subdivisionScheme = "none"\n    }\n')), "\n}\n"));
                                                                n[d] = (y = _, dt(da() + y))
                                                            }
                                                            h.uuid in i || (i[h.uuid] = h), r += (t = e, a = c, o = h, l = "Object_" + t.id, s = t.matrixWorld.elements, u = "( ".concat(ds(s, 0), ", ").concat(ds(s, 4), ", ").concat(ds(s, 8), ", ").concat(ds(s, 12), " )"), 0 > t.matrixWorld.determinant() && console.warn("THREE.USDZExporter: USDZ does not support negative scales", t), 'def Xform "'.concat(l, '" (\n    prepend references = @./geometries/Geometry_').concat(a.id, ".usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ").concat(u, '\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    rel material:binding = </Materials/Material_').concat(o.id, ">\n}\n\n"))
                                                        } else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)", e)
                                                    }
                                                }), r += function(e, t) {
                                                    var n = [];
                                                    for (var r in e) {
                                                        var i = e[r];
                                                        n.push(function(e, t) {
                                                            var n = "            ",
                                                                r = [],
                                                                i = [];

                                                            function a(n, r, i) {
                                                                var a = n.id + (i ? "_" + i.getHexString() : ""),
                                                                    o = 1023 === n.format;
                                                                return t[a] = n, '\n        def Shader "Transform2d_'.concat(r, '" (\n            sdrMetadata = {\n                string role = "math"\n            }\n        )\n        {\n            uniform token info:id = "UsdTransform2d"\n            float2 inputs:in.connect = </Materials/Material_').concat(e.id, "/uvReader_st.outputs:result>\n            float2 inputs:scale = ").concat(dc(n.repeat), "\n            float2 inputs:translation = ").concat(dc(n.offset), '\n            float2 outputs:result\n        }\n\n        def Shader "Texture_').concat(n.id, "_").concat(r, '"\n        {\n            uniform token info:id = "UsdUVTexture"\n            asset inputs:file = @textures/Texture_').concat(a, ".").concat(o ? "png" : "jpg", "@\n            float2 inputs:st.connect = </Materials/Material_").concat(e.id, "/Transform2d_").concat(r, '.outputs:result>\n            token inputs:wrapS = "repeat"\n            token inputs:wrapT = "repeat"\n            float outputs:r\n            float outputs:g\n            float outputs:b\n            float3 outputs:rgb\n        }')
                                                            }
                                                            return null !== e.map ? (r.push("".concat(n, "color3f inputs:diffuseColor.connect = </Materials/Material_").concat(e.id, "/Texture_").concat(e.map.id, "_diffuse.outputs:rgb>")), i.push(a(e.map, "diffuse", e.color))) : r.push("".concat(n, "color3f inputs:diffuseColor = ").concat(du(e.color))), null !== e.emissiveMap ? (r.push("".concat(n, "color3f inputs:emissiveColor.connect = </Materials/Material_").concat(e.id, "/Texture_").concat(e.emissiveMap.id, "_emissive.outputs:rgb>")), i.push(a(e.emissiveMap, "emissive"))) : e.emissive.getHex() > 0 && r.push("".concat(n, "color3f inputs:emissiveColor = ").concat(du(e.emissive))), null !== e.normalMap && (r.push("".concat(n, "normal3f inputs:normal.connect = </Materials/Material_").concat(e.id, "/Texture_").concat(e.normalMap.id, "_normal.outputs:rgb>")), i.push(a(e.normalMap, "normal"))), null !== e.aoMap && (r.push("".concat(n, "float inputs:occlusion.connect = </Materials/Material_").concat(e.id, "/Texture_").concat(e.aoMap.id, "_occlusion.outputs:r>")), i.push(a(e.aoMap, "occlusion"))), null !== e.roughnessMap && 1 === e.roughness ? (r.push("".concat(n, "float inputs:roughness.connect = </Materials/Material_").concat(e.id, "/Texture_").concat(e.roughnessMap.id, "_roughness.outputs:g>")), i.push(a(e.roughnessMap, "roughness"))) : r.push("".concat(n, "float inputs:roughness = ").concat(e.roughness)), null !== e.metalnessMap && 1 === e.metalness ? (r.push("".concat(n, "float inputs:metallic.connect = </Materials/Material_").concat(e.id, "/Texture_").concat(e.metalnessMap.id, "_metallic.outputs:b>")), i.push(a(e.metalnessMap, "metallic"))) : r.push("".concat(n, "float inputs:metallic = ").concat(e.metalness)), null !== e.alphaMap ? (r.push("".concat(n, "float inputs:opacity.connect = </Materials/Material_").concat(e.id, "/Texture_").concat(e.alphaMap.id, "_opacity.outputs:r>")), r.push("".concat(n, "float inputs:opacityThreshold = 0.0001")), i.push(a(e.alphaMap, "opacity"))) : r.push("".concat(n, "float inputs:opacity = ").concat(e.opacity)), e.isMeshPhysicalMaterial && (r.push("".concat(n, "float inputs:clearcoat = ").concat(e.clearcoat)), r.push("".concat(n, "float inputs:clearcoatRoughness = ").concat(e.clearcoatRoughness)), r.push("".concat(n, "float inputs:ior = ").concat(e.ior))), '\n    def Material "Material_'.concat(e.id, '"\n    {\n        def Shader "PreviewSurface"\n        {\n            uniform token info:id = "UsdPreviewSurface"\n').concat(r.join("\n"), "\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n\n        token outputs:surface.connect = </Materials/Material_").concat(e.id, '/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = "st"\n\n        def Shader "uvReader_st"\n        {\n            uniform token info:id = "UsdPrimvarReader_float2"\n            token inputs:varname.connect = </Materials/Material_').concat(e.id, ".inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n\n").concat(i.join("\n"), "\n\n    }\n")
                                                        }(i, t))
                                                    }
                                                    return 'def "Materials"\n{\n'.concat(n.join(""), "\n}\n\n")
                                                }(i, a), n["model.usda"] = dt(r), r = null, o = [], a) o.push(s);
                                            l = 0, p.label = 1;
                                        case 1:
                                            if (!(l < o.length)) return [3, 4];
                                            return u = o[l], [5, (0, z.Ju)(t(u))];
                                        case 2:
                                            p.sent(), p.label = 3;
                                        case 3:
                                            return l++, [3, 1];
                                        case 4:
                                            for (var m in c = 0, n) h = n[m], c += 34 + m.length, 4 != (d = 63 & c) && (f = new Uint8Array(64 - d), n[m] = [h, {
                                                extra: {
                                                    12345: f
                                                }
                                            }]), c = h.length;
                                            return [2, function(e, t) {
                                                t || (t = {});
                                                var n, r, i = {},
                                                    a = [];
                                                h7(e, "", i, t);
                                                var o = 0,
                                                    s = 0;
                                                for (var l in i) {
                                                    var u = i[l],
                                                        c = u[0],
                                                        h = u[1],
                                                        d = 0 == h.level ? 0 : 8,
                                                        f = (T = dt(l)).length,
                                                        p = h.comment,
                                                        m = p && dt(p),
                                                        v = m && m.length,
                                                        g = dn(h.extra);
                                                    if (f > 65535) throw "filename too long";
                                                    var y = d ? function(e, t) {
                                                            var n;
                                                            return function(e, t, n, r, i, a) {
                                                                var o = e.length,
                                                                    s = new hk(0 + o + 5 * (1 + Math.ceil(o / 7e3)) + 0),
                                                                    l = s.subarray(0, s.length - 0),
                                                                    u = 0;
                                                                if (!t || o < 8)
                                                                    for (var c = 0; c <= o; c += 65535) {
                                                                        var h = c + 65535;
                                                                        h < o ? u = h0(l, u, e.subarray(c, h)) : (l[c] = a, u = h0(l, u, e.subarray(c, o)))
                                                                    } else {
                                                                        for (var d = h2[t - 1], f = d >>> 13, p = 8191 & d, m = (1 << n) - 1, v = new hA(32768), g = new hA(m + 1), y = Math.ceil(n / 3), _ = 2 * y, x = function(t) {
                                                                                return (e[t] ^ e[t + 1] << y ^ e[t + 2] << _) & m
                                                                            }, b = new hR(25e3), w = new hA(288), M = new hA(32), S = 0, T = 0, E = (c = 0, 0), k = 0, A = 0; c < o; ++c) {
                                                                            var R = x(c),
                                                                                C = 32767 & c,
                                                                                L = g[R];
                                                                            if (v[C] = L, g[R] = C, k <= c) {
                                                                                var P = o - c;
                                                                                if ((S > 7e3 || E > 24576) && P > 423) {
                                                                                    u = h1(e, l, 0, b, w, M, T, E, A, c - A, u), E = S = T = 0, A = c;
                                                                                    for (var I = 0; I < 286; ++I) w[I] = 0;
                                                                                    for (I = 0; I < 30; ++I) M[I] = 0
                                                                                }
                                                                                var D = 2,
                                                                                    O = 0,
                                                                                    N = p,
                                                                                    F = C - L & 32767;
                                                                                if (P > 2 && R == x(c - F))
                                                                                    for (var U = Math.min(f, P) - 1, B = Math.min(32767, c), z = Math.min(258, P); F <= B && --N && C != L;) {
                                                                                        if (e[c + D] == e[c + D - F]) {
                                                                                            for (var H = 0; H < z && e[c + H] == e[c + H - F]; ++H);
                                                                                            if (H > D) {
                                                                                                if (D = H, O = F, H > U) break;
                                                                                                var V = Math.min(F, H - 2),
                                                                                                    G = 0;
                                                                                                for (I = 0; I < V; ++I) {
                                                                                                    var W = c - F + I + 32768 & 32767,
                                                                                                        j = W - v[W] + 32768 & 32767;
                                                                                                    j > G && (G = j, L = W)
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        F += (C = L) - (L = v[C]) + 32768 & 32767
                                                                                    }
                                                                                if (O) {
                                                                                    b[E++] = 0x10000000 | hN[D] << 18 | hF[O];
                                                                                    var q = 31 & hN[D],
                                                                                        X = 31 & hF[O];
                                                                                    T += hC[q] + hL[X], ++w[257 + q], ++M[X], k = c + D, ++S
                                                                                } else b[E++] = e[c], ++w[e[c]]
                                                                            }
                                                                        }
                                                                        u = h1(e, l, a, b, w, M, T, E, A, c - A, u), !a && 7 & u && (u = h0(l, u + 1, h3))
                                                                    }
                                                                return hX(s, 0, r + hq(u) + i)
                                                            }(e, null == (n = t || {}).level ? 6 : n.level, null == n.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + n.mem, 0, 0, !0)
                                                        }(c, h) : c,
                                                        _ = y.length,
                                                        x = h5();
                                                    x.p(c), a.push(h6(h, {
                                                        size: c.length,
                                                        crc: x.d(),
                                                        c: y,
                                                        f: T,
                                                        m: m,
                                                        u: f != l.length || m && p.length != v,
                                                        o: o,
                                                        compression: d
                                                    })), o += 30 + f + g + _, s += 76 + 2 * (f + g) + (v || 0) + _
                                                }
                                                for (var b = new hk(s + 22), w = o, M = s - o, S = 0; S < a.length; ++S) {
                                                    var T = a[S];
                                                    dr(b, T.o, T, T.f, T.u, T.c.length);
                                                    var E = 30 + T.f.length + dn(T.extra);
                                                    b.set(T.c, T.o + E), dr(b, o, T, T.f, T.u, T.c.length, T.o, T.m), o += 16 + E + (T.m ? T.m.length : 0)
                                                }
                                                return n = o, r = a.length, h8(b, n, 0x6054b50), h8(b, n + 8, r), h8(b, n + 10, r), h8(b, n + 12, M), h8(b, n + 16, w), b
                                            }(n, {
                                                level: 0
                                            })]
                                    }
                                })
                            })()
                        }
                    }]), e
                }();

            function da() {
                return '#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n'
            }

            function ds(e, t) {
                return "(".concat(e[t + 0], ", ").concat(e[t + 1], ", ").concat(e[t + 2], ", ").concat(e[t + 3], ")")
            }

            function dl(e, t) {
                if (void 0 === e) return console.warn("USDZExporter: Normals missing."), Array(t).fill("(0, 0, 0)").join(", ");
                for (var n = [], r = 0; r < e.count; r++) {
                    var i = e.getX(r),
                        a = e.getY(r),
                        o = e.getZ(r);
                    n.push("(".concat(i.toPrecision(7), ", ").concat(a.toPrecision(7), ", ").concat(o.toPrecision(7), ")"))
                }
                return n.join(", ")
            }

            function du(e) {
                return "(".concat(e.r, ", ").concat(e.g, ", ").concat(e.b, ")")
            }

            function dc(e) {
                return "(".concat(e.x, ", ").concat(e.y, ")")
            }
            var dh = function(e, t, n, r) {
                    for (var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r, s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o);
                    return a > 3 && o && Object.defineProperty(t, n, o), o
                },
                dd = !1,
                df = !1,
                dp = (r = ["quick-look", "scene-viewer", "webxr", "none"], function(e) {
                    try {
                        var t = ux(e),
                            n = (t.length ? t[0].terms : []).filter(function(e) {
                                return e && "ident" === e.type
                            }).map(function(e) {
                                return e.value
                            }).filter(function(e) {
                                return r.indexOf(e) > -1
                            }),
                            i = new Set,
                            a = !0,
                            o = !1,
                            s = void 0;
                        try {
                            for (var l, u = n[Symbol.iterator](); !(a = (l = u.next()).done); a = !0) {
                                var c = l.value;
                                i.add(c)
                            }
                        } catch (e) {
                            o = !0, s = e
                        } finally {
                            try {
                                a || null == u.return || u.return()
                            } finally {
                                if (o) throw s
                            }
                        }
                        return i
                    } catch (e) {}
                    return new Set
                }),
                dm = "quick-look",
                dv = "scene-viewer",
                dg = "webxr",
                dy = "none",
                d_ = Symbol("arButtonContainer"),
                dx = Symbol("enterARWithWebXR"),
                db = Symbol("openSceneViewer"),
                dw = Symbol("openIOSARQuickLook"),
                dM = Symbol("canActivateAR"),
                dS = Symbol("arMode"),
                dT = Symbol("arModes"),
                dE = Symbol("arAnchor"),
                dk = Symbol("preload"),
                dA = Symbol("onARButtonContainerClick"),
                dR = Symbol("onARStatus"),
                dC = Symbol("onARTracking"),
                dL = Symbol("onARTap"),
                dP = Symbol("selectARMode"),
                dI = Symbol("triggerLoad"),
                dD = Symbol("evaluate"),
                dO = Symbol("lastValue"),
                dN = function() {
                    function e() {
                        (0, k._)(this, e), this[i] = null
                    }
                    return (0, A._)(e, [{
                        key: "isConstant",
                        get: function() {
                            return !1
                        }
                    }, {
                        key: "evaluate",
                        value: function() {
                            return this.isConstant && null != this[dO] || (this[dO] = this[dD]()), this[dO]
                        }
                    }], [{
                        key: "evaluatableFor",
                        value: function(t) {
                            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : uA;
                            if (t instanceof e) return t;
                            if ("number" === t.type) return "%" === t.unit ? new dB(t, n) : t;
                            switch (t.name.value) {
                                case "calc":
                                    return new dW(t, n);
                                case "env":
                                    return new dH(t)
                            }
                            return uA
                        }
                    }, {
                        key: "evaluate",
                        value: function(t) {
                            return t instanceof e ? t.evaluate() : t
                        }
                    }, {
                        key: "isConstant",
                        value: function(t) {
                            return !(t instanceof e) || t.isConstant
                        }
                    }, {
                        key: "applyIntrinsics",
                        value: function(e, t) {
                            var n = t.basis,
                                r = t.keywords,
                                i = r.auto;
                            return n.map(function(t, n) {
                                var a = null == i[n] ? t : i[n],
                                    o = e[n] ? e[n] : a;
                                if ("ident" === o.type) {
                                    var s = o.value;
                                    s in r && (o = r[s][n])
                                }
                                return null != o && "ident" !== o.type || (o = a), "%" === o.unit ? u_(o.number / 100 * t.number, t.unit) : (o = uL(o, t)).unit !== t.unit ? t : o
                            })
                        }
                    }]), e
                }();
            i = dO;
            var dF = Symbol("percentage"),
                dU = Symbol("basis"),
                dB = function(e) {
                    function t(e, n) {
                        var r;
                        return (0, k._)(this, t), (r = (0, E._)(this, t))[dF] = e, r[dU] = n, r
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "isConstant",
                        get: function() {
                            return !0
                        }
                    }, {
                        key: dD,
                        value: function() {
                            return u_(this[dF].number / 100 * this[dU].number, this[dU].unit)
                        }
                    }]), t
                }(dN),
                dz = Symbol("identNode"),
                dH = function(e) {
                    function t(e) {
                        (0, k._)(this, t), (n = (0, E._)(this, t))[a] = null;
                        var n, r = e.arguments.length ? e.arguments[0].terms[0] : null;
                        return null != r && "ident" === r.type && (n[dz] = r), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "isConstant",
                        get: function() {
                            return !1
                        }
                    }, {
                        key: (a = dz, dD),
                        value: function() {
                            return null != this[dz] && "window-scroll-y" === this[dz].value ? {
                                type: "number",
                                number: window.pageYOffset / (Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) - window.innerHeight) || 0,
                                unit: null
                            } : uA
                        }
                    }]), t
                }(dN),
                dV = /[\*\/]/,
                dG = Symbol("evalutor"),
                dW = function(e) {
                    function t(e) {
                        var n, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : uA;
                        if ((0, k._)(this, t), (n = (0, E._)(this, t))[o] = null, 1 !== e.arguments.length) return (0, D._)(n);
                        for (var i = e.arguments[0].terms.slice(), a = []; i.length;) {
                            var s = i.shift();
                            if (a.length > 0) {
                                var l = a[a.length - 1];
                                if ("operator" === l.type && dV.test(l.value)) {
                                    var u = a.pop(),
                                        c = a.pop();
                                    if (null == c) return (0, D._)(n);
                                    a.push(new dY(u, dN.evaluatableFor(c, r), dN.evaluatableFor(s, r)));
                                    continue
                                }
                            }
                            a.push("operator" === s.type ? s : dN.evaluatableFor(s, r))
                        }
                        for (; a.length > 2;) {
                            var h = (0, O._)(a.splice(0, 3), 3),
                                d = h[0],
                                f = h[1],
                                p = h[2];
                            if ("operator" !== f.type) return (0, D._)(n);
                            a.unshift(new dY(f, dN.evaluatableFor(d, r), dN.evaluatableFor(p, r)))
                        }
                        return 1 === a.length && (n[dG] = a[0]), n
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "isConstant",
                        get: function() {
                            return null == this[dG] || dN.isConstant(this[dG])
                        }
                    }, {
                        key: (o = dG, dD),
                        value: function() {
                            return null != this[dG] ? dN.evaluate(this[dG]) : uA
                        }
                    }]), t
                }(dN),
                dj = Symbol("operator"),
                dq = Symbol("left"),
                dX = Symbol("right"),
                dY = function(e) {
                    function t(e, n, r) {
                        var i;
                        return (0, k._)(this, t), (i = (0, E._)(this, t))[dj] = e, i[dq] = n, i[dX] = r, i
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "isConstant",
                        get: function() {
                            return dN.isConstant(this[dq]) && dN.isConstant(this[dX])
                        }
                    }, {
                        key: dD,
                        value: function() {
                            var e, t = uL(dN.evaluate(this[dq])),
                                n = uL(dN.evaluate(this[dX])),
                                r = t.number,
                                i = t.unit,
                                a = n.number,
                                o = n.unit;
                            if (null != o && null != i && o != i) return uA;
                            switch (this[dj].value) {
                                case "+":
                                    e = r + a;
                                    break;
                                case "-":
                                    e = r - a;
                                    break;
                                case "/":
                                    e = r / a;
                                    break;
                                case "*":
                                    e = r * a;
                                    break;
                                default:
                                    return uA
                            }
                            return {
                                type: "number",
                                number: e,
                                unit: i || o
                            }
                        }
                    }]), t
                }(dN),
                dJ = Symbol("evaluatables"),
                dZ = Symbol("intrinsics"),
                dK = function(e) {
                    function t(e, n) {
                        (0, k._)(this, t), (r = (0, E._)(this, t))[dZ] = n;
                        var r, i = e[0],
                            a = null != i ? i.terms : [];
                        return r[dJ] = n.basis.map(function(e, t) {
                            var n = a[t];
                            return null == n ? {
                                type: "ident",
                                value: "auto"
                            } : "ident" === n.type ? n : dN.evaluatableFor(n, e)
                        }), r
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "isConstant",
                        get: function() {
                            var e = !0,
                                t = !1,
                                n = void 0;
                            try {
                                for (var r, i = this[dJ][Symbol.iterator](); !(e = (r = i.next()).done); e = !0) {
                                    var a = r.value;
                                    if (!dN.isConstant(a)) return !1
                                }
                            } catch (e) {
                                t = !0, n = e
                            } finally {
                                try {
                                    e || null == i.return || i.return()
                                } finally {
                                    if (t) throw n
                                }
                            }
                            return !0
                        }
                    }, {
                        key: dD,
                        value: function() {
                            var e = this[dJ].map(function(e) {
                                return dN.evaluate(e)
                            });
                            return dN.applyIntrinsics(e, this[dZ]).map(function(e) {
                                return e.number
                            })
                        }
                    }]), t
                }(dN),
                dQ = Symbol("instances"),
                d$ = Symbol("activateListener"),
                d0 = Symbol("deactivateListener"),
                d1 = Symbol("notifyInstances"),
                d2 = Symbol("notify"),
                d3 = Symbol("callback"),
                d4 = function() {
                    function e(t) {
                        (0, k._)(this, e), this[d3] = t
                    }
                    return (0, A._)(e, [{
                        key: "observe",
                        value: function() {
                            0 === e[dQ].size && e[d$](), e[dQ].add(this)
                        }
                    }, {
                        key: "disconnect",
                        value: function() {
                            e[dQ].delete(this), 0 === e[dQ].size && e[d0]()
                        }
                    }, {
                        key: d2,
                        value: function() {
                            this[d3]()
                        }
                    }], [{
                        key: d1,
                        value: function() {
                            var t = !0,
                                n = !1,
                                r = void 0;
                            try {
                                for (var i, a = e[dQ][Symbol.iterator](); !(t = (i = a.next()).done); t = !0) i.value[d2]()
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == a.return || a.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                        }
                    }, {
                        key: (s = dQ, d$),
                        value: function() {
                            window.addEventListener("scroll", this[d1], {
                                passive: !0
                            })
                        }
                    }, {
                        key: d0,
                        value: function() {
                            window.removeEventListener("scroll", this[d1])
                        }
                    }]), e
                }();
            d4[s] = new Set;
            var d5 = Symbol("computeStyleCallback"),
                d6 = Symbol("astWalker"),
                d8 = Symbol("dependencies"),
                d7 = Symbol("onScroll"),
                d9 = function() {
                    function e(t) {
                        var n = this;
                        (0, k._)(this, e), this[l] = {}, this[u] = new uk(["function"]), this[c] = function() {
                            n[d5]({
                                relatedState: "window-scroll"
                            })
                        }, this[d5] = t
                    }
                    return (0, A._)(e, [{
                        key: "observeEffectsFor",
                        value: function(e) {
                            var t = this,
                                n = {},
                                r = this[d8];
                            for (var i in this[d6].walk(e, function(e) {
                                    var i = e.name,
                                        a = e.arguments[0].terms[0];
                                    if ("env" === i.value && null != a && "ident" === a.type && "window-scroll-y" === a.value && null == n["window-scroll"]) {
                                        var o = "window-scroll" in r ? r["window-scroll"] : new d4(t[d7]);
                                        o.observe(), delete r["window-scroll"], n["window-scroll"] = o
                                    }
                                }), r) r[i].disconnect();
                            this[d8] = n
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            for (var e in this[d8]) this[d8][e].disconnect()
                        }
                    }]), e
                }();
            l = d8, u = d6, c = d7;
            var fe = function(e) {
                    var t = e.observeEffects || !1,
                        n = e.intrinsics instanceof Function ? e.intrinsics : function() {
                            return e.intrinsics
                        };
                    return function(r, i) {
                        var a, o = r.updated,
                            s = r.connectedCallback,
                            l = r.disconnectedCallback,
                            u = Symbol("".concat(i, "StyleEffector")),
                            c = Symbol("".concat(i, "StyleEvaluator")),
                            h = Symbol("".concat(i, "UpdateEvaluator")),
                            d = Symbol("".concat(i, "EvaluateAndSync"));
                        Object.defineProperties(r, (a = {}, (0, R._)(a, u, {
                            value: null,
                            writable: !0
                        }), (0, R._)(a, c, {
                            value: null,
                            writable: !0
                        }), (0, R._)(a, h, {
                            value: function() {
                                var e = this,
                                    r = ux(this[i]);
                                this[c] = new dK(r, n(this)), null == this[u] && t && (this[u] = new d9(function() {
                                    return e[d]()
                                })), null != this[u] && this[u].observeEffectsFor(r)
                            }
                        }), (0, R._)(a, d, {
                            value: function() {
                                if (null != this[c]) {
                                    var t = this[c].evaluate();
                                    this[e.updateHandler](t)
                                }
                            }
                        }), (0, R._)(a, "updated", {
                            value: function(e) {
                                e.has(i) && (this[h](), this[d]()), o.call(this, e)
                            }
                        }), (0, R._)(a, "connectedCallback", {
                            value: function() {
                                s.call(this), this.requestUpdate(i, this[i])
                            }
                        }), (0, R._)(a, "disconnectedCallback", {
                            value: function() {
                                l.call(this), null != this[u] && (this[u].dispose(), this[u] = null)
                            }
                        }), a))
                    }
                },
                ft = Object.freeze({
                    minimumRadius: 0,
                    maximumRadius: 1 / 0,
                    minimumPolarAngle: Math.PI / 8,
                    maximumPolarAngle: Math.PI - Math.PI / 8,
                    minimumAzimuthalAngle: -1 / 0,
                    maximumAzimuthalAngle: 1 / 0,
                    minimumFieldOfView: 10,
                    maximumFieldOfView: 45,
                    interactionPolicy: "always-allow",
                    touchAction: "pan-y"
                }),
                fn = Math.PI / 8,
                fr = "user-interaction",
                fi = function(e) {
                    function t(e, n) {
                        var r;
                        return (0, k._)(this, t), (r = (0, E._)(this, t)).camera = e, r.element = n, r.sensitivity = 1, r._interactionEnabled = !1, r._disableZoom = !1, r.isUserChange = !1, r.isUserPointing = !1, r.spherical = new s$, r.goalSpherical = new s$, r.thetaDamper = new uy, r.phiDamper = new uy, r.radiusDamper = new uy, r.logFov = Math.log(ft.maximumFieldOfView), r.goalLogFov = r.logFov, r.fovDamper = new uy, r.touchMode = null, r.lastPointerPosition = {
                            clientX: 0,
                            clientY: 0
                        }, r.touchDecided = !1, r.onMouseMove = function(e) {
                            r.handleSinglePointerMove(e), e.cancelable && e.preventDefault()
                        }, r.onTouchMove = function(e) {
                            null !== r.touchMode && (r.touchMode(e), null !== r.touchMode && e.cancelable && e.preventDefault())
                        }, r.touchModeZoom = function(e) {
                            var t = e.targetTouches;
                            if (r.lastTouches.length > 1 && t.length > 1) {
                                var n = .04 * (r.twoTouchDistance(r.lastTouches[0], r.lastTouches[1]) - r.twoTouchDistance(t[0], t[1])) / 10;
                                r.userAdjustOrbit(0, 0, n), r.lastTouches = t
                            }
                        }, r.touchModeRotate = function(e) {
                            var t = e.targetTouches,
                                n = r._options.touchAction;
                            if (!r.touchDecided && "none" !== n) {
                                r.touchDecided = !0;
                                var i = t[0],
                                    a = i.clientX,
                                    o = i.clientY,
                                    s = Math.abs(a - r.lastPointerPosition.clientX),
                                    l = Math.abs(o - r.lastPointerPosition.clientY);
                                if ("pan-y" === n && l > s || "pan-x" === n && s > l) return void(r.touchMode = null)
                            }
                            r.handleSinglePointerMove(t[0]), r.lastTouches = t
                        }, r.onMouseDown = function(e) {
                            r.onPointerDown(function() {
                                self.addEventListener("mousemove", r.onMouseMove), self.addEventListener("mouseup", r.onMouseUp, {
                                    once: !0
                                }), r.handleSinglePointerDown(e)
                            })
                        }, r.onTouchStart = function(e) {
                            r.onPointerDown(function() {
                                var t = e.targetTouches,
                                    n = e.changedTouches,
                                    i = e.touches;
                                t.length === n.length && (r.touchMode = null, r.touchDecided = !1), t.length === i.length && r.onTouchChange(e)
                            })
                        }, r.onMouseUp = function(e) {
                            self.removeEventListener("mousemove", r.onMouseMove), r.onPointerUp()
                        }, r.onTouchEnd = function(e) {
                            e.targetTouches.length > 0 && null !== r.touchMode && r.onTouchChange(e), r.onPointerUp()
                        }, r.onWheel = function(e) {
                            if (r.canInteract) {
                                var t = e.deltaY * (1 == e.deltaMode ? 18 : 1) * .04 / 30;
                                r.userAdjustOrbit(0, 0, t), e.cancelable && e.preventDefault()
                            }
                        }, r.onKeyDown = function(e) {
                            var t = !1;
                            switch (e.keyCode) {
                                case 33:
                                    t = !0, r.userAdjustOrbit(0, 0, .04);
                                    break;
                                case 34:
                                    t = !0, r.userAdjustOrbit(0, 0, -.04);
                                    break;
                                case 38:
                                    t = !0, r.userAdjustOrbit(0, -fn, 0);
                                    break;
                                case 40:
                                    t = !0, r.userAdjustOrbit(0, fn, 0);
                                    break;
                                case 37:
                                    t = !0, r.userAdjustOrbit(-fn, 0, 0);
                                    break;
                                case 39:
                                    t = !0, r.userAdjustOrbit(fn, 0, 0)
                            }
                            t && e.cancelable && e.preventDefault()
                        }, r._options = Object.assign({}, ft), r.setOrbit(0, Math.PI / 2, 1), r.setFieldOfView(100), r.jumpToGoal(), r
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "interactionEnabled",
                        get: function() {
                            return this._interactionEnabled
                        }
                    }, {
                        key: "enableInteraction",
                        value: function() {
                            if (!1 === this._interactionEnabled) {
                                var e = this.element;
                                e.addEventListener("mousedown", this.onMouseDown), this._disableZoom || e.addEventListener("wheel", this.onWheel), e.addEventListener("keydown", this.onKeyDown), e.addEventListener("touchstart", this.onTouchStart, {
                                    passive: !0
                                }), e.addEventListener("touchmove", this.onTouchMove, {
                                    passive: !1
                                }), e.addEventListener("touchend", this.onTouchEnd), this.element.style.cursor = "grab", this._interactionEnabled = !0, this.updateTouchActionStyle()
                            }
                        }
                    }, {
                        key: "disableInteraction",
                        value: function() {
                            if (!0 === this._interactionEnabled) {
                                var e = this.element;
                                self.removeEventListener("mousemove", this.onMouseMove), e.removeEventListener("mousedown", this.onMouseDown), this._disableZoom || e.removeEventListener("wheel", this.onWheel), e.removeEventListener("keydown", this.onKeyDown), e.removeEventListener("touchstart", this.onTouchStart), e.removeEventListener("touchmove", this.onTouchMove), self.removeEventListener("mouseup", this.onMouseUp), e.removeEventListener("touchend", this.onTouchEnd), e.style.cursor = "", this.touchMode = null, this._interactionEnabled = !1, this.updateTouchActionStyle()
                            }
                        }
                    }, {
                        key: "options",
                        get: function() {
                            return this._options
                        }
                    }, {
                        key: "disableZoom",
                        set: function(e) {
                            this._disableZoom != e && (this._disableZoom = e, !0 === e ? this.element.removeEventListener("wheel", this.onWheel) : this.element.addEventListener("wheel", this.onWheel), this.updateTouchActionStyle())
                        }
                    }, {
                        key: "getCameraSpherical",
                        value: function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new s$;
                            return e.copy(this.spherical)
                        }
                    }, {
                        key: "getFieldOfView",
                        value: function() {
                            return this.camera.fov
                        }
                    }, {
                        key: "applyOptions",
                        value: function(e) {
                            Object.assign(this._options, e), this.setOrbit(), this.setFieldOfView(Math.exp(this.goalLogFov))
                        }
                    }, {
                        key: "updateNearFar",
                        value: function(e, t) {
                            this.camera.near = Math.max(e, t / 1e3), this.camera.far = t, this.camera.updateProjectionMatrix()
                        }
                    }, {
                        key: "updateAspect",
                        value: function(e) {
                            this.camera.aspect = e, this.camera.updateProjectionMatrix()
                        }
                    }, {
                        key: "setOrbit",
                        value: function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.goalSpherical.theta,
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.goalSpherical.phi,
                                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.goalSpherical.radius,
                                r = this._options,
                                i = r.minimumAzimuthalAngle,
                                a = r.maximumAzimuthalAngle,
                                o = r.minimumPolarAngle,
                                s = r.maximumPolarAngle,
                                l = r.minimumRadius,
                                u = r.maximumRadius,
                                c = this.goalSpherical,
                                h = c.theta,
                                d = c.phi,
                                f = c.radius,
                                p = up(e, i, a);
                            isFinite(i) || isFinite(a) || (this.spherical.theta = this.wrapAngle(this.spherical.theta - p) + p);
                            var m = up(t, o, s),
                                v = up(n, l, u);
                            return (p !== h || m !== d || v !== f) && (this.goalSpherical.theta = p, this.goalSpherical.phi = m, this.goalSpherical.radius = v, this.goalSpherical.makeSafe(), this.isUserChange = !1, !0)
                        }
                    }, {
                        key: "setRadius",
                        value: function(e) {
                            this.goalSpherical.radius = e, this.setOrbit()
                        }
                    }, {
                        key: "setFieldOfView",
                        value: function(e) {
                            var t = this._options;
                            e = up(e, t.minimumFieldOfView, t.maximumFieldOfView), this.goalLogFov = Math.log(e)
                        }
                    }, {
                        key: "setDamperDecayTime",
                        value: function(e) {
                            this.thetaDamper.setDecayTime(e), this.phiDamper.setDecayTime(e), this.radiusDamper.setDecayTime(e), this.fovDamper.setDecayTime(e)
                        }
                    }, {
                        key: "adjustOrbit",
                        value: function(e, t, n) {
                            var r = this.goalSpherical,
                                i = r.theta,
                                a = r.phi,
                                o = r.radius,
                                s = this._options,
                                l = s.minimumRadius,
                                u = s.maximumRadius,
                                c = s.minimumFieldOfView,
                                h = s.maximumFieldOfView,
                                d = this.spherical.theta - i,
                                f = Math.PI - .001,
                                p = i - up(e, -f - d, f - d),
                                m = 0 === n ? 0 : ((n > 0 ? u : l) - o) / (Math.log(n > 0 ? h : c) - this.goalLogFov),
                                v = o + n * (isFinite(m) ? m : 2 * (u - l));
                            if (this.setOrbit(p, a - t, v), 0 !== n) {
                                var g = this.goalLogFov + n;
                                this.setFieldOfView(Math.exp(g))
                            }
                        }
                    }, {
                        key: "jumpToGoal",
                        value: function() {
                            this.update(0, 1e4)
                        }
                    }, {
                        key: "update",
                        value: function(e, t) {
                            if (!this.isStationary()) {
                                var n = this._options,
                                    r = n.maximumPolarAngle,
                                    i = n.maximumRadius,
                                    a = this.spherical.theta - this.goalSpherical.theta;
                                !(Math.abs(a) > Math.PI) || isFinite(this._options.minimumAzimuthalAngle) || isFinite(this._options.maximumAzimuthalAngle) || (this.spherical.theta -= 2 * Math.sign(a) * Math.PI), this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, t, Math.PI), this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, t, r), this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, t, i), this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, t, 1), this.moveCamera()
                            }
                        }
                    }, {
                        key: "updateTouchActionStyle",
                        value: function() {
                            var e = this.element.style;
                            if (this._interactionEnabled) {
                                var t = this._options.touchAction;
                                this._disableZoom && "none" !== t ? e.touchAction = "manipulation" : e.touchAction = t
                            } else e.touchAction = ""
                        }
                    }, {
                        key: "isStationary",
                        value: function() {
                            return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov
                        }
                    }, {
                        key: "moveCamera",
                        value: function() {
                            this.spherical.makeSafe(), this.camera.position.setFromSpherical(this.spherical), this.camera.setRotationFromEuler(new tX(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, "YXZ")), this.camera.fov !== Math.exp(this.logFov) && (this.camera.fov = Math.exp(this.logFov), this.camera.updateProjectionMatrix());
                            var e = this.isUserChange ? fr : "none";
                            this.dispatchEvent({
                                type: "change",
                                source: e
                            })
                        }
                    }, {
                        key: "canInteract",
                        get: function() {
                            return "allow-when-focused" == this._options.interactionPolicy ? this.element.getRootNode().activeElement === this.element : "always-allow" === this._options.interactionPolicy
                        }
                    }, {
                        key: "userAdjustOrbit",
                        value: function(e, t, n) {
                            this.adjustOrbit(e * this.sensitivity, t * this.sensitivity, n), this.isUserChange = !0, this.dispatchEvent({
                                type: "change",
                                source: fr
                            })
                        }
                    }, {
                        key: "wrapAngle",
                        value: function(e) {
                            var t = (e + Math.PI) / (2 * Math.PI);
                            return 2 * (t - Math.floor(t)) * Math.PI - Math.PI
                        }
                    }, {
                        key: "pixelLengthToSphericalAngle",
                        value: function(e) {
                            return 2 * Math.PI * e / this.element.clientHeight
                        }
                    }, {
                        key: "twoTouchDistance",
                        value: function(e, t) {
                            var n = e.clientX,
                                r = e.clientY,
                                i = t.clientX,
                                a = t.clientY,
                                o = i - n,
                                s = a - r;
                            return Math.sqrt(o * o + s * s)
                        }
                    }, {
                        key: "handleSinglePointerMove",
                        value: function(e) {
                            var t = e.clientX,
                                n = e.clientY,
                                r = this.pixelLengthToSphericalAngle(t - this.lastPointerPosition.clientX),
                                i = this.pixelLengthToSphericalAngle(n - this.lastPointerPosition.clientY);
                            this.lastPointerPosition.clientX = t, this.lastPointerPosition.clientY = n, !1 === this.isUserPointing && (this.isUserPointing = !0, this.dispatchEvent({
                                type: "pointer-change-start",
                                pointer: Object.assign({}, e)
                            })), this.userAdjustOrbit(r, i, 0)
                        }
                    }, {
                        key: "onPointerDown",
                        value: function(e) {
                            this.canInteract && (this.isUserPointing = !1, e())
                        }
                    }, {
                        key: "onTouchChange",
                        value: function(e) {
                            var t = e.targetTouches;
                            switch (t.length) {
                                default:
                                    case 1:
                                    this.touchMode = this.touchModeRotate,
                                this.handleSinglePointerDown(t[0]);
                                break;
                                case 2:
                                        this.touchMode = this._disableZoom || this.touchDecided && null === this.touchMode ? null : this.touchModeZoom,
                                    this.touchDecided = !0
                            }
                            this.lastTouches = t
                        }
                    }, {
                        key: "handleSinglePointerDown",
                        value: function(e) {
                            this.lastPointerPosition.clientX = e.clientX, this.lastPointerPosition.clientY = e.clientY, this.element.style.cursor = "grabbing"
                        }
                    }, {
                        key: "onPointerUp",
                        value: function() {
                            this.element.style.cursor = "grab", this.isUserPointing && this.dispatchEvent({
                                type: "pointer-change-end",
                                pointer: Object.assign({}, this.lastPointerPosition)
                            })
                        }
                    }]), t
                }(eW),
                fa = function(e) {
                    return e < .5 ? 2 * e * e : (4 - 2 * e) * e - 1
                },
                fo = function(e, t) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : fa;
                    return function(r) {
                        return e + (t - e) * n(r)
                    }
                },
                fs = function(e, t) {
                    for (var n, r, i = [], a = [], o = e, s = 0; s < t.length; ++s) {
                        var l = t[s],
                            u = l.value,
                            c = l.frames,
                            h = fo(o, u, l.ease || fa);
                        i.push(h), a.push(c), o = u
                    }
                    return n = a.reduce(function(e, t) {
                            return e + t
                        }, 0), r = a.map(function(e) {
                            return e / n
                        }),
                        function(e) {
                            for (var t = 0, n = 1 / 0, a = function() {
                                    return 0
                                }, o = 0; o < r.length && (n = r[o], a = i[o], !(e <= t + n)); ++o) t += n;
                            return a((e - t) / n)
                        }
                },
                fl = function(e, t, n, r) {
                    for (var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r, s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o);
                    return a > 3 && o && Object.defineProperty(t, n, o), o
                },
                fu = fs(0, [{
                    frames: 5,
                    value: -1
                }, {
                    frames: 1,
                    value: -1
                }, {
                    frames: 8,
                    value: 1
                }, {
                    frames: 1,
                    value: 1
                }, {
                    frames: 5,
                    value: 0
                }, {
                    frames: 18,
                    value: 0
                }]),
                fc = fs(0, [{
                    frames: 1,
                    value: 1
                }, {
                    frames: 5,
                    value: 1
                }, {
                    frames: 1,
                    value: 0
                }, {
                    frames: 6,
                    value: 0
                }]),
                fh = ["front", "right", "back", "left"],
                fd = ["upper-", "", "lower-"],
                ff = "auto",
                fp = "when-focused",
                fm = "wiggle",
                fv = function() {
                    return {
                        basis: [uR(u_(45, "deg"))],
                        keywords: {
                            auto: [null]
                        }
                    }
                },
                fg = {
                    basis: [uR(u_(25, "deg"))],
                    keywords: {
                        auto: [null]
                    }
                },
                fy = function() {
                    return {
                        basis: [uR(u_(45, "deg"))],
                        keywords: {
                            auto: [null]
                        }
                    }
                },
                f_ = function() {
                    var e = ux("0deg 75deg 105%")[0].terms,
                        t = uL(e[0]),
                        n = uL(e[1]);
                    return function(e) {
                        return {
                            basis: [t, n, u_(e[ht].idealCameraDistance(), "m")],
                            keywords: {
                                auto: [null, null, u_(105, "%")]
                            }
                        }
                    }
                }(),
                fx = function(e) {
                    var t = 1.1 * e[ht].boundingRadius;
                    return {
                        basis: [u_(-1 / 0, "rad"), u_(Math.PI / 8, "rad"), u_(t, "m")],
                        keywords: {
                            auto: [null, null, null]
                        }
                    }
                },
                fb = function(e) {
                    var t = new dK([], f_(e)).evaluate()[2];
                    return {
                        basis: [u_(1 / 0, "rad"), u_(Math.PI - Math.PI / 8, "rad"), u_(t, "m")],
                        keywords: {
                            auto: [null, null, null]
                        }
                    }
                },
                fw = function(e) {
                    var t = e[ht].boundingBox.getCenter(new to);
                    return {
                        basis: [u_(t.x, "m"), u_(t.y, "m"), u_(t.z, "m")],
                        keywords: {
                            auto: [null, null, null]
                        }
                    }
                },
                fM = Math.PI / 2,
                fS = Math.PI / 3,
                fT = fM / 2,
                fE = 2 * Math.PI,
                fk = Symbol("controls"),
                fA = Symbol("promptElement"),
                fR = Symbol("promptAnimatedContainer"),
                fC = Symbol("deferInteractionPrompt"),
                fL = Symbol("updateAria"),
                fP = Symbol("updateCameraForRadius"),
                fI = Symbol("onBlur"),
                fD = Symbol("onFocus"),
                fO = Symbol("onChange"),
                fN = Symbol("onPointerChange"),
                fF = Symbol("waitingToPromptUser"),
                fU = Symbol("userHasInteracted"),
                fB = Symbol("promptElementVisibleTime"),
                fz = Symbol("lastPromptOffset"),
                fH = Symbol("focusedTime"),
                fV = Symbol("lastSpherical"),
                fG = Symbol("jumpCamera"),
                fW = Symbol("initialized"),
                fj = Symbol("maintainThetaPhi"),
                fq = Symbol("syncCameraOrbit"),
                fX = Symbol("syncFieldOfView"),
                fY = Symbol("syncCameraTarget"),
                fJ = Symbol("syncMinCameraOrbit"),
                fZ = Symbol("syncMaxCameraOrbit"),
                fK = Symbol("syncMinFieldOfView"),
                fQ = Symbol("syncMaxFieldOfView"),
                f$ = Symbol("modelViewerStatusInstance"),
                f0 = Symbol("updateStatus"),
                f1 = function(e, t, n, r) {
                    for (var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r, s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o);
                    return a > 3 && o && Object.defineProperty(t, n, o), o
                },
                f2 = "auto",
                f3 = "manual",
                f4 = new(function(e) {
                    function t() {
                        (0, k._)(this, t), (e = (0, E._)(this, t))[f$] = null, e.registeredInstanceStatuses = new Map, e.loadingPromises = [], e.statusElement = document.createElement("p"), e.statusUpdateInProgress = !1, e[f0] = uf(function() {
                            return e.updateStatus()
                        }, 100);
                        var e, n = e.statusElement,
                            r = n.style;
                        return n.setAttribute("role", "status"), n.classList.add("screen-reader-only"), r.top = r.left = "0", r.pointerEvents = "none", e
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "registerInstance",
                        value: function(e) {
                            if (!this.registeredInstanceStatuses.has(e)) {
                                var t = function() {},
                                    n = !1 === e.loaded && !!e.src,
                                    r = new Promise(function(r) {
                                        if (!n) return void r();
                                        var i = function() {
                                            r(), e.removeEventListener("load", i), e.removeEventListener("error", i)
                                        };
                                        e.addEventListener("load", i), e.addEventListener("error", i), t = i
                                    });
                                this.registeredInstanceStatuses.set(e, {
                                    onUnregistered: t
                                }), this.loadingPromises.push(r), null == this.modelViewerStatusInstance && (this.modelViewerStatusInstance = e)
                            }
                        }
                    }, {
                        key: "unregisterInstance",
                        value: function(e) {
                            if (this.registeredInstanceStatuses.has(e)) {
                                var t = this.registeredInstanceStatuses,
                                    n = t.get(e);
                                t.delete(e), n.onUnregistered(), this.modelViewerStatusInstance === e && (this.modelViewerStatusInstance = t.size > 0 ? function(e) {
                                    if (null != e.keys) return e.keys().next().value || null;
                                    var t = null;
                                    try {
                                        e.forEach(function(e, n, r) {
                                            throw t = n, Error()
                                        })
                                    } catch (e) {}
                                    return t
                                }(t) : null)
                            }
                        }
                    }, {
                        key: "modelViewerStatusInstance",
                        get: function() {
                            return this[f$]
                        },
                        set: function(e) {
                            if (this[f$] !== e) {
                                var t = this.statusElement;
                                null != e && null != e.shadowRoot ? e.shadowRoot.appendChild(t) : null != t.parentNode && t.parentNode.removeChild(t), this[f$] = e, this[f0]()
                            }
                        }
                    }, {
                        key: "updateStatus",
                        value: function() {
                            var e = this;
                            return (0, T._)(function() {
                                var t;
                                return (0, z.YH)(this, function(n) {
                                    switch (n.label) {
                                        case 0:
                                            if (!(!e.statusUpdateInProgress && 0 !== e.loadingPromises.length)) return [3, 5];
                                            e.statusElement.textContent = "This page includes one or more 3D models that are loading", e.statusUpdateInProgress = !0, e.dispatchEvent({
                                                type: "initial-status-announced"
                                            }), n.label = 1;
                                        case 1:
                                            if (!e.loadingPromises.length) return [3, 4];
                                            return t = e.loadingPromises, e.loadingPromises = [], [4, Promise.all(t)];
                                        case 2:
                                            n.sent(), n.label = 3;
                                        case 3:
                                            return [3, 1];
                                        case 4:
                                            e.statusElement.textContent = "All 3D models in the page have loaded", e.statusUpdateInProgress = !1, e.dispatchEvent({
                                                type: "finished-loading-announced"
                                            }), n.label = 5;
                                        case 5:
                                            return [2]
                                    }
                                })
                            })()
                        }
                    }]), t
                }(eW)),
                f5 = Symbol("defaultProgressBarElement"),
                f6 = Symbol("defaultProgressMaskElement"),
                f8 = Symbol("posterContainerElement"),
                f7 = Symbol("defaultPosterElement"),
                f9 = Symbol("posterDismissalSource"),
                pe = Symbol("hidePoster"),
                pt = Symbol("modelIsRevealed"),
                pn = Symbol("updateProgressBar"),
                pr = Symbol("lastReportedProgress"),
                pi = Symbol("transitioned"),
                pa = Symbol("onTransitionEnd"),
                po = Symbol("ariaLabelCallToAction"),
                ps = Symbol("onClick"),
                pl = Symbol("onKeydown"),
                pu = Symbol("onProgress"),
                pc = function() {
                    function e() {
                        (0, k._)(this, e), this.pluginCallbacks = [], this.register(function(e) {
                            return new py(e)
                        }), this.register(function(e) {
                            return new p_(e)
                        }), this.register(function(e) {
                            return new px(e)
                        }), this.register(function(e) {
                            return new pw(e)
                        }), this.register(function(e) {
                            return new pM(e)
                        }), this.register(function(e) {
                            return new pb(e)
                        })
                    }
                    return (0, A._)(e, [{
                        key: "register",
                        value: function(e) {
                            return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
                        }
                    }, {
                        key: "unregister",
                        value: function(e) {
                            return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
                        }
                    }, {
                        key: "parse",
                        value: function(e, t, n, r) {
                            "object" == (void 0 === n ? "undefined" : (0, U._)(n)) && (console.warn("THREE.GLTFExporter: parse() expects options as the fourth argument now."), r = n);
                            for (var i = new pg, a = [], o = 0, s = this.pluginCallbacks.length; o < s; o++) a.push(this.pluginCallbacks[o](i));
                            i.setPlugins(a), i.write(e, t, r).catch(n)
                        }
                    }, {
                        key: "parseAsync",
                        value: function(e, t) {
                            var n = this;
                            return new Promise(function(r, i) {
                                n.parse(e, r, i, t)
                            })
                        }
                    }]), e
                }(),
                ph = {};
            ph[1003] = 9728, ph[1004] = 9984, ph[1005] = 9986, ph[1006] = 9729, ph[1007] = 9985, ph[1008] = 9987, ph[1001] = 33071, ph[1e3] = 10497, ph[1002] = 33648;
            var pd = {
                scale: "scale",
                position: "translation",
                quaternion: "rotation",
                morphTargetInfluences: "weights"
            };

            function pf(e, t) {
                return e.length === t.length && e.every(function(e, n) {
                    return e === t[n]
                })
            }

            function pp(e) {
                return 4 * Math.ceil(e / 4)
            }

            function pm(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = pp(e.byteLength);
                if (n !== e.byteLength) {
                    var r = new Uint8Array(n);
                    if (r.set(new Uint8Array(e)), 0 !== t)
                        for (var i = e.byteLength; i < n; i++) r[i] = t;
                    return r.buffer
                }
                return e
            }
            var pv = null,
                pg = function() {
                    function e() {
                        (0, k._)(this, e), this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = new Map, this.skins = [], this.extensionsUsed = {}, this.uids = new Map, this.uid = 0, this.json = {
                            asset: {
                                version: "2.0",
                                generator: "THREE.GLTFExporter"
                            }
                        }, this.cache = {
                            meshes: new Map,
                            attributes: new Map,
                            attributesNormalized: new Map,
                            materials: new Map,
                            textures: new Map,
                            images: new Map
                        }
                    }
                    return (0, A._)(e, [{
                        key: "setPlugins",
                        value: function(e) {
                            this.plugins = e
                        }
                    }, {
                        key: "write",
                        value: function(e, t, n) {
                            var r = this;
                            return (0, T._)(function() {
                                var i, a, o, s, l, u, c, h;
                                return (0, z.YH)(this, function(d) {
                                    switch (d.label) {
                                        case 0:
                                            return r.options = Object.assign({}, {
                                                binary: !1,
                                                trs: !1,
                                                onlyVisible: !0,
                                                truncateDrawRange: !0,
                                                embedImages: !0,
                                                maxTextureSize: 1 / 0,
                                                animations: [],
                                                includeCustomExtensions: !1
                                            }, n), r.options.animations.length > 0 && (r.options.trs = !0), r.processInput(e), [4, Promise.all(r.pending)];
                                        case 1:
                                            return d.sent(), a = (i = r).buffers, o = i.json, n = i.options, s = i.extensionsUsed, l = new Blob(a, {
                                                type: "application/octet-stream"
                                            }), ((u = Object.keys(s)).length > 0 && (o.extensionsUsed = u), o.buffers && o.buffers.length > 0 && (o.buffers[0].byteLength = l.size), !0 === n.binary) ? ((c = new window.FileReader).readAsArrayBuffer(l), c.onloadend = function() {
                                                var e = pm(c.result),
                                                    n = new DataView(new ArrayBuffer(8));
                                                n.setUint32(0, e.byteLength, !0), n.setUint32(4, 5130562, !0);
                                                var r = pm(function(e) {
                                                        if (void 0 !== window.TextEncoder) return (new TextEncoder).encode(e).buffer;
                                                        for (var t = new Uint8Array(new ArrayBuffer(e.length)), n = 0, r = e.length; n < r; n++) {
                                                            var i = e.charCodeAt(n);
                                                            t[n] = i > 255 ? 32 : i
                                                        }
                                                        return t.buffer
                                                    }(JSON.stringify(o)), 32),
                                                    i = new DataView(new ArrayBuffer(8));
                                                i.setUint32(0, r.byteLength, !0), i.setUint32(4, 0x4e4f534a, !0);
                                                var a = new ArrayBuffer(12),
                                                    s = new DataView(a);
                                                s.setUint32(0, 0x46546c67, !0), s.setUint32(4, 2, !0);
                                                var l = 12 + i.byteLength + r.byteLength + n.byteLength + e.byteLength;
                                                s.setUint32(8, l, !0);
                                                var u = new Blob([a, i, r, n, e], {
                                                        type: "application/octet-stream"
                                                    }),
                                                    h = new window.FileReader;
                                                h.readAsArrayBuffer(u), h.onloadend = function() {
                                                    t(h.result)
                                                }
                                            }) : o.buffers && o.buffers.length > 0 ? ((h = new window.FileReader).readAsDataURL(l), h.onloadend = function() {
                                                var e = h.result;
                                                o.buffers[0].uri = e, t(o)
                                            }) : t(o), [2]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "serializeUserData",
                        value: function(e, t) {
                            if (0 !== Object.keys(e.userData).length) {
                                var n = this.options,
                                    r = this.extensionsUsed;
                                try {
                                    var i = JSON.parse(JSON.stringify(e.userData));
                                    if (n.includeCustomExtensions && i.gltfExtensions) {
                                        for (var a in void 0 === t.extensions && (t.extensions = {}), i.gltfExtensions) t.extensions[a] = i.gltfExtensions[a], r[a] = !0;
                                        delete i.gltfExtensions
                                    }
                                    Object.keys(i).length > 0 && (t.extras = i)
                                } catch (t) {
                                    console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + t.message)
                                }
                            }
                        }
                    }, {
                        key: "getUID",
                        value: function(e) {
                            return this.uids.has(e) || this.uids.set(e, this.uid++), this.uids.get(e)
                        }
                    }, {
                        key: "isNormalizedNormalAttribute",
                        value: function(e) {
                            if (this.cache.attributesNormalized.has(e)) return !1;
                            for (var t = new to, n = 0, r = e.count; n < r; n++)
                                if (Math.abs(t.fromBufferAttribute(e, n).length() - 1) > 5e-4) return !1;
                            return !0
                        }
                    }, {
                        key: "createNormalizedNormalAttribute",
                        value: function(e) {
                            var t = this.cache;
                            if (t.attributesNormalized.has(e)) return t.attributesNormalized.get(e);
                            for (var n = e.clone(), r = new to, i = 0, a = n.count; i < a; i++) r.fromBufferAttribute(n, i), 0 === r.x && 0 === r.y && 0 === r.z ? r.setX(1) : r.normalize(), n.setXYZ(i, r.x, r.y, r.z);
                            return t.attributesNormalized.set(e, n), n
                        }
                    }, {
                        key: "applyTextureTransform",
                        value: function(e, t) {
                            var n = !1,
                                r = {};
                            0 === t.offset.x && 0 === t.offset.y || (r.offset = t.offset.toArray(), n = !0), 0 !== t.rotation && (r.rotation = t.rotation, n = !0), 1 === t.repeat.x && 1 === t.repeat.y || (r.scale = t.repeat.toArray(), n = !0), n && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = r, this.extensionsUsed.KHR_texture_transform = !0)
                        }
                    }, {
                        key: "processBuffer",
                        value: function(e) {
                            var t = this.json,
                                n = this.buffers;
                            return t.buffers || (t.buffers = [{
                                byteLength: 0
                            }]), n.push(e), 0
                        }
                    }, {
                        key: "processBufferView",
                        value: function(e, t, n, r, i) {
                            var a, o = this.json;
                            o.bufferViews || (o.bufferViews = []), a = 5121 === t ? 1 : 5123 === t ? 2 : 4;
                            for (var s = pp(r * e.itemSize * a), l = new DataView(new ArrayBuffer(s)), u = 0, c = n; c < n + r; c++)
                                for (var h = 0; h < e.itemSize; h++) {
                                    var d = void 0;
                                    e.itemSize > 4 ? d = e.array[c * e.itemSize + h] : 0 === h ? d = e.getX(c) : 1 === h ? d = e.getY(c) : 2 === h ? d = e.getZ(c) : 3 === h && (d = e.getW(c)), 5126 === t ? l.setFloat32(u, d, !0) : 5125 === t ? l.setUint32(u, d, !0) : 5123 === t ? l.setUint16(u, d, !0) : 5121 === t && l.setUint8(u, d), u += a
                                }
                            var f = {
                                buffer: this.processBuffer(l.buffer),
                                byteOffset: this.byteOffset,
                                byteLength: s
                            };
                            return void 0 !== i && (f.target = i), 34962 === i && (f.byteStride = e.itemSize * a), this.byteOffset += s, o.bufferViews.push(f), {
                                id: o.bufferViews.length - 1,
                                byteLength: 0
                            }
                        }
                    }, {
                        key: "processBufferViewImage",
                        value: function(e) {
                            var t = this,
                                n = t.json;
                            return n.bufferViews || (n.bufferViews = []), new Promise(function(r) {
                                var i = new window.FileReader;
                                i.readAsArrayBuffer(e), i.onloadend = function() {
                                    var e = pm(i.result),
                                        a = {
                                            buffer: t.processBuffer(e),
                                            byteOffset: t.byteOffset,
                                            byteLength: e.byteLength
                                        };
                                    t.byteOffset += e.byteLength, r(n.bufferViews.push(a) - 1)
                                }
                            })
                        }
                    }, {
                        key: "processAccessor",
                        value: function(e, t, n, r) {
                            var i, a, o = this.options,
                                s = this.json;
                            if (e.array.constructor === Float32Array) i = 5126;
                            else if (e.array.constructor === Uint32Array) i = 5125;
                            else if (e.array.constructor === Uint16Array) i = 5123;
                            else {
                                if (e.array.constructor !== Uint8Array) throw Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
                                i = 5121
                            }
                            if (void 0 === n && (n = 0), void 0 === r && (r = e.count), o.truncateDrawRange && void 0 !== t && null === t.index && (r = Math.min(n + r, t.drawRange.count === 1 / 0 ? e.count : t.drawRange.start + t.drawRange.count) - (n = Math.max(n, t.drawRange.start))) < 0 && (r = 0), 0 === r) return null;
                            var l = function(e, t, n) {
                                for (var r = {
                                        min: Array(e.itemSize).fill(Number.POSITIVE_INFINITY),
                                        max: Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)
                                    }, i = t; i < t + n; i++)
                                    for (var a = 0; a < e.itemSize; a++) {
                                        var o = void 0;
                                        e.itemSize > 4 ? o = e.array[i * e.itemSize + a] : 0 === a ? o = e.getX(i) : 1 === a ? o = e.getY(i) : 2 === a ? o = e.getZ(i) : 3 === a && (o = e.getW(i)), r.min[a] = Math.min(r.min[a], o), r.max[a] = Math.max(r.max[a], o)
                                    }
                                return r
                            }(e, n, r);
                            void 0 !== t && (a = e === t.index ? 34963 : 34962);
                            var u = this.processBufferView(e, i, n, r, a),
                                c = {
                                    bufferView: u.id,
                                    byteOffset: u.byteOffset,
                                    componentType: i,
                                    count: r,
                                    max: l.max,
                                    min: l.min,
                                    type: {
                                        1: "SCALAR",
                                        2: "VEC2",
                                        3: "VEC3",
                                        4: "VEC4",
                                        16: "MAT4"
                                    }[e.itemSize]
                                };
                            return !0 === e.normalized && (c.normalized = !0), s.accessors || (s.accessors = []), s.accessors.push(c) - 1
                        }
                    }, {
                        key: "processImage",
                        value: function(e, t, n) {
                            var r = this,
                                i = r.cache,
                                a = r.json,
                                o = r.options,
                                s = r.pending;
                            i.images.has(e) || i.images.set(e, {});
                            var l = i.images.get(e),
                                u = 1023 === t ? "image/png" : "image/jpeg",
                                c = u + ":flipY/" + n.toString();
                            if (void 0 !== l[c]) return l[c];
                            a.images || (a.images = []);
                            var h = {
                                mimeType: u
                            };
                            if (o.embedImages) {
                                var d = pv = pv || document.createElement("canvas");
                                d.width = Math.min(e.width, o.maxTextureSize), d.height = Math.min(e.height, o.maxTextureSize);
                                var f = d.getContext("2d");
                                if (!0 === n && (f.translate(0, d.height), f.scale(1, -1)), "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) f.drawImage(e, 0, 0, d.width, d.height);
                                else {
                                    1023 !== t && 1022 !== t && console.error("GLTFExporter: Only RGB and RGBA formats are supported."), (e.width > o.maxTextureSize || e.height > o.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
                                    var p = new Uint8ClampedArray(e.height * e.width * 4);
                                    if (1023 === t)
                                        for (var m = 0; m < p.length; m += 4) p[m + 0] = e.data[m + 0], p[m + 1] = e.data[m + 1], p[m + 2] = e.data[m + 2], p[m + 3] = e.data[m + 3];
                                    else
                                        for (var v = 0, g = 0; v < p.length; v += 4, g += 3) p[v + 0] = e.data[g + 0], p[v + 1] = e.data[g + 1], p[v + 2] = e.data[g + 2], p[v + 3] = 255;
                                    f.putImageData(new ImageData(p, e.width, e.height), 0, 0)
                                }!0 === o.binary ? s.push(new Promise(function(e) {
                                    d.toBlob(function(t) {
                                        r.processBufferViewImage(t).then(function(t) {
                                            h.bufferView = t, e()
                                        })
                                    }, u)
                                })) : h.uri = d.toDataURL(u)
                            } else h.uri = e.src;
                            var y = a.images.push(h) - 1;
                            return l[c] = y, y
                        }
                    }, {
                        key: "processSampler",
                        value: function(e) {
                            var t = this.json;
                            t.samplers || (t.samplers = []);
                            var n = {
                                magFilter: ph[e.magFilter],
                                minFilter: ph[e.minFilter],
                                wrapS: ph[e.wrapS],
                                wrapT: ph[e.wrapT]
                            };
                            return t.samplers.push(n) - 1
                        }
                    }, {
                        key: "processTexture",
                        value: function(e) {
                            var t = this.cache,
                                n = this.json;
                            if (t.textures.has(e)) return t.textures.get(e);
                            n.textures || (n.textures = []);
                            var r = {
                                sampler: this.processSampler(e),
                                source: this.processImage(e.image, e.format, e.flipY)
                            };
                            e.name && (r.name = e.name), this._invokeAll(function(t) {
                                t.writeTexture && t.writeTexture(e, r)
                            });
                            var i = n.textures.push(r) - 1;
                            return t.textures.set(e, i), i
                        }
                    }, {
                        key: "processMaterial",
                        value: function(e) {
                            var t = this.cache,
                                n = this.json;
                            if (t.materials.has(e)) return t.materials.get(e);
                            if (e.isShaderMaterial) return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
                            n.materials || (n.materials = []);
                            var r = {
                                pbrMetallicRoughness: {}
                            };
                            !0 !== e.isMeshStandardMaterial && !0 !== e.isMeshBasicMaterial && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
                            var i = e.color.toArray().concat([e.opacity]);
                            if (pf(i, [1, 1, 1, 1]) || (r.pbrMetallicRoughness.baseColorFactor = i), e.isMeshStandardMaterial ? (r.pbrMetallicRoughness.metallicFactor = e.metalness, r.pbrMetallicRoughness.roughnessFactor = e.roughness) : (r.pbrMetallicRoughness.metallicFactor = .5, r.pbrMetallicRoughness.roughnessFactor = .5), e.metalnessMap || e.roughnessMap) {
                                if (e.metalnessMap === e.roughnessMap) {
                                    var a = {
                                        index: this.processTexture(e.metalnessMap)
                                    };
                                    this.applyTextureTransform(a, e.metalnessMap), r.pbrMetallicRoughness.metallicRoughnessTexture = a
                                } else console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.")
                            }
                            if (e.map) {
                                var o = {
                                    index: this.processTexture(e.map)
                                };
                                this.applyTextureTransform(o, e.map), r.pbrMetallicRoughness.baseColorTexture = o
                            }
                            if (e.emissive) {
                                var s = e.emissive.clone().multiplyScalar(e.emissiveIntensity),
                                    l = Math.max(s.r, s.g, s.b);
                                if (l > 1 && (s.multiplyScalar(1 / l), console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")), l > 0 && (r.emissiveFactor = s.toArray()), e.emissiveMap) {
                                    var u = {
                                        index: this.processTexture(e.emissiveMap)
                                    };
                                    this.applyTextureTransform(u, e.emissiveMap), r.emissiveTexture = u
                                }
                            }
                            if (e.normalMap) {
                                var c = {
                                    index: this.processTexture(e.normalMap)
                                };
                                e.normalScale && 1 !== e.normalScale.x && (c.scale = e.normalScale.x), this.applyTextureTransform(c, e.normalMap), r.normalTexture = c
                            }
                            if (e.aoMap) {
                                var h = {
                                    index: this.processTexture(e.aoMap),
                                    texCoord: 1
                                };
                                1 !== e.aoMapIntensity && (h.strength = e.aoMapIntensity), this.applyTextureTransform(h, e.aoMap), r.occlusionTexture = h
                            }
                            e.transparent ? r.alphaMode = "BLEND" : e.alphaTest > 0 && (r.alphaMode = "MASK", r.alphaCutoff = e.alphaTest), 2 === e.side && (r.doubleSided = !0), "" !== e.name && (r.name = e.name), this.serializeUserData(e, r), this._invokeAll(function(t) {
                                t.writeMaterial && t.writeMaterial(e, r)
                            });
                            var d = n.materials.push(r) - 1;
                            return t.materials.set(e, d), d
                        }
                    }, {
                        key: "processMesh",
                        value: function(e) {
                            var t, n = this.cache,
                                r = this.json,
                                i = [e.geometry.uuid];
                            if (Array.isArray(e.material))
                                for (var a = 0, o = e.material.length; a < o; a++) i.push(e.material[a].uuid);
                            else i.push(e.material.uuid);
                            var s = i.join(":");
                            if (n.meshes.has(s)) return n.meshes.get(s);
                            var l = e.geometry;
                            if (t = e.isLineSegments ? 1 : e.isLineLoop ? 2 : e.isLine ? 3 : e.isPoints ? 0 : e.material.wireframe ? 1 : 4, !0 !== l.isBufferGeometry) throw Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");
                            var u = {},
                                c = {},
                                h = [],
                                d = [],
                                f = {
                                    uv: "TEXCOORD_0",
                                    uv2: "TEXCOORD_1",
                                    color: "COLOR_0",
                                    skinWeight: "WEIGHTS_0",
                                    skinIndex: "JOINTS_0"
                                },
                                p = l.getAttribute("normal");
                            void 0 === p || this.isNormalizedNormalAttribute(p) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), l.setAttribute("normal", this.createNormalizedNormalAttribute(p)));
                            var m = null;
                            for (var v in l.attributes)
                                if ("morph" !== v.substr(0, 5)) {
                                    var g = l.attributes[v];
                                    if (v = f[v] || v.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(v) || (v = "_" + v), n.attributes.has(this.getUID(g))) {
                                        c[v] = n.attributes.get(this.getUID(g));
                                        continue
                                    }
                                    m = null;
                                    var y = g.array;
                                    "JOINTS_0" !== v || y instanceof Uint16Array || y instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), m = new nw(new Uint16Array(y), g.itemSize, g.normalized));
                                    var _ = this.processAccessor(m || g, l);
                                    null !== _ && (c[v] = _, n.attributes.set(this.getUID(g), _))
                                }
                            if (void 0 !== p && l.setAttribute("normal", p), 0 === Object.keys(c).length) return null;
                            if (void 0 !== e.morphTargetInfluences && e.morphTargetInfluences.length > 0) {
                                var x = [],
                                    b = [],
                                    w = {};
                                if (void 0 !== e.morphTargetDictionary)
                                    for (var M in e.morphTargetDictionary) w[e.morphTargetDictionary[M]] = M;
                                for (var S = 0; S < e.morphTargetInfluences.length; ++S) {
                                    var T = {},
                                        E = !1;
                                    for (var k in l.morphAttributes) {
                                        if ("position" !== k && "normal" !== k) {
                                            E || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), E = !0);
                                            continue
                                        }
                                        var A = l.morphAttributes[k][S],
                                            R = k.toUpperCase(),
                                            C = l.attributes[k];
                                        if (n.attributes.has(this.getUID(A))) {
                                            T[R] = n.attributes.get(this.getUID(A));
                                            continue
                                        }
                                        var L = A.clone();
                                        if (!l.morphTargetsRelative)
                                            for (var P = 0, I = A.count; P < I; P++) L.setXYZ(P, A.getX(P) - C.getX(P), A.getY(P) - C.getY(P), A.getZ(P) - C.getZ(P));
                                        T[R] = this.processAccessor(L, l), n.attributes.set(this.getUID(C), T[R])
                                    }
                                    d.push(T), x.push(e.morphTargetInfluences[S]), void 0 !== e.morphTargetDictionary && b.push(w[S])
                                }
                                u.weights = x, b.length > 0 && (u.extras = {}, u.extras.targetNames = b)
                            }
                            var D = Array.isArray(e.material);
                            if (D && 0 === l.groups.length) return null;
                            for (var O = D ? e.material : [e.material], N = D ? l.groups : [{
                                    materialIndex: 0,
                                    start: void 0,
                                    count: void 0
                                }], F = 0, U = N.length; F < U; F++) {
                                var B = {
                                    mode: t,
                                    attributes: c
                                };
                                if (this.serializeUserData(l, B), d.length > 0 && (B.targets = d), null !== l.index) {
                                    var z = this.getUID(l.index);
                                    void 0 === N[F].start && void 0 === N[F].count || (z += ":" + N[F].start + ":" + N[F].count), n.attributes.has(z) ? B.indices = n.attributes.get(z) : (B.indices = this.processAccessor(l.index, l, N[F].start, N[F].count), n.attributes.set(z, B.indices)), null === B.indices && delete B.indices
                                }
                                var H = this.processMaterial(O[N[F].materialIndex]);
                                null !== H && (B.material = H), h.push(B)
                            }
                            u.primitives = h, r.meshes || (r.meshes = []), this._invokeAll(function(t) {
                                t.writeMesh && t.writeMesh(e, u)
                            });
                            var V = r.meshes.push(u) - 1;
                            return n.meshes.set(s, V), V
                        }
                    }, {
                        key: "processCamera",
                        value: function(e) {
                            var t = this.json;
                            t.cameras || (t.cameras = []);
                            var n = e.isOrthographicCamera,
                                r = {
                                    type: n ? "orthographic" : "perspective"
                                };
                            return n ? r.orthographic = {
                                xmag: 2 * e.right,
                                ymag: 2 * e.top,
                                zfar: e.far <= 0 ? .001 : e.far,
                                znear: e.near < 0 ? 0 : e.near
                            } : r.perspective = {
                                aspectRatio: e.aspect,
                                yfov: e3.degToRad(e.fov),
                                zfar: e.far <= 0 ? .001 : e.far,
                                znear: e.near < 0 ? 0 : e.near
                            }, "" !== e.name && (r.name = e.type), t.cameras.push(r) - 1
                        }
                    }, {
                        key: "processAnimation",
                        value: function(e, t) {
                            var n = this.json,
                                r = this.nodeMap;
                            n.animations || (n.animations = []);
                            for (var i = (e = pc.Utils.mergeMorphTargetTracks(e.clone(), t)).tracks, a = [], o = [], s = 0; s < i.length; ++s) {
                                var l = i[s],
                                    u = sY.parseTrackName(l.name),
                                    c = sY.findNode(t, u.nodeName),
                                    h = pd[u.propertyName];
                                if ("bones" === u.objectName && (c = !0 === c.isSkinnedMesh ? c.skeleton.getBoneByName(u.objectIndex) : void 0), !c || !h) return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', l.name), null;
                                var d = void 0,
                                    f = l.values.length / l.times.length;
                                h === pd.morphTargetInfluences && (f /= c.morphTargetInfluences.length), !0 === l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (d = "CUBICSPLINE", f /= 3) : d = 2300 === l.getInterpolation() ? "STEP" : "LINEAR", o.push({
                                    input: this.processAccessor(new nw(l.times, 1)),
                                    output: this.processAccessor(new nw(l.values, f)),
                                    interpolation: d
                                }), a.push({
                                    sampler: o.length - 1,
                                    target: {
                                        node: r.get(c),
                                        path: h
                                    }
                                })
                            }
                            return n.animations.push({
                                name: e.name || "clip_" + n.animations.length,
                                samplers: o,
                                channels: a
                            }), n.animations.length - 1
                        }
                    }, {
                        key: "processSkin",
                        value: function(e) {
                            var t = this.json,
                                n = this.nodeMap,
                                r = t.nodes[n.get(e)],
                                i = e.skeleton;
                            if (void 0 === i) return null;
                            var a = e.skeleton.bones[0];
                            if (void 0 === a) return null;
                            for (var o = [], s = new Float32Array(16 * i.bones.length), l = new tF, u = 0; u < i.bones.length; ++u) o.push(n.get(i.bones[u])), l.copy(i.boneInverses[u]), l.multiply(e.bindMatrix).toArray(s, 16 * u);
                            return void 0 === t.skins && (t.skins = []), t.skins.push({
                                inverseBindMatrices: this.processAccessor(new nw(s, 16)),
                                joints: o,
                                skeleton: n.get(a)
                            }), r.skin = t.skins.length - 1
                        }
                    }, {
                        key: "processNode",
                        value: function(e) {
                            var t = this.json,
                                n = this.options,
                                r = this.nodeMap;
                            t.nodes || (t.nodes = []);
                            var i = {};
                            if (n.trs) {
                                var a = e.quaternion.toArray(),
                                    o = e.position.toArray(),
                                    s = e.scale.toArray();
                                pf(a, [0, 0, 0, 1]) || (i.rotation = a), pf(o, [0, 0, 0]) || (i.translation = o), pf(s, [1, 1, 1]) || (i.scale = s)
                            } else e.matrixAutoUpdate && e.updateMatrix(), !1 === pf(e.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) && (i.matrix = e.matrix.elements);
                            if ("" !== e.name && (i.name = String(e.name)), this.serializeUserData(e, i), e.isMesh || e.isLine || e.isPoints) {
                                var l = this.processMesh(e);
                                null !== l && (i.mesh = l)
                            } else e.isCamera && (i.camera = this.processCamera(e));
                            if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {
                                for (var u = [], c = 0, h = e.children.length; c < h; c++) {
                                    var d = e.children[c];
                                    if (d.visible || !1 === n.onlyVisible) {
                                        var f = this.processNode(d);
                                        null !== f && u.push(f)
                                    }
                                }
                                u.length > 0 && (i.children = u)
                            }
                            this._invokeAll(function(t) {
                                t.writeNode && t.writeNode(e, i)
                            });
                            var p = t.nodes.push(i) - 1;
                            return r.set(e, p), p
                        }
                    }, {
                        key: "processScene",
                        value: function(e) {
                            var t = this.json,
                                n = this.options;
                            t.scenes || (t.scenes = [], t.scene = 0);
                            var r = {};
                            "" !== e.name && (r.name = e.name), t.scenes.push(r);
                            for (var i = [], a = 0, o = e.children.length; a < o; a++) {
                                var s = e.children[a];
                                if (s.visible || !1 === n.onlyVisible) {
                                    var l = this.processNode(s);
                                    null !== l && i.push(l)
                                }
                            }
                            i.length > 0 && (r.nodes = i), this.serializeUserData(e, r)
                        }
                    }, {
                        key: "processObjects",
                        value: function(e) {
                            var t = new aC;
                            t.name = "AuxScene";
                            for (var n = 0; n < e.length; n++) t.children.push(e[n]);
                            this.processScene(t)
                        }
                    }, {
                        key: "processInput",
                        value: function(e) {
                            var t = this.options;
                            e = e instanceof Array ? e : [e], this._invokeAll(function(t) {
                                t.beforeParse && t.beforeParse(e)
                            });
                            for (var n = [], r = 0; r < e.length; r++) e[r] instanceof aC ? this.processScene(e[r]) : n.push(e[r]);
                            n.length > 0 && this.processObjects(n);
                            for (var i = 0; i < this.skins.length; ++i) this.processSkin(this.skins[i]);
                            for (var a = 0; a < t.animations.length; ++a) this.processAnimation(t.animations[a], e[0]);
                            this._invokeAll(function(t) {
                                t.afterParse && t.afterParse(e)
                            })
                        }
                    }, {
                        key: "_invokeAll",
                        value: function(e) {
                            for (var t = 0, n = this.plugins.length; t < n; t++) e(this.plugins[t])
                        }
                    }]), e
                }(),
                py = function() {
                    function e(t) {
                        (0, k._)(this, e), this.writer = t, this.name = "KHR_lights_punctual"
                    }
                    return (0, A._)(e, [{
                        key: "writeNode",
                        value: function(e, t) {
                            if (e.isLight) {
                                if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
                                var n = this.writer,
                                    r = n.json,
                                    i = n.extensionsUsed,
                                    a = {};
                                e.name && (a.name = e.name), a.color = e.color.toArray(), a.intensity = e.intensity, e.isDirectionalLight ? a.type = "directional" : e.isPointLight ? (a.type = "point", e.distance > 0 && (a.range = e.distance)) : e.isSpotLight && (a.type = "spot", e.distance > 0 && (a.range = e.distance), a.spot = {}, a.spot.innerConeAngle = -((e.penumbra - 1) * e.angle * 1), a.spot.outerConeAngle = e.angle), void 0 !== e.decay && 2 !== e.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), e.target && (e.target.parent !== e || 0 !== e.target.position.x || 0 !== e.target.position.y || -1 !== e.target.position.z) && console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), i[this.name] || (r.extensions = r.extensions || {}, r.extensions[this.name] = {
                                    lights: []
                                }, i[this.name] = !0);
                                var o = r.extensions[this.name].lights;
                                o.push(a), t.extensions = t.extensions || {}, t.extensions[this.name] = {
                                    light: o.length - 1
                                }
                            }
                        }
                    }]), e
                }(),
                p_ = function() {
                    function e(t) {
                        (0, k._)(this, e), this.writer = t, this.name = "KHR_materials_unlit"
                    }
                    return (0, A._)(e, [{
                        key: "writeMaterial",
                        value: function(e, t) {
                            if (e.isMeshBasicMaterial) {
                                var n = this.writer.extensionsUsed;
                                t.extensions = t.extensions || {}, t.extensions[this.name] = {}, n[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = .9
                            }
                        }
                    }]), e
                }(),
                px = function() {
                    function e(t) {
                        (0, k._)(this, e), this.writer = t, this.name = "KHR_materials_pbrSpecularGlossiness"
                    }
                    return (0, A._)(e, [{
                        key: "writeMaterial",
                        value: function(e, t) {
                            if (e.isGLTFSpecularGlossinessMaterial) {
                                var n = this.writer,
                                    r = n.extensionsUsed,
                                    i = {};
                                t.pbrMetallicRoughness.baseColorFactor && (i.diffuseFactor = t.pbrMetallicRoughness.baseColorFactor);
                                var a = [1, 1, 1];
                                if (e.specular.toArray(a, 0), i.specularFactor = a, i.glossinessFactor = e.glossiness, t.pbrMetallicRoughness.baseColorTexture && (i.diffuseTexture = t.pbrMetallicRoughness.baseColorTexture), e.specularMap) {
                                    var o = {
                                        index: n.processTexture(e.specularMap)
                                    };
                                    n.applyTextureTransform(o, e.specularMap), i.specularGlossinessTexture = o
                                }
                                t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0
                            }
                        }
                    }]), e
                }(),
                pb = function() {
                    function e(t) {
                        (0, k._)(this, e), this.writer = t, this.name = "KHR_materials_clearcoat"
                    }
                    return (0, A._)(e, [{
                        key: "writeMaterial",
                        value: function(e, t) {
                            if (e.isMeshPhysicalMaterial) {
                                var n = this.writer,
                                    r = n.extensionsUsed,
                                    i = {};
                                if (i.clearcoatFactor = e.clearcoat, e.clearcoatMap) {
                                    var a = {
                                        index: n.processTexture(e.clearcoatMap)
                                    };
                                    n.applyTextureTransform(a, e.clearcoatMap), i.clearcoatTexture = a
                                }
                                if (i.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) {
                                    var o = {
                                        index: n.processTexture(e.clearcoatRoughnessMap)
                                    };
                                    n.applyTextureTransform(o, e.clearcoatRoughnessMap), i.clearcoatRoughnessTexture = o
                                }
                                if (e.clearcoatNormalMap) {
                                    var s = {
                                        index: n.processTexture(e.clearcoatNormalMap)
                                    };
                                    n.applyTextureTransform(s, e.clearcoatNormalMap), i.clearcoatNormalTexture = s
                                }
                                t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0
                            }
                        }
                    }]), e
                }(),
                pw = function() {
                    function e(t) {
                        (0, k._)(this, e), this.writer = t, this.name = "KHR_materials_transmission"
                    }
                    return (0, A._)(e, [{
                        key: "writeMaterial",
                        value: function(e, t) {
                            if (e.isMeshPhysicalMaterial && 0 !== e.transmission) {
                                var n = this.writer,
                                    r = n.extensionsUsed,
                                    i = {};
                                if (i.transmissionFactor = e.transmission, e.transmissionMap) {
                                    var a = {
                                        index: n.processTexture(e.transmissionMap)
                                    };
                                    n.applyTextureTransform(a, e.transmissionMap), i.transmissionTexture = a
                                }
                                t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0
                            }
                        }
                    }]), e
                }(),
                pM = function() {
                    function e(t) {
                        (0, k._)(this, e), this.writer = t, this.name = "KHR_materials_volume"
                    }
                    return (0, A._)(e, [{
                        key: "writeMaterial",
                        value: function(e, t) {
                            if (e.isMeshPhysicalMaterial && 0 !== e.transmission) {
                                var n = this.writer,
                                    r = n.extensionsUsed,
                                    i = {};
                                if (i.thicknessFactor = e.thickness, e.thicknessMap) {
                                    var a = {
                                        index: n.processTexture(e.thicknessMap)
                                    };
                                    n.applyTextureTransform(a, e.thicknessMap), i.thicknessTexture = a
                                }
                                i.attenuationDistance = e.attenuationDistance, i.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0
                            }
                        }
                    }]), e
                }();
            pc.Utils = {
                insertKeyframe: function(e, t) {
                    var n, r = e.getValueSize(),
                        i = new e.TimeBufferType(e.times.length + 1),
                        a = new e.ValueBufferType(e.values.length + r),
                        o = e.createInterpolant(new e.ValueBufferType(r));
                    if (0 === e.times.length) {
                        i[0] = t;
                        for (var s = 0; s < r; s++) a[s] = 0;
                        n = 0
                    } else if (t < e.times[0]) {
                        if (.001 > Math.abs(e.times[0] - t)) return 0;
                        i[0] = t, i.set(e.times, 1), a.set(o.evaluate(t), 0), a.set(e.values, r), n = 0
                    } else if (t > e.times[e.times.length - 1]) {
                        if (.001 > Math.abs(e.times[e.times.length - 1] - t)) return e.times.length - 1;
                        i[i.length - 1] = t, i.set(e.times, 0), a.set(e.values, 0), a.set(o.evaluate(t), e.values.length), n = i.length - 1
                    } else
                        for (var l = 0; l < e.times.length; l++) {
                            if (.001 > Math.abs(e.times[l] - t)) return l;
                            if (e.times[l] < t && e.times[l + 1] > t) {
                                i.set(e.times.slice(0, l + 1), 0), i[l + 1] = t, i.set(e.times.slice(l + 1), l + 2), a.set(e.values.slice(0, (l + 1) * r), 0), a.set(o.evaluate(t), (l + 1) * r), a.set(e.values.slice((l + 1) * r), (l + 2) * r), n = l + 1;
                                break
                            }
                        }
                    return e.times = i, e.values = a, n
                },
                mergeMorphTargetTracks: function(e, t) {
                    for (var n = [], r = {}, i = e.tracks, a = 0; a < i.length; ++a) {
                        var o = i[a],
                            s = sY.parseTrackName(o.name),
                            l = sY.findNode(t, s.nodeName);
                        if ("morphTargetInfluences" !== s.propertyName || void 0 === s.propertyIndex) {
                            n.push(o);
                            continue
                        }
                        if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) {
                            if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
                            console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), (o = o.clone()).setInterpolation(2301)
                        }
                        var u = l.morphTargetInfluences.length,
                            c = l.morphTargetDictionary[s.propertyIndex];
                        if (void 0 === c) throw Error("THREE.GLTFExporter: Morph target name not found: " + s.propertyIndex);
                        var h = void 0;
                        if (void 0 === r[l.uuid]) {
                            for (var d = new(h = o.clone()).ValueBufferType(u * h.times.length), f = 0; f < h.times.length; f++) d[f * u + c] = h.values[f];
                            h.name = (s.nodeName || "") + ".morphTargetInfluences", h.values = d, r[l.uuid] = h, n.push(h);
                            continue
                        }
                        var p = o.createInterpolant(new o.ValueBufferType(1));
                        h = r[l.uuid];
                        for (var m = 0; m < h.times.length; m++) h.values[m * u + c] = p.evaluate(h.times[m]);
                        for (var v = 0; v < o.times.length; v++) {
                            var g = this.insertKeyframe(h, o.times[v]);
                            h.values[g * u + c] = o.values[v]
                        }
                    }
                    return e.tracks = n, e
                }
            };
            var pS = function(e) {
                    return void 0 !== e.material && e.userData && e.userData.variantMaterials && !!Array.from(e.userData.variantMaterials.values()).filter(function(e) {
                        return pT(e.material)
                    })
                },
                pT = function(e) {
                    return e && e.isMaterial && !Array.isArray(e)
                },
                pE = function() {
                    function e(t) {
                        (0, k._)(this, e), this.writer = t, this.name = "KHR_materials_variants", this.variantNames = []
                    }
                    return (0, A._)(e, [{
                        key: "beforeParse",
                        value: function(e) {
                            var t = this,
                                n = new Set,
                                r = !0,
                                i = !1,
                                a = void 0;
                            try {
                                for (var o, s = e[Symbol.iterator](); !(r = (o = s.next()).done); r = !0) o.value.traverse(function(e) {
                                    if (pS(e)) {
                                        var t = e.userData.variantMaterials,
                                            r = e.userData.variantData,
                                            i = !0,
                                            a = !1,
                                            o = void 0;
                                        try {
                                            for (var s, l = r[Symbol.iterator](); !(i = (s = l.next()).done); i = !0) {
                                                var u = (0, O._)(s.value, 2),
                                                    c = u[0],
                                                    h = u[1],
                                                    d = t.get(h.index);
                                                pT(d.material) && n.add(c)
                                            }
                                        } catch (e) {
                                            a = !0, o = e
                                        } finally {
                                            try {
                                                i || null == l.return || l.return()
                                            } finally {
                                                if (a) throw o
                                            }
                                        }
                                    }
                                })
                            } catch (e) {
                                i = !0, a = e
                            } finally {
                                try {
                                    r || null == s.return || s.return()
                                } finally {
                                    if (i) throw a
                                }
                            }
                            n.forEach(function(e) {
                                return t.variantNames.push(e)
                            })
                        }
                    }, {
                        key: "writeMesh",
                        value: function(e, t) {
                            if (pS(e)) {
                                var n = e.userData,
                                    r = n.variantMaterials,
                                    i = n.variantData,
                                    a = new Map,
                                    o = new Map,
                                    s = Array.from(i.values()).sort(function(e, t) {
                                        return e.index - t.index
                                    }),
                                    l = !0,
                                    u = !1,
                                    c = void 0;
                                try {
                                    for (var h, d = s.entries()[Symbol.iterator](); !(l = (h = d.next()).done); l = !0) {
                                        var f = (0, O._)(h.value, 2),
                                            p = f[0],
                                            m = f[1];
                                        o.set(m.index, p)
                                    }
                                } catch (e) {
                                    u = !0, c = e
                                } finally {
                                    try {
                                        l || null == d.return || d.return()
                                    } finally {
                                        if (u) throw c
                                    }
                                }
                                var v = !0,
                                    g = !1,
                                    y = void 0;
                                try {
                                    for (var _, x = i.values()[Symbol.iterator](); !(v = (_ = x.next()).done); v = !0) {
                                        var b = _.value,
                                            w = r.get(b.index).material;
                                        if (pT(w)) {
                                            var M = this.writer.processMaterial(w);
                                            a.has(M) || a.set(M, {
                                                material: M,
                                                variants: []
                                            }), a.get(M).variants.push(o.get(b.index))
                                        }
                                    }
                                } catch (e) {
                                    g = !0, y = e
                                } finally {
                                    try {
                                        v || null == x.return || x.return()
                                    } finally {
                                        if (g) throw y
                                    }
                                }
                                var S = Array.from(a.values()).map(function(e) {
                                    return e.variants.sort(function(e, t) {
                                        return e - t
                                    }) && e
                                }).sort(function(e, t) {
                                    return e.material - t.material
                                });
                                if (0 !== S.length) {
                                    var T = pT(n.originalMaterial) ? this.writer.processMaterial(n.originalMaterial) : -1,
                                        E = !0,
                                        k = !1,
                                        A = void 0;
                                    try {
                                        for (var R, C = t.primitives[Symbol.iterator](); !(E = (R = C.next()).done); E = !0) {
                                            var L = R.value;
                                            T >= 0 && (L.material = T), L.extensions = L.extensions || {}, L.extensions[this.name] = {
                                                mappings: S
                                            }
                                        }
                                    } catch (e) {
                                        k = !0, A = e
                                    } finally {
                                        try {
                                            E || null == C.return || C.return()
                                        } finally {
                                            if (k) throw A
                                        }
                                    }
                                }
                            }
                        }
                    }, {
                        key: "afterParse",
                        value: function() {
                            if (0 !== this.variantNames.length) {
                                var e = this.writer.json;
                                e.extensions = e.extensions || {};
                                var t = this.variantNames.map(function(e) {
                                    return {
                                        name: e
                                    }
                                });
                                e.extensions[this.name] = {
                                    variants: t
                                }, this.writer.extensionsUsed[this.name] = !0
                            }
                        }
                    }]), e
                }(),
                pk = Symbol("correlatedObjects"),
                pA = Symbol("sourceObject"),
                pR = Symbol("onUpdate"),
                pC = function e(t, n) {
                    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                    (0, k._)(this, e), this[pR] = t, this[pA] = n, this[pk] = r
                },
                pL = new sx,
                pP = new n_,
                pI = new rl(2, 2),
                pD = 0,
                pO = Symbol("threeTexture"),
                pN = function(e) {
                    function t(e, n, r) {
                        return (0, k._)(this, t), (0, E._)(this, t, [e, r = null != r ? r : {
                            name: "adhoc_image",
                            uri: n && n.image && n.image.src ? n.image.src : "adhoc_image" + pD++
                        }, new Set(n ? [n] : [])])
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: pO,
                        get: function() {
                            var e;
                            return console.assert(null != this[pk] && this[pk].size > 0, "Image correlated object is undefined"), null === (e = this[pk]) || void 0 === e ? void 0 : e.values().next().value
                        }
                    }, {
                        key: "name",
                        get: function() {
                            return this[pA].name || ""
                        }
                    }, {
                        key: "uri",
                        get: function() {
                            return this[pA].uri
                        }
                    }, {
                        key: "bufferView",
                        get: function() {
                            return this[pA].bufferView
                        }
                    }, {
                        key: "type",
                        get: function() {
                            return null != this.uri ? "external" : "embedded"
                        }
                    }, {
                        key: "setURI",
                        value: function(e) {
                            var t = this;
                            return (0, T._)(function() {
                                var n, r;
                                return (0, z.YH)(this, function(i) {
                                    switch (i.label) {
                                        case 0:
                                            return t[pA].uri = e, [4, new Promise(function(t, n) {
                                                pL.load(e, t, void 0, n)
                                            })];
                                        case 1:
                                            return n = i.sent(), (r = t[pO]).image = n, r.needsUpdate = !0, t[pR](), [2]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "createThumbnail",
                        value: function(e, t) {
                            var n = this;
                            return (0, T._)(function() {
                                var r, i, a, o, s, l, u, c;
                                return (0, z.YH)(this, function(h) {
                                    var d;
                                    return r = new aC, pP.map = n[pO], i = new nK(pI, pP), r.add(i), a = new ry(-1, 1, 1, -1, 0, 1), o = cM.singleton.threeRenderer, s = new tr(e, t), o.setRenderTarget(s), o.render(r, a), o.setRenderTarget(null), l = new Uint8Array(e * t * 4), o.readRenderTargetPixels(s, 0, 0, e, t, l), cX.width = e, cX.height = t, [2, ((c = (u = cX.getContext("2d")).createImageData(e, t)).data.set(l), u.putImageData(c, 0, 0), new Promise((d = (0, T._)(function(e, t) {
                                        return (0, z.YH)(this, function(n) {
                                            return cX.toBlob(function(n) {
                                                if (!n) return t("Failed to capture thumbnail.");
                                                e(URL.createObjectURL(n))
                                            }, "image/png"), [2]
                                        })
                                    }), function(e, t) {
                                        return d.apply(this, arguments)
                                    })))]
                                })
                            })()
                        }
                    }]), t
                }(pC);
            ! function(e) {
                e[e.Nearest = 9728] = "Nearest", e[e.Linear = 9729] = "Linear", e[e.NearestMipmapNearest = 9984] = "NearestMipmapNearest", e[e.LinearMipmapNearest = 9985] = "LinearMipmapNearest", e[e.NearestMipmapLinear = 9986] = "NearestMipmapLinear", e[e.LinearMipmapLinear = 9987] = "LinearMipmapLinear"
            }(h || (h = {})),
            function(e) {
                e[e.ClampToEdge = 33071] = "ClampToEdge", e[e.MirroredRepeat = 33648] = "MirroredRepeat", e[e.Repeat = 10497] = "Repeat"
            }(d || (d = {}));
            var pF = function() {
                    var e = [h.Nearest, h.Linear, h.NearestMipmapNearest, h.LinearMipmapLinear, h.NearestMipmapLinear, h.LinearMipmapLinear];
                    return function(t) {
                        return e.indexOf(t) > -1
                    }
                }(),
                pU = function() {
                    var e = [h.Nearest, h.Linear];
                    return function(t) {
                        return e.indexOf(t) > -1
                    }
                }(),
                pB = function() {
                    var e = [d.ClampToEdge, d.MirroredRepeat, d.Repeat];
                    return function(t) {
                        return e.indexOf(t) > -1
                    }
                }(),
                pz = Symbol("threeTextures"),
                pH = Symbol("setProperty"),
                pV = Symbol("sourceSampler"),
                pG = function(e) {
                    function t(e, n, r) {
                        return (0, k._)(this, t), null == (r = null != r ? r : {}).minFilter && (r.minFilter = n ? n.minFilter : h.LinearMipmapLinear), null == r.magFilter && (r.magFilter = n ? n.magFilter : h.Linear), null == r.wrapS && (r.wrapS = n ? n.wrapS : d.Repeat), null == r.wrapT && (r.wrapT = n ? n.wrapT : d.Repeat), (0, E._)(this, t, [e, r, new Set(n ? [n] : [])])
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: pz,
                        get: function() {
                            return console.assert(null != this[pk] && this[pk].size > 0, "Sampler correlated object is undefined"), this[pk]
                        }
                    }, {
                        key: pV,
                        get: function() {
                            return console.assert(null != this[pA], "Sampler source is undefined"), this[pA]
                        }
                    }, {
                        key: "name",
                        get: function() {
                            return this[pA].name || ""
                        }
                    }, {
                        key: "minFilter",
                        get: function() {
                            return this[pV].minFilter
                        }
                    }, {
                        key: "magFilter",
                        get: function() {
                            return this[pV].magFilter
                        }
                    }, {
                        key: "wrapS",
                        get: function() {
                            return this[pV].wrapS
                        }
                    }, {
                        key: "wrapT",
                        get: function() {
                            return this[pV].wrapT
                        }
                    }, {
                        key: "setMinFilter",
                        value: function(e) {
                            this[pH]("minFilter", e)
                        }
                    }, {
                        key: "setMagFilter",
                        value: function(e) {
                            this[pH]("magFilter", e)
                        }
                    }, {
                        key: "setWrapS",
                        value: function(e) {
                            this[pH]("wrapS", e)
                        }
                    }, {
                        key: "setWrapT",
                        value: function(e) {
                            this[pH]("wrapT", e)
                        }
                    }, {
                        key: pH,
                        value: function(e, t) {
                            var n = this[pV];
                            if (null != n) {
                                if (function(e, t) {
                                        switch (e) {
                                            case "minFilter":
                                                return pF(t);
                                            case "magFilter":
                                                return pU(t);
                                            case "wrapS":
                                            case "wrapT":
                                                return pB(t);
                                            default:
                                                throw Error('Cannot configure property "'.concat(e, '" on Sampler'))
                                        }
                                    }(e, t)) {
                                    n[e] = t;
                                    var r = !0,
                                        i = !1,
                                        a = void 0;
                                    try {
                                        for (var o, s = this[pz][Symbol.iterator](); !(r = (o = s.next()).done); r = !0) {
                                            var l = o.value;
                                            l[e] = t, l.needsUpdate = !0
                                        }
                                    } catch (e) {
                                        i = !0, a = e
                                    } finally {
                                        try {
                                            r || null == s.return || s.return()
                                        } finally {
                                            if (i) throw a
                                        }
                                    }
                                }
                                this[pR]()
                            }
                        }
                    }]), t
                }(pC),
                pW = Symbol("image"),
                pj = Symbol("sampler"),
                pq = function(e) {
                    function t(e, n) {
                        var r, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                            o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
                        return (0, k._)(this, t), (r = (0, E._)(this, t, [e, i || {}, new Set(n ? [n] : [])]))[pj] = new pG(e, n, a), r[pW] = new pN(e, n, o), r
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: "name",
                        get: function() {
                            return this[pA].name || ""
                        }
                    }, {
                        key: "sampler",
                        get: function() {
                            return this[pj]
                        }
                    }, {
                        key: "source",
                        get: function() {
                            return this[pW]
                        }
                    }]), t
                }(pC),
                pX = Symbol("texture"),
                pY = Symbol("materials"),
                pJ = Symbol("usage");
            ! function(e) {
                e[e.Base = 0] = "Base", e[e.MetallicRoughness = 1] = "MetallicRoughness", e[e.Normal = 2] = "Normal", e[e.Occlusion = 3] = "Occlusion", e[e.Emissive = 4] = "Emissive"
            }(p || (p = {}));
            var pZ = function() {
                function e(t, n, r, i, a, o) {
                    if ((0, k._)(this, e), this[f] = null, o) {
                        var s = a.textures ? a.textures[o.index] : null,
                            l = s && a.samplers ? a.samplers[s.sampler] : null,
                            u = s && a.images ? a.images[s.source] : null;
                        this[pX] = new pq(t, r, s, l, u)
                    }
                    this.onUpdate = t, this[pY] = i, this[pJ] = n
                }
                return (0, A._)(e, [{
                    key: "texture",
                    get: function() {
                        return this[pX]
                    }
                }, {
                    key: "setTexture",
                    value: function(e) {
                        var t = null != e ? e.source[pO] : null,
                            n = 3001,
                            r = !0,
                            i = !1,
                            a = void 0;
                        if (this[pX] = e, this[pY]) try {
                            for (var o, s = this[pY][Symbol.iterator](); !(r = (o = s.next()).done); r = !0) {
                                var l = o.value;
                                switch (this[pJ]) {
                                    case p.Base:
                                        l.map = t;
                                        break;
                                    case p.MetallicRoughness:
                                        n = 3e3, l.metalnessMap = t, l.roughnessMap = t;
                                        break;
                                    case p.Normal:
                                        n = 3e3, l.normalMap = t;
                                        break;
                                    case p.Occlusion:
                                        n = 3e3, l.aoMap = t;
                                        break;
                                    case p.Emissive:
                                        l.emissiveMap = t
                                }
                                l.needsUpdate = !0
                            }
                        } catch (e) {
                            i = !0, a = e
                        } finally {
                            try {
                                r || null == s.return || s.return()
                            } finally {
                                if (i) throw a
                            }
                        }
                        t && (t.encoding = n), this.onUpdate()
                    }
                }]), e
            }();
            f = pX;
            var pK = Symbol("threeMaterials"),
                pQ = Symbol("baseColorTexture"),
                p$ = Symbol("metallicRoughnessTexture"),
                p0 = function(e) {
                    function t(e, n, r, i) {
                        (0, k._)(this, t), a = (0, E._)(this, t, [e, r, i]), null == r.baseColorFactor && (r.baseColorFactor = [1, 1, 1, 1]), null == r.roughnessFactor && (r.roughnessFactor = 1), null == r.metallicFactor && (r.metallicFactor = 1);
                        var a, o = r.baseColorTexture,
                            s = r.metallicRoughnessTexture,
                            l = i.values().next().value,
                            u = l.map,
                            c = l.metalnessMap;
                        return a[pQ] = new pZ(e, p.Base, u, i, n, o || null), a[p$] = new pZ(e, p.MetallicRoughness, c, i, n, s || null), a
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: pK,
                        get: function() {
                            return this[pk]
                        }
                    }, {
                        key: "baseColorFactor",
                        get: function() {
                            return this[pA].baseColorFactor
                        }
                    }, {
                        key: "metallicFactor",
                        get: function() {
                            return this[pA].metallicFactor
                        }
                    }, {
                        key: "roughnessFactor",
                        get: function() {
                            return this[pA].roughnessFactor
                        }
                    }, {
                        key: "baseColorTexture",
                        get: function() {
                            return this[pQ]
                        }
                    }, {
                        key: "metallicRoughnessTexture",
                        get: function() {
                            return this[p$]
                        }
                    }, {
                        key: "setBaseColorFactor",
                        value: function(e) {
                            var t = !0,
                                n = !1,
                                r = void 0;
                            try {
                                for (var i, a = this[pK][Symbol.iterator](); !(t = (i = a.next()).done); t = !0) {
                                    var o = i.value;
                                    o.color.fromArray(e), o.opacity = e[3]
                                }
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == a.return || a.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                            this[pA].baseColorFactor = e, this[pR]()
                        }
                    }, {
                        key: "setMetallicFactor",
                        value: function(e) {
                            var t = !0,
                                n = !1,
                                r = void 0;
                            try {
                                for (var i, a = this[pK][Symbol.iterator](); !(t = (i = a.next()).done); t = !0) i.value.metalness = e
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == a.return || a.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                            this[pA].metallicFactor = e, this[pR]()
                        }
                    }, {
                        key: "setRoughnessFactor",
                        value: function(e) {
                            var t = !0,
                                n = !1,
                                r = void 0;
                            try {
                                for (var i, a = this[pK][Symbol.iterator](); !(t = (i = a.next()).done); t = !0) i.value.roughness = e
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == a.return || a.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                            this[pA].roughnessFactor = e, this[pR]()
                        }
                    }]), t
                }(pC),
                p1 = Symbol("pbrMetallicRoughness"),
                p2 = Symbol("normalTexture"),
                p3 = Symbol("occlusionTexture"),
                p4 = Symbol("emissiveTexture"),
                p5 = Symbol("backingThreeMaterial"),
                p6 = Symbol("applyAlphaCutoff"),
                p8 = Symbol("lazyLoadGLTFInfo"),
                p7 = Symbol("initialize"),
                p9 = Symbol("getLoadedMaterial"),
                me = Symbol("ensureMaterialIsLoaded"),
                mt = Symbol("gltfIndex"),
                mn = Symbol("setActive"),
                mr = Symbol("variantIndices"),
                mi = Symbol("isActive"),
                ma = Symbol("variantSet"),
                mo = Symbol("modelVariants"),
                ms = function(e) {
                    function t(e, n, r, i, a, o, s, l) {
                        var u;
                        return (0, k._)(this, t), (u = (0, E._)(this, t, [e, r, s]))[m] = new Set, u[mt] = i, u[mi] = a, u[mo] = o, null == l ? u[p7](n) : u[p8] = l, u
                    }
                    return (0, P._)(t, e), (0, A._)(t, [{
                        key: (m = ma, p5),
                        get: function() {
                            return this[pk].values().next().value
                        }
                    }, {
                        key: p7,
                        value: function(e) {
                            var t = this[pR],
                                n = this[pA],
                                r = this[pk];
                            n.extensions && n.extensions.KHR_materials_pbrSpecularGlossiness && console.warn("Material ".concat(n.name, ' uses a deprecated extension\n          "KHR_materials_pbrSpecularGlossiness", please use\n          "pbrMetallicRoughness" instead. Specular Glossiness materials are\n          currently supported for rendering, but not for our scene-graph API,\n          nor for auto-generation of USDZ for Quick Look.')), null == n.pbrMetallicRoughness && (n.pbrMetallicRoughness = {}), this[p1] = new p0(t, e, n.pbrMetallicRoughness, r), null == n.emissiveFactor && (n.emissiveFactor = [0, 0, 0]), null == n.doubleSided && (n.doubleSided = !1), null == n.alphaMode && (n.alphaMode = "OPAQUE"), null == n.alphaCutoff && (n.alphaCutoff = .5);
                            var i = n.normalTexture,
                                a = n.occlusionTexture,
                                o = n.emissiveTexture,
                                s = r.values().next().value,
                                l = s.normalMap,
                                u = s.aoMap,
                                c = s.emissiveMap;
                            this[p2] = new pZ(t, p.Normal, l, r, e, i || null), this[p3] = new pZ(t, p.Occlusion, u, r, e, a || null), this[p4] = new pZ(t, p.Emissive, c, r, e, o || null)
                        }
                    }, {
                        key: p9,
                        value: function() {
                            var e = this;
                            return (0, T._)(function() {
                                var t, n, r;
                                return (0, z.YH)(this, function(i) {
                                    switch (i.label) {
                                        case 0:
                                            if (!(null != e[p8])) return [3, 2];
                                            return [4, e[p8].doLazyLoad()];
                                        case 1:
                                            return n = (t = i.sent()).set, r = t.material, [2, (e[pk] = n, e[p7](e[p8].gltf), e[p8] = void 0, e.ensureLoaded = (0, T._)(function() {
                                                return (0, z.YH)(this, function(e) {
                                                    return [2]
                                                })
                                            }), r)];
                                        case 2:
                                            return [2, e[pk].values().next().value]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: me,
                        value: function() {
                            if (null != this[p8]) throw Error('Material "'.concat(this.name, "\" has not been loaded, call 'await\n    myMaterial.ensureLoaded()' before using an unloaded material."))
                        }
                    }, {
                        key: "ensureLoaded",
                        value: function() {
                            var e = this;
                            return (0, T._)(function() {
                                return (0, z.YH)(this, function(t) {
                                    switch (t.label) {
                                        case 0:
                                            return [4, e[p9]()];
                                        case 1:
                                            return t.sent(), [2]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: "isLoaded",
                        get: function() {
                            return null == this[p8]
                        }
                    }, {
                        key: "isActive",
                        get: function() {
                            return this[mi]
                        }
                    }, {
                        key: mn,
                        value: function(e) {
                            this[mi] = e
                        }
                    }, {
                        key: "name",
                        get: function() {
                            return this[pA].name
                        },
                        set: function(e) {
                            var t = this[pA],
                                n = !0,
                                r = !1,
                                i = void 0;
                            if (null != t && (t.name = e), null != this[pk]) try {
                                for (var a, o = this[pk][Symbol.iterator](); !(n = (a = o.next()).done); n = !0) a.value.name = e
                            } catch (e) {
                                r = !0, i = e
                            } finally {
                                try {
                                    n || null == o.return || o.return()
                                } finally {
                                    if (r) throw i
                                }
                            }
                        }
                    }, {
                        key: "pbrMetallicRoughness",
                        get: function() {
                            return this[me](), this[p1]
                        }
                    }, {
                        key: "normalTexture",
                        get: function() {
                            return this[me](), this[p2]
                        }
                    }, {
                        key: "occlusionTexture",
                        get: function() {
                            return this[me](), this[p3]
                        }
                    }, {
                        key: "emissiveTexture",
                        get: function() {
                            return this[me](), this[p4]
                        }
                    }, {
                        key: "emissiveFactor",
                        get: function() {
                            return this[me](), this[pA].emissiveFactor
                        }
                    }, {
                        key: "index",
                        get: function() {
                            return this[mt]
                        }
                    }, {
                        key: mr,
                        value: function() {
                            return this[ma]
                        }
                    }, {
                        key: "hasVariant",
                        value: function(e) {
                            var t = this[mo].get(e);
                            return null != t && this[ma].has(t.index)
                        }
                    }, {
                        key: "setEmissiveFactor",
                        value: function(e) {
                            this[me]();
                            var t = !0,
                                n = !1,
                                r = void 0;
                            try {
                                for (var i, a = this[pk][Symbol.iterator](); !(t = (i = a.next()).done); t = !0) i.value.emissive.fromArray(e)
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == a.return || a.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                            this[pA].emissiveFactor = e, this[pR]()
                        }
                    }, {
                        key: p6,
                        value: function() {
                            this[me]();
                            var e = this[pA],
                                t = !0,
                                n = !1,
                                r = void 0;
                            try {
                                for (var i, a = this[pk][Symbol.iterator](); !(t = (i = a.next()).done); t = !0) {
                                    var o = i.value;
                                    "MASK" === this[pA].alphaMode ? o.alphaTest = e.alphaCutoff : o.alphaTest = void 0, o.needsUpdate = !0
                                }
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == a.return || a.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                        }
                    }, {
                        key: "setAlphaCutoff",
                        value: function(e) {
                            this[me](), this[pA].alphaCutoff = e, this[p6](), this[pR]()
                        }
                    }, {
                        key: "getAlphaCutoff",
                        value: function() {
                            return this[me](), this[pA].alphaCutoff
                        }
                    }, {
                        key: "setDoubleSided",
                        value: function(e) {
                            this[me]();
                            var t = !0,
                                n = !1,
                                r = void 0;
                            try {
                                for (var i, a = this[pk][Symbol.iterator](); !(t = (i = a.next()).done); t = !0) {
                                    var o = i.value;
                                    o.side = e ? 2 : 0, o.needsUpdate = !0
                                }
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == a.return || a.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                            this[pA].doubleSided = e, this[pR]()
                        }
                    }, {
                        key: "getDoubleSided",
                        value: function() {
                            return this[me](), this[pA].doubleSided
                        }
                    }, {
                        key: "setAlphaMode",
                        value: function(e) {
                            this[me](), this[pA].alphaMode = e;
                            var t = !0,
                                n = !1,
                                r = void 0;
                            try {
                                for (var i, a = this[pk][Symbol.iterator](); !(t = (i = a.next()).done); t = !0) {
                                    var o, s = i.value;
                                    o = "OPAQUE" !== e, s.transparent = o, s.depthWrite = !o, this[p6](), s.needsUpdate = !0
                                }
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == a.return || a.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                            this[pR]()
                        }
                    }, {
                        key: "getAlphaMode",
                        value: function() {
                            return this[me](), this[pA].alphaMode
                        }
                    }]), t
                }(pC),
                ml = Symbol("materials"),
                mu = Symbol("variantToMaterialMap"),
                mc = Symbol("modelVariants"),
                mh = Symbol("mesh"),
                md = Symbol("children"),
                mf = Symbol("initialMaterialIdx"),
                mp = Symbol("activeMaterialIdx"),
                mm = function e(t) {
                    (0, k._)(this, e), this.name = "", this[v] = [], this.name = t
                };
            v = md;
            var mv = function(e) {
                function t(e, n, r, i) {
                    (0, k._)(this, t), (_ = (0, E._)(this, t, [e.name]))[g] = new Map, _[y] = new Map, _[mh] = e;
                    var a = i.gltf,
                        o = i.threeGLTF,
                        s = i.threeObjectMap;
                    _[mc] = r, _.mesh.userData.variantData = r;
                    var l = s.get(e.material);
                    null != l.materials ? _[mf] = _[mp] = l.materials : console.error("Primitive (".concat(e.name, ") missing initial material reference."));
                    var u = e.userData.associations || {};
                    if (null == u.meshes) return (0, D._)(_, void console.error("Mesh is missing primitive index association"));
                    var c = ((a.meshes || [])[u.meshes].primitives || [])[u.primitives];
                    if (null != c) {
                        if (null != c.material) _[ml].set(c.material, n[c.material]);
                        else {
                            var h = n.findIndex(function(e) {
                                return "Default" === e.name
                            });
                            h >= 0 ? _[ml].set(h, n[h]) : console.warn("gltfPrimitive has no material!")
                        }
                        if (c.extensions && c.extensions.KHR_materials_variants) {
                            var d = c.extensions.KHR_materials_variants,
                                f = o.parser.json.extensions.KHR_materials_variants.variants,
                                p = !0,
                                m = !1,
                                v = void 0;
                            try {
                                for (var _, x, b = d.mappings[Symbol.iterator](); !(p = (x = b.next()).done); p = !0) {
                                    var w = x.value,
                                        M = n[w.material];
                                    _[ml].set(w.material, M);
                                    var S = !0,
                                        T = !1,
                                        A = void 0;
                                    try {
                                        for (var R, C = w.variants[Symbol.iterator](); !(S = (R = C.next()).done); S = !0) {
                                            var L = R.value,
                                                P = f[L].name;
                                            _[mu].set(L, M), M[mr]().add(L), r.has(P) || r.set(P, {
                                                name: P,
                                                index: L
                                            })
                                        }
                                    } catch (e) {
                                        T = !0, A = e
                                    } finally {
                                        try {
                                            S || null == C.return || C.return()
                                        } finally {
                                            if (T) throw A
                                        }
                                    }
                                }
                            } catch (e) {
                                m = !0, v = e
                            } finally {
                                try {
                                    p || null == b.return || b.return()
                                } finally {
                                    if (m) throw v
                                }
                            }
                        }
                    } else console.error("Mesh primitive definition is missing.");
                    return _
                }
                return (0, P._)(t, e), (0, A._)(t, [{
                    key: "mesh",
                    get: function() {
                        return this[mh]
                    }
                }, {
                    key: "setActiveMaterial",
                    value: function(e) {
                        var t = this;
                        return (0, T._)(function() {
                            var n, r;
                            return (0, z.YH)(this, function(i) {
                                switch (i.label) {
                                    case 0:
                                        if (!(null != (n = t[ml].get(e)))) return [3, 2];
                                        return r = t.mesh, [4, n[p9]()];
                                    case 1:
                                        r.material = i.sent(), t[mp] = e, i.label = 2;
                                    case 2:
                                        return [2, t.mesh.material]
                                }
                            })
                        })()
                    }
                }, {
                    key: "getActiveMaterial",
                    value: function() {
                        return this[ml].get(this[mp])
                    }
                }, {
                    key: "getMaterial",
                    value: function(e) {
                        return this[ml].get(e)
                    }
                }, {
                    key: "enableVariant",
                    value: function(e) {
                        var t = this;
                        return (0, T._)(function() {
                            var n;
                            return (0, z.YH)(this, function(r) {
                                return null == e ? [2, t.setActiveMaterial(t[mf])] : null != t[mu] && t[mc].has(e) ? (n = t[mc].get(e), [2, t.enableVariantHelper(n.index)]) : [2, null]
                            })
                        })()
                    }
                }, {
                    key: "enableVariantHelper",
                    value: function(e) {
                        var t = this;
                        return (0, T._)(function() {
                            var n;
                            return (0, z.YH)(this, function(r) {
                                return null != t[mu] && null != e && null != (n = t[mu].get(e)) ? [2, t.setActiveMaterial(n.index)] : [2, null]
                            })
                        })()
                    }
                }, {
                    key: "instantiateVariants",
                    value: function() {
                        var e = this;
                        return (0, T._)(function() {
                            var t, n, r, i, a, o, s, l;
                            return (0, z.YH)(this, function(u) {
                                switch (u.label) {
                                    case 0:
                                        if (t = !0, n = !1, r = void 0, !(null != e[mu])) return [3, 8];
                                        u.label = 1;
                                    case 1:
                                        u.trys.push([1, 6, 7, 8]), i = e[mu].keys()[Symbol.iterator](), u.label = 2;
                                    case 2:
                                        if (t = (a = i.next()).done) return [3, 5];
                                        if (o = a.value, null != e.mesh.userData.variantMaterials.get(o).material) return [3, 4];
                                        return [4, e.enableVariantHelper(o)];
                                    case 3:
                                        null != (s = u.sent()) && (e.mesh.userData.variantMaterials.get(o).material = s), u.label = 4;
                                    case 4:
                                        return t = !0, [3, 2];
                                    case 5:
                                        return [3, 8];
                                    case 6:
                                        return l = u.sent(), n = !0, r = l, [3, 8];
                                    case 7:
                                        try {
                                            t || null == i.return || i.return()
                                        } finally {
                                            if (n) throw r
                                        }
                                        return [7];
                                    case 8:
                                        return [2]
                                }
                            })
                        })()
                    }
                }, {
                    key: "variantInfo",
                    get: function() {
                        return this[mu]
                    }
                }, {
                    key: "addVariant",
                    value: function(e, t) {
                        if (!this.ensureVariantIsUnused(t)) return !1;
                        this[mc].has(t) || this[mc].set(t, {
                            name: t,
                            index: this[mc].size
                        });
                        var n = this[mc].get(t).index;
                        return e[mr]().add(n), this[mu].set(n, e), this[ml].set(e.index, e), this.updateVariantUserData(n, e), !0
                    }
                }, {
                    key: "deleteVariant",
                    value: function(e) {
                        if (this.variantInfo.has(e)) {
                            this.variantInfo.delete(e);
                            var t = this.mesh.userData.variantMaterials;
                            null != t && t.delete(e)
                        }
                    }
                }, {
                    key: "updateVariantUserData",
                    value: function(e, t) {
                        t[mr]().add(e), this.mesh.userData.variantData = this[mc], this.mesh.userData.variantMaterials = this.mesh.userData.variantMaterials || new Map, this.mesh.userData.variantMaterials.set(e, {
                            material: t[pk].values().next().value,
                            gltfMaterialIndex: t.index
                        })
                    }
                }, {
                    key: "ensureVariantIsUnused",
                    value: function(e) {
                        var t = this[mc].get(e);
                        return null == t || !this.variantInfo.has(t.index) || (console.warn("Primitive cannot add variant '".concat(e, "' for this material, it already exists.")), !1)
                    }
                }]), t
            }(mm);
            g = ml, y = mu;
            var mg = Symbol("materials"),
                my = Symbol("hierarchy"),
                m_ = Symbol("roots"),
                mx = Symbol("primitives"),
                mb = Symbol("correlatedSceneGraph"),
                mw = Symbol("prepareVariantsForExport"),
                mM = Symbol("switchVariant"),
                mS = Symbol("threeScene"),
                mT = Symbol("materialsFromPoint"),
                mE = Symbol("materialFromPoint"),
                mk = Symbol("variantData"),
                mA = Symbol("availableVariants"),
                mR = Symbol("modelOnUpdate"),
                mC = Symbol("cloneMaterial"),
                mL = function e(t, n, r, i) {
                    (0, k._)(this, e), this.gltf = t, this.gltfElementMap = n, this.mapKey = r, this.doLazyLoad = i
                },
                mP = function() {
                    function e(t) {
                        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function() {};
                        (0, k._)(this, e), this[_] = [], this[x] = [], this[b] = [], this[w] = [], this[M] = function() {}, this[S] = new Map, this[mR] = n, this[mb] = t;
                        var r = t.gltf,
                            i = t.threeGLTF,
                            a = t.gltfElementMap;
                        this[mS] = i.scene;
                        var o = !0,
                            s = !1,
                            l = void 0;
                        try {
                            for (var u, c, h = r.materials.entries()[Symbol.iterator](); !(o = (c = h.next()).done); o = !0) u = this,
                                function() {
                                    var e = (0, O._)(c.value, 2),
                                        t = e[0],
                                        o = e[1],
                                        s = a.get(o);
                                    if (null != s) u[mg].push(new ms(n, r, o, t, !0, u[mk], s));
                                    else {
                                        var l, h = (r.materials || [])[t],
                                            d = (l = (0, T._)(function() {
                                                var e, n;
                                                return (0, z.YH)(this, function(r) {
                                                    switch (r.label) {
                                                        case 0:
                                                            return [4, i.parser.getDependency("material", t)];
                                                        case 1:
                                                            return e = r.sent(), n = new Set, [2, (a.set(h, n), n.add(e), {
                                                                set: n,
                                                                material: e
                                                            })]
                                                    }
                                                })
                                            }), function() {
                                                return l.apply(this, arguments)
                                            });
                                        u[mg].push(new ms(n, r, h, t, !1, u[mk], s, new mL(r, a, h, d)))
                                    }
                                }()
                        } catch (e) {
                            s = !0, l = e
                        } finally {
                            try {
                                o || null == h.return || h.return()
                            } finally {
                                if (s) throw l
                            }
                        }
                        var d = new Map,
                            f = [],
                            p = !0,
                            m = !1,
                            v = void 0;
                        try {
                            for (var g, y = i.scene.children[Symbol.iterator](); !(p = (g = y.next()).done); p = !0) {
                                var E = g.value;
                                f.push(E)
                            }
                        } catch (e) {
                            m = !0, v = e
                        } finally {
                            try {
                                p || null == y.return || y.return()
                            } finally {
                                if (m) throw v
                            }
                        }
                        for (; f.length > 0;) {
                            var A = f.pop(),
                                R = null;
                            A instanceof nK ? (R = new mv(A, this.materials, this[mk], t), this[mx].push(R)) : R = new mm(A.name);
                            var C = d.get(A);
                            null != C ? C[md].push(R) : this[m_].push(R), this[my].push(R);
                            var L = !0,
                                P = !1,
                                I = void 0;
                            try {
                                for (var D, N = A.children[Symbol.iterator](); !(L = (D = N.next()).done); L = !0) {
                                    var F = D.value;
                                    f.push(F), d.set(A, R)
                                }
                            } catch (e) {
                                P = !0, I = e
                            } finally {
                                try {
                                    L || null == N.return || N.return()
                                } finally {
                                    if (P) throw I
                                }
                            }
                        }
                    }
                    return (0, A._)(e, [{
                        key: "materials",
                        get: function() {
                            return this[mg]
                        }
                    }, {
                        key: (_ = mg, x = my, b = m_, w = mx, M = mR, S = mk, mA),
                        value: function() {
                            var e = Array.from(this[mk].values());
                            return e.sort(function(e, t) {
                                return e.index - t.index
                            }), e.map(function(e) {
                                return e.name
                            })
                        }
                    }, {
                        key: "getMaterialByName",
                        value: function(e) {
                            var t = this[mg].filter(function(t) {
                                return t.name === e
                            });
                            return t.length > 0 ? t[0] : null
                        }
                    }, {
                        key: mT,
                        value: function(e) {
                            var t = this;
                            return e.intersectObject(this[mS], !0).map(function(e) {
                                var n = t[my].find(function(t) {
                                    return t instanceof mv && t.mesh === e.object
                                });
                                return null != n ? n.getActiveMaterial() : null
                            })
                        }
                    }, {
                        key: mE,
                        value: function(e) {
                            var t = this[mT](e);
                            return t.length > 0 ? t[0] : null
                        }
                    }, {
                        key: mM,
                        value: function(e) {
                            var t = this;
                            return (0, T._)(function() {
                                var n, r, i, a, o, s, l, u, c, h, d, f, p, m, v, g, y;
                                return (0, z.YH)(this, function(_) {
                                    switch (_.label) {
                                        case 0:
                                            n = !0, r = !1, i = void 0, _.label = 1;
                                        case 1:
                                            _.trys.push([1, 6, 7, 8]), a = t[mx][Symbol.iterator](), _.label = 2;
                                        case 2:
                                            if (n = (o = a.next()).done) return [3, 5];
                                            return [4, o.value.enableVariant(e)];
                                        case 3:
                                            _.sent(), _.label = 4;
                                        case 4:
                                            return n = !0, [3, 2];
                                        case 5:
                                            return [3, 8];
                                        case 6:
                                            return s = _.sent(), r = !0, i = s, [3, 8];
                                        case 7:
                                            try {
                                                n || null == a.return || a.return()
                                            } finally {
                                                if (r) throw i
                                            }
                                            return [7];
                                        case 8:
                                            l = !0, u = !1, c = void 0;
                                            try {
                                                for (h = t.materials[Symbol.iterator](); !(l = (d = h.next()).done); l = !0) d.value[mn](!1)
                                            } catch (e) {
                                                u = !0, c = e
                                            } finally {
                                                try {
                                                    l || null == h.return || h.return()
                                                } finally {
                                                    if (u) throw c
                                                }
                                            }
                                            f = !0, p = !1, m = void 0;
                                            try {
                                                for (v = t[mx][Symbol.iterator](); !(f = (g = v.next()).done); f = !0) y = g.value, t.materials[y.getActiveMaterial().index][mn](!0)
                                            } catch (e) {
                                                p = !0, m = e
                                            } finally {
                                                try {
                                                    f || null == v.return || v.return()
                                                } finally {
                                                    if (p) throw m
                                                }
                                            }
                                            return [2]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: mw,
                        value: function() {
                            var e = this;
                            return (0, T._)(function() {
                                var t, n, r, i, a, o, s;
                                return (0, z.YH)(this, function(l) {
                                    switch (l.label) {
                                        case 0:
                                            t = [], n = !0, r = !1, i = void 0;
                                            try {
                                                for (a = e[mx][Symbol.iterator](); !(n = (o = a.next()).done); n = !0) s = o.value, t.push(s.instantiateVariants())
                                            } catch (e) {
                                                r = !0, i = e
                                            } finally {
                                                try {
                                                    n || null == a.return || a.return()
                                                } finally {
                                                    if (r) throw i
                                                }
                                            }
                                            return [4, Promise.all(t)];
                                        case 1:
                                            return l.sent(), [2]
                                    }
                                })
                            })()
                        }
                    }, {
                        key: mC,
                        value: function(e, t) {
                            var n = this.materials[e];
                            n.isLoaded || console.error("Cloning an unloaded material,\n           call 'material.ensureLoaded() before cloning the material.");
                            var r = n[pk],
                                i = JSON.parse(JSON.stringify(n[pA]));
                            i.name = t, this[mb].gltf.materials.push(i);
                            var a = new Set,
                                o = !0,
                                s = !1,
                                l = void 0;
                            try {
                                for (var u, c = r.entries()[Symbol.iterator](); !(o = (u = c.next()).done); o = !0) {
                                    var h = (0, O._)(u.value, 2),
                                        d = h[0],
                                        f = h[1].clone();
                                    f.name = t + (r.size > 1 ? "_inst" + d : ""), a.add(f)
                                }
                            } catch (e) {
                                s = !0, l = e
                            } finally {
                                try {
                                    o || null == c.return || c.return()
                                } finally {
                                    if (s) throw l
                                }
                            }
                            var p = new ms(this[mR], this[mb].gltf, i, this[mg].length, !1, this[mk], a);
                            return this[mg].push(p), p
                        }
                    }, {
                        key: "createMaterialInstanceForVariant",
                        value: function(e, t, n) {
                            var r = !(arguments.length > 3) || void 0 === arguments[3] || arguments[3],
                                i = null,
                                a = !0,
                                o = !1,
                                s = void 0;
                            try {
                                for (var l, u = this[mx][Symbol.iterator](); !(a = (l = u.next()).done); a = !0) {
                                    var c = l.value,
                                        h = this[mk].get(n);
                                    null != h && c.variantInfo.has(h.index) || null != c.getMaterial(e) && (this.hasVariant(n) || this.createVariant(n), null == i && (i = this[mC](e, t)), c.addVariant(i, n))
                                }
                            } catch (e) {
                                o = !0, s = e
                            } finally {
                                try {
                                    a || null == u.return || u.return()
                                } finally {
                                    if (o) throw s
                                }
                            }
                            if (r && null != i) {
                                i[mn](!0), this.materials[e][mn](!1);
                                var d = !0,
                                    f = !1,
                                    p = void 0;
                                try {
                                    for (var m, v = this[mx][Symbol.iterator](); !(d = (m = v.next()).done); d = !0) m.value.enableVariant(n)
                                } catch (e) {
                                    f = !0, p = e
                                } finally {
                                    try {
                                        d || null == v.return || v.return()
                                    } finally {
                                        if (f) throw p
                                    }
                                }
                            }
                            return i
                        }
                    }, {
                        key: "createVariant",
                        value: function(e) {
                            this[mk].has(e) ? console.warn("Variant '".concat(e, "'' already exists")) : this[mk].set(e, {
                                name: e,
                                index: this[mk].size
                            })
                        }
                    }, {
                        key: "hasVariant",
                        value: function(e) {
                            return this[mk].has(e)
                        }
                    }, {
                        key: "setMaterialToVariant",
                        value: function(e, t) {
                            var n = !0,
                                r = !1,
                                i = void 0;
                            if (null != this[mA]().find(function(e) {
                                    return e === t
                                })) {
                                if (e < 0 || e >= this.materials.length) console.error("setMaterialToVariant(): materialIndex is out of bounds.");
                                else try {
                                    for (var a, o = this[mx][Symbol.iterator](); !(n = (a = o.next()).done); n = !0) {
                                        var s = a.value,
                                            l = s.getMaterial(e);
                                        null != l && s.addVariant(l, t)
                                    }
                                } catch (e) {
                                    r = !0, i = e
                                } finally {
                                    try {
                                        n || null == o.return || o.return()
                                    } finally {
                                        if (r) throw i
                                    }
                                }
                            } else console.warn("Can't add material to '".concat(t, "', the variant does not exist.'"))
                        }
                    }, {
                        key: "updateVariantName",
                        value: function(e, t) {
                            var n = this[mk].get(e);
                            null != n && (n.name = t, this[mk].set(t, n), this[mk].delete(e))
                        }
                    }, {
                        key: "deleteVariant",
                        value: function(e) {
                            var t = this[mk].get(e);
                            if (null != t) {
                                var n = !0,
                                    r = !1,
                                    i = void 0;
                                try {
                                    for (var a, o = this.materials[Symbol.iterator](); !(n = (a = o.next()).done); n = !0) {
                                        var s = a.value;
                                        s.hasVariant(e) && s[ma].delete(t.index)
                                    }
                                } catch (e) {
                                    r = !0, i = e
                                } finally {
                                    try {
                                        n || null == o.return || o.return()
                                    } finally {
                                        if (r) throw i
                                    }
                                }
                                var l = !0,
                                    u = !1,
                                    c = void 0;
                                try {
                                    for (var h, d = this[mx][Symbol.iterator](); !(l = (h = d.next()).done); l = !0) h.value.deleteVariant(t.index)
                                } catch (e) {
                                    u = !0, c = e
                                } finally {
                                    try {
                                        l || null == d.return || d.return()
                                    } finally {
                                        if (u) throw c
                                    }
                                }
                                this[mk].delete(e)
                            }
                        }
                    }]), e
                }(),
                mI = function(e, t, n, r) {
                    for (var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r, s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o);
                    return a > 3 && o && Object.defineProperty(t, n, o), o
                },
                mD = Symbol("currentGLTF"),
                mO = Symbol("model"),
                mN = Symbol("getOnUpdateMethod"),
                mF = Symbol("textureLoader"),
                mU = Symbol("originalGltfJson"),
                mB = function(e, t, n, r) {
                    for (var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r, s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o);
                    return a > 3 && o && Object.defineProperty(t, n, o), o
                },
                mz = {
                    basis: [uR(u_(Math.PI / 32, "rad"))],
                    keywords: {
                        auto: [null]
                    }
                },
                mH = Symbol("autoRotateStartTime"),
                mV = Symbol("radiansPerSecond"),
                mG = Symbol("syncRotationRate"),
                mW = Symbol("onCameraChange"),
                mj = function(e) {
                    var t, n, r;
                    return function(e) {
                        function i() {
                            var e;
                            return (0, k._)(this, i), e = (0, E._)(this, i, arguments), e[t] = new Map, e[n] = function(t) {
                                t.forEach(function(t) {
                                    t instanceof MutationRecord && "childList" !== t.type || (t.addedNodes.forEach(function(t) {
                                        e[hw](t)
                                    }), t.removedNodes.forEach(function(t) {
                                        e[hM](t)
                                    }), e[hn]())
                                })
                            }, e[r] = new MutationObserver(e[hx]), e
                        }
                        return (0, P._)(i, e), (0, A._)(i, [{
                            key: "connectedCallback",
                            value: function() {
                                L((0, C._)(i.prototype), "connectedCallback", this).call(this);
                                for (var e = 0; e < this.children.length; ++e) this[hw](this.children[e]);
                                var t = self.ShadyDOM;
                                null == t ? this[hb].observe(this, {
                                    childList: !0
                                }) : this[hb] = t.observeChildren(this, this[hx])
                            }
                        }, {
                            key: "disconnectedCallback",
                            value: function() {
                                L((0, C._)(i.prototype), "disconnectedCallback", this).call(this);
                                var e = self.ShadyDOM;
                                null == e ? this[hb].disconnect() : e.unobserveChildren(this[hb])
                            }
                        }, {
                            key: (t = h_, n = hx, r = hb, hr),
                            value: function(e, t) {
                                L((0, C._)(i.prototype), hr, this).call(this, e, t);
                                var n = this[ht],
                                    r = n.annotationRenderer,
                                    a = n.getCamera();
                                n.shouldRender() && (n.updateHotspots(a.position), r.domElement.style.display = "", r.render(n, a))
                            }
                        }, {
                            key: "updateHotspot",
                            value: function(e) {
                                var t = this[h_].get(e.name);
                                null != t && (t.updatePosition(e.position), t.updateNormal(e.normal), this[hn]())
                            }
                        }, {
                            key: "positionAndNormalFromPoint",
                            value: function(e, t) {
                                var n, r = this[ht],
                                    i = r.getNDC(e, t),
                                    a = r.positionAndNormalFromPoint(i);
                                if (null == a) return null;
                                hS.copy(r.target.matrixWorld).invert();
                                var o = hf(a.position.applyMatrix4(hS));
                                hT.getNormalMatrix(hS);
                                var s = hf(a.normal.applyNormalMatrix(hT)),
                                    l = null;
                                return null != a.uv && (l = {
                                    u: (n = a.uv).x,
                                    v: n.y,
                                    toString: function() {
                                        return "".concat(this.u, " ").concat(this.v)
                                    }
                                }), {
                                    position: o,
                                    normal: s,
                                    uv: l
                                }
                            }
                        }, {
                            key: hw,
                            value: function(e) {
                                if (e instanceof HTMLElement && 0 === e.slot.indexOf("hotspot")) {
                                    var t = this[h_].get(e.slot);
                                    null != t ? t.increment() : (t = new uP({
                                        name: e.slot,
                                        position: e.dataset.position,
                                        normal: e.dataset.normal
                                    }), this[h_].set(e.slot, t), this[ht].addHotspot(t)), this[ht].queueRender()
                                }
                            }
                        }, {
                            key: hM,
                            value: function(e) {
                                if (e instanceof HTMLElement) {
                                    var t = this[h_].get(e.slot);
                                    t && (t.decrement() && (this[ht].removeHotspot(t), this[h_].delete(e.slot)), this[ht].queueRender())
                                }
                            }
                        }]), i
                    }(e)
                }(function(e) {
                    var t, n, r, i, a = function(e) {
                        function a() {
                            var e;
                            return (0, k._)(this, a), e = (0, E._)(this, a, arguments), e[t] = void 0, e[n] = null, e[r] = new sM, e[i] = null, e.variantName = null, e.orientation = "0 0 0", e.scale = "1 1 1", e
                        }
                        return (0, P._)(a, e), (0, A._)(a, [{
                            key: "model",
                            get: function() {
                                return this[mO]
                            }
                        }, {
                            key: "availableVariants",
                            get: function() {
                                return this.model ? this.model[mA]() : []
                            }
                        }, {
                            key: "originalGltfJson",
                            get: function() {
                                return this[mU]
                            }
                        }, {
                            key: (t = mO, n = mD, r = mF, i = mU, mN),
                            value: function() {
                                var e = this;
                                return function() {
                                    e[hn]()
                                }
                            }
                        }, {
                            key: "createTexture",
                            value: function(e) {
                                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "image/png",
                                    n = this;
                                return (0, T._)(function() {
                                    var r, i;
                                    return (0, z.YH)(this, function(a) {
                                        switch (a.label) {
                                            case 0:
                                                return r = n[mD], [4, new Promise(function(t) {
                                                    return n[mF].load(e, t)
                                                })];
                                            case 1:
                                                return i = a.sent(), [2, r && i ? (i.encoding = 3001, i.wrapS = 1e3, i.wrapT = 1e3, i.flipY = !1, "image/jpeg" === t && (i.format = 1022), new pq(n[mN](), i)) : null]
                                        }
                                    })
                                })()
                            }
                        }, {
                            key: "updated",
                            value: function(e) {
                                var t = this,
                                    n = this;
                                return (0, T._)(function() {
                                    var r, i, o, s, l, u, c, h;
                                    return (0, z.YH)(this, function(d) {
                                        switch (d.label) {
                                            case 0:
                                                if (L((0, C._)(a.prototype), "updated", t).call(n, e), !e.has("variantName")) return [3, 3];
                                                if (r = n[mD], i = n.variantName, !(null != r)) return [3, 2];
                                                return [4, n[mO][mM](i)];
                                            case 1:
                                                d.sent(), n[hn](), n.dispatchEvent(new CustomEvent("variant-applied")), d.label = 2;
                                            case 2:
                                                d.label = 3;
                                            case 3:
                                                return (e.has("orientation") || e.has("scale")) && (o = n[ht].modelContainer, l = uL((s = ux(n.orientation)[0].terms)[0]).number, u = uL(s[1]).number, c = uL(s[2]).number, o.quaternion.setFromEuler(new tX(u, c, l, "YXZ")), h = ux(n.scale)[0].terms, o.scale.set(h[0].number, h[1].number, h[2].number), n[ht].updateBoundingBox(), n[ht].updateShadow(), n[ho].arRenderer.onUpdateScene(), n[hn]()), [2]
                                        }
                                    })
                                })()
                            }
                        }, {
                            key: hi,
                            value: function() {
                                L((0, C._)(a.prototype), hi, this).call(this);
                                var e = this[ht].currentGLTF;
                                if (null != e) {
                                    var t = e.correlatedSceneGraph;
                                    null != t && e !== this[mD] && (this[mO] = new mP(t, this[mN]()), this[mU] = JSON.parse(JSON.stringify(t.gltf))), "variants" in e.userData && this.requestUpdate("variantName")
                                }
                                this[mD] = e, this.dispatchEvent(new CustomEvent("scene-graph-ready"))
                            }
                        }, {
                            key: "exportScene",
                            value: function(e) {
                                var t = this;
                                return (0, T._)(function() {
                                    var n;
                                    return (0, z.YH)(this, function(r) {
                                        var i;
                                        return n = t[ht], [2, new Promise((i = (0, T._)(function(r) {
                                            var i, a, o;
                                            return (0, z.YH)(this, function(s) {
                                                switch (s.label) {
                                                    case 0:
                                                        return Object.assign(i = {
                                                            binary: !0,
                                                            onlyVisible: !0,
                                                            maxTextureSize: 1 / 0,
                                                            forcePowerOfTwoTextures: !1,
                                                            includeCustomExtensions: !1,
                                                            embedImages: !0
                                                        }, e), i.animations = n.animations, i.truncateDrawRange = !0, a = n.shadow, o = !1, null != a && (o = a.visible, a.visible = !1), [4, t[mO][mw]()];
                                                    case 1:
                                                        return s.sent(), (new pc).register(function(e) {
                                                            return new pE(e)
                                                        }).parse(n.modelContainer.children[0], function(e) {
                                                            return r(new Blob([i.binary ? e : JSON.stringify(e)], {
                                                                type: i.binary ? "application/octet-stream" : "application/json"
                                                            }))
                                                        }, i), null != a && (a.visible = o), [2]
                                                }
                                            })
                                        }), function(e) {
                                            return i.apply(this, arguments)
                                        }))]
                                    })
                                })()
                            }
                        }, {
                            key: "materialFromPoint",
                            value: function(e, t) {
                                var n = this[ht],
                                    r = n.getNDC(e, t);
                                return n.raycaster.setFromCamera(r, n.getCamera()), this[mO][mE](n.raycaster)
                            }
                        }]), a
                    }(e);
                    return mI([eU({
                        type: String,
                        attribute: "variant-name"
                    })], a.prototype, "variantName", void 0), mI([eU({
                        type: String,
                        attribute: "orientation"
                    })], a.prototype, "orientation", void 0), mI([eU({
                        type: String,
                        attribute: "scale"
                    })], a.prototype, "scale", void 0), a
                }(function(e) {
                    var t, n, r, i = function(e) {
                        function i() {
                            var e;
                            return (0, k._)(this, i), e = (0, E._)(this, i, arguments), e.autoRotate = !1, e.autoRotateDelay = 3e3, e.rotationPerSecond = "auto", e[t] = performance.now(), e[n] = 0, e[r] = function(t) {
                                e.autoRotate && "user-interaction" === t.detail.source && (e[mH] = performance.now())
                            }, e
                        }
                        return (0, P._)(i, e), (0, A._)(i, [{
                            key: "connectedCallback",
                            value: function() {
                                L((0, C._)(i.prototype), "connectedCallback", this).call(this), this.addEventListener("camera-change", this[mW]), this[mH] = performance.now()
                            }
                        }, {
                            key: "disconnectedCallback",
                            value: function() {
                                L((0, C._)(i.prototype), "disconnectedCallback", this).call(this), this.removeEventListener("camera-change", this[mW]), this[mH] = performance.now()
                            }
                        }, {
                            key: "updated",
                            value: function(e) {
                                L((0, C._)(i.prototype), "updated", this).call(this, e), e.has("autoRotate") && (this[mH] = performance.now())
                            }
                        }, {
                            key: (t = mH, n = mV, mG),
                            value: function(e) {
                                this[mV] = e[0]
                            }
                        }, {
                            key: hr,
                            value: function(e, t) {
                                if (L((0, C._)(i.prototype), hr, this).call(this, e, t), this.autoRotate && this[hd]() && !this[ho].isPresenting) {
                                    var n = Math.min(t, e - this[mH] - this.autoRotateDelay);
                                    n > 0 && (this[ht].yaw = this.turntableRotation + this[mV] * n * .001)
                                }
                            }
                        }, {
                            key: "turntableRotation",
                            get: function() {
                                return this[ht].yaw
                            }
                        }, {
                            key: "resetTurntableRotation",
                            value: function() {
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                                this[ht].yaw = e
                            }
                        }]), i
                    }(e);
                    return r = mW, mB([eU({
                        type: Boolean,
                        attribute: "auto-rotate"
                    })], i.prototype, "autoRotate", void 0), mB([eU({
                        type: Number,
                        attribute: "auto-rotate-delay"
                    })], i.prototype, "autoRotateDelay", void 0), mB([fe({
                        intrinsics: mz,
                        updateHandler: mG
                    }), eU({
                        type: String,
                        attribute: "rotation-per-second"
                    })], i.prototype, "rotationPerSecond", void 0), i
                }(function(e) {
                    var t, n, r, i = function(e) {
                        function i() {
                            var e;
                            return (0, k._)(this, i), e = (0, E._)(this, i, arguments), e.environmentImage = null, e.skyboxImage = null, e.shadowIntensity = 0, e.shadowSoftness = 1, e.exposure = 1, e[t] = null, e[n] = null, e[r] = function(t) {
                                t.element === e && e[uj]()
                            }, e
                        }
                        return (0, P._)(i, e), (0, A._)(i, [{
                            key: "connectedCallback",
                            value: function() {
                                L((0, C._)(i.prototype), "connectedCallback", this).call(this), this[ho].loader.addEventListener("preload", this[uX])
                            }
                        }, {
                            key: "disconnectedCallback",
                            value: function() {
                                L((0, C._)(i.prototype), "disconnectedCallback", this).call(this), this[ho].loader.removeEventListener("preload", this[uX])
                            }
                        }, {
                            key: "updated",
                            value: function(e) {
                                L((0, C._)(i.prototype), "updated", this).call(this, e), e.has("shadowIntensity") && (this[ht].setShadowIntensity(.1 * this.shadowIntensity), this[hn]()), e.has("shadowSoftness") && (this[ht].setShadowSoftness(this.shadowSoftness), this[hn]()), e.has("exposure") && (this[ht].exposure = this.exposure, this[hn]()), (e.has("environmentImage") || e.has("skyboxImage")) && this[hc]() && this[uj]()
                            }
                        }, {
                            key: (t = uG, n = uq, r = uX, hi),
                            value: function() {
                                L((0, C._)(i.prototype), hi, this).call(this), null != this[uG] && this[uW](this[uG])
                            }
                        }, {
                            key: uj,
                            value: function() {
                                var e = this;
                                return (0, T._)(function() {
                                    var t, n, r, i, a, o, s;
                                    return (0, z.YH)(this, function(l) {
                                        switch (l.label) {
                                            case 0:
                                                if (t = e.skyboxImage, n = e.environmentImage, null != e[uq] && (e[uq](), e[uq] = null), !(null != (r = e[ho].textureUtils))) return [3, 4];
                                                l.label = 1;
                                            case 1:
                                                var u;
                                                return l.trys.push([1, 3, , 4]), [4, new Promise((u = (0, T._)(function(i, a) {
                                                    var o;
                                                    return (0, z.YH)(this, function(s) {
                                                        switch (s.label) {
                                                            case 0:
                                                                return o = r.generateEnvironmentMapAndSkybox(uc(t), n, {
                                                                    progressTracker: e[hs]
                                                                }), e[uq] = function() {
                                                                    return a(o)
                                                                }, [4, o];
                                                            case 1:
                                                                return i.apply(void 0, [s.sent()]), [2]
                                                        }
                                                    })
                                                }), function(e, t) {
                                                    return u.apply(this, arguments)
                                                }))];
                                            case 2:
                                                return a = (i = l.sent()).environmentMap, o = i.skybox, e[ht].background = null != o ? o.name === a.name ? a : o : null, e[uW](a), e[ht].dispatchEvent({
                                                    type: "envmap-update"
                                                }), [3, 4];
                                            case 3:
                                                if ((s = l.sent()) instanceof Error) throw e[uW](null), s;
                                                return [3, 4];
                                            case 4:
                                                return [2]
                                        }
                                    })
                                })()
                            }
                        }, {
                            key: uW,
                            value: function(e) {
                                this[ht].environment !== e && (this[uG] = e, this[ht].environment = this[uG], this.dispatchEvent(new CustomEvent("environment-change")), this[hn]())
                            }
                        }]), i
                    }(e);
                    return uV([eU({
                        type: String,
                        attribute: "environment-image"
                    })], i.prototype, "environmentImage", void 0), uV([eU({
                        type: String,
                        attribute: "skybox-image"
                    })], i.prototype, "skyboxImage", void 0), uV([eU({
                        type: Number,
                        attribute: "shadow-intensity"
                    })], i.prototype, "shadowIntensity", void 0), uV([eU({
                        type: Number,
                        attribute: "shadow-softness"
                    })], i.prototype, "shadowSoftness", void 0), uV([eU({
                        type: Number
                    })], i.prototype, "exposure", void 0), i
                }(function(e) {
                    var t, n, r, i, a, o, s, l, u, c, h, d, f, p, m, v, g = function(e) {
                        function g() {
                            var e;
                            return (0, k._)(this, g), e = (0, E._)(this, g, arguments), e.cameraControls = !1, e.cameraOrbit = "0deg 75deg 105%", e.cameraTarget = "auto auto auto", e.fieldOfView = "auto", e.minCameraOrbit = "auto", e.maxCameraOrbit = "auto", e.minFieldOfView = "auto", e.maxFieldOfView = "auto", e.interactionPromptThreshold = 3e3, e.interactionPromptStyle = fm, e.interactionPrompt = ff, e.interactionPolicy = "always-allow", e.orbitSensitivity = 1, e.touchAction = "pan-y", e.disableZoom = !1, e.interpolationDecay = 50, e.bounds = "legacy", e[t] = e.shadowRoot.querySelector(".interaction-prompt"), e[n] = e.shadowRoot.querySelector(".interaction-prompt > .animated-container"), e[r] = 1 / 0, e[i] = 0, e[a] = 1 / 0, e[o] = !1, e[s] = !1, e[l] = new fi(e[ht].camera, e[c9]), e[u] = new s$, e[c] = !1, e[h] = !1, e[d] = !1, e[f] = function() {
                                var t = e[c9];
                                isFinite(e[fH]) || (e[fH] = performance.now());
                                var n = e[c4];
                                t.getAttribute("aria-label") !== n && t.setAttribute("aria-label", n), e.interactionPrompt !== fp || e[fU] || (e[fF] = !0)
                            }, e[p] = function() {
                                e.interactionPrompt === fp && (e[fF] = !1, e[fA].classList.remove("visible"), e[fB] = 1 / 0, e[fH] = 1 / 0)
                            }, e[m] = function(t) {
                                var n = t.source;
                                e[fL](), e[hn](), n === fr && (e[fU] = !0, e[fC]()), e.dispatchEvent(new CustomEvent("camera-change", {
                                    detail: {
                                        source: n
                                    }
                                }))
                            }, e[v] = function(t) {
                                "pointer-change-start" === t.type ? e[c7].classList.add("pointer-tumbling") : e[c7].classList.remove("pointer-tumbling")
                            }, e
                        }
                        return (0, P._)(g, e), (0, A._)(g, [{
                            key: "getCameraOrbit",
                            value: function() {
                                var e = this[fV];
                                return {
                                    theta: e.theta,
                                    phi: e.phi,
                                    radius: e.radius,
                                    toString: function() {
                                        return "".concat(this.theta, "rad ").concat(this.phi, "rad ").concat(this.radius, "m")
                                    }
                                }
                            }
                        }, {
                            key: "getCameraTarget",
                            value: function() {
                                return hf(this[ho].isPresenting ? this[ho].arRenderer.target : this[ht].getTarget())
                            }
                        }, {
                            key: "getFieldOfView",
                            value: function() {
                                return this[fk].getFieldOfView()
                            }
                        }, {
                            key: "getMinimumFieldOfView",
                            value: function() {
                                return this[fk].options.minimumFieldOfView
                            }
                        }, {
                            key: "getMaximumFieldOfView",
                            value: function() {
                                return this[fk].options.maximumFieldOfView
                            }
                        }, {
                            key: "getIdealAspect",
                            value: function() {
                                return this[ht].idealAspect
                            }
                        }, {
                            key: "jumpCameraToGoal",
                            value: function() {
                                this[fG] = !0, this.requestUpdate(fG, !1)
                            }
                        }, {
                            key: "resetInteractionPrompt",
                            value: function() {
                                this[fz] = 0, this[fB] = 1 / 0, this[fU] = !1, this[fF] = this.interactionPrompt === ff && this.cameraControls
                            }
                        }, {
                            key: "zoom",
                            value: function(e) {
                                var t = new WheelEvent("wheel", {
                                    deltaY: -30 * e
                                });
                                this[c9].dispatchEvent(t)
                            }
                        }, {
                            key: "connectedCallback",
                            value: function() {
                                L((0, C._)(g.prototype), "connectedCallback", this).call(this), this[fk].addEventListener("change", this[fO]), this[fk].addEventListener("pointer-change-start", this[fN]), this[fk].addEventListener("pointer-change-end", this[fN])
                            }
                        }, {
                            key: "disconnectedCallback",
                            value: function() {
                                L((0, C._)(g.prototype), "disconnectedCallback", this).call(this), this[fk].removeEventListener("change", this[fO]), this[fk].removeEventListener("pointer-change-start", this[fN]), this[fk].removeEventListener("pointer-change-end", this[fN])
                            }
                        }, {
                            key: "updated",
                            value: function(e) {
                                var t = this;
                                L((0, C._)(g.prototype), "updated", this).call(this, e);
                                var n = this[fk],
                                    r = this[c9];
                                if (e.has("cameraControls") && (this.cameraControls ? (n.enableInteraction(), this.interactionPrompt === ff && (this[fF] = !0), r.addEventListener("focus", this[fD]), r.addEventListener("blur", this[fI])) : (r.removeEventListener("focus", this[fD]), r.removeEventListener("blur", this[fI]), n.disableInteraction(), this[fC]())), e.has("disableZoom") && (n.disableZoom = this.disableZoom), e.has("bounds") && (this[ht].tightBounds = "tight" === this.bounds), (e.has("interactionPrompt") || e.has("cameraControls") || e.has("src")) && (this.interactionPrompt === ff && this.cameraControls && !this[fU] ? this[fF] = !0 : this[fC]()), e.has("interactionPromptStyle") && this[fA].classList.toggle("wiggle", this.interactionPromptStyle === fm), e.has("interactionPolicy")) {
                                    var i = this.interactionPolicy;
                                    n.applyOptions({
                                        interactionPolicy: i
                                    })
                                }
                                if (e.has("touchAction")) {
                                    var a = this.touchAction;
                                    n.applyOptions({
                                        touchAction: a
                                    }), n.updateTouchActionStyle()
                                }
                                e.has("orbitSensitivity") && (n.sensitivity = this.orbitSensitivity), e.has("interpolationDecay") && (n.setDamperDecayTime(this.interpolationDecay), this[ht].setTargetDamperDecayTime(this.interpolationDecay)), !0 === this[fG] && Promise.resolve().then(function() {
                                    n.jumpToGoal(), t[ht].jumpToGoal(), t[fG] = !1
                                })
                            }
                        }, {
                            key: "updateFraming",
                            value: function() {
                                var e = this;
                                return (0, T._)(function() {
                                    var t, n, r, i;
                                    return (0, z.YH)(this, function(a) {
                                        switch (a.label) {
                                            case 0:
                                                return n = (t = e[ht]).adjustedFoV(t.framedFoVDeg), [4, t.updateFraming()];
                                            case 1:
                                                return a.sent(), r = t.adjustedFoV(t.framedFoVDeg), i = e[fk].getFieldOfView() / n, e[fk].setFieldOfView(r * i), e[fj] = !0, e.requestUpdate("maxFieldOfView"), e.requestUpdate("fieldOfView"), e.requestUpdate("minCameraOrbit"), e.requestUpdate("maxCameraOrbit"), [4, e.requestUpdate("cameraOrbit")];
                                            case 2:
                                                return a.sent(), [2]
                                        }
                                    })
                                })()
                            }
                        }, {
                            key: (t = fA, n = fR, r = fH, i = fz, a = fB, o = fU, s = fF, l = fk, u = fV, c = fG, h = fW, d = fj, fX),
                            value: function(e) {
                                var t = this[ht];
                                t.framedFoVDeg = 180 * e[0] / Math.PI, this[fk].setFieldOfView(t.adjustedFoV(t.framedFoVDeg))
                            }
                        }, {
                            key: fq,
                            value: function(e) {
                                if (this[fj]) {
                                    var t = this.getCameraOrbit(),
                                        n = t.theta,
                                        r = t.phi;
                                    e[0] = n, e[1] = r, this[fj] = !1
                                }
                                this[fk].setOrbit(e[0], e[1], e[2])
                            }
                        }, {
                            key: fJ,
                            value: function(e) {
                                this[fk].applyOptions({
                                    minimumAzimuthalAngle: e[0],
                                    minimumPolarAngle: e[1],
                                    minimumRadius: e[2]
                                }), this.jumpCameraToGoal()
                            }
                        }, {
                            key: fZ,
                            value: function(e) {
                                this[fk].applyOptions({
                                    maximumAzimuthalAngle: e[0],
                                    maximumPolarAngle: e[1],
                                    maximumRadius: e[2]
                                }), this[fP](e[2]), this.jumpCameraToGoal()
                            }
                        }, {
                            key: fK,
                            value: function(e) {
                                this[fk].applyOptions({
                                    minimumFieldOfView: 180 * e[0] / Math.PI
                                }), this.jumpCameraToGoal()
                            }
                        }, {
                            key: fQ,
                            value: function(e) {
                                var t = this[ht].adjustedFoV(180 * e[0] / Math.PI);
                                this[fk].applyOptions({
                                    maximumFieldOfView: t
                                }), this.jumpCameraToGoal()
                            }
                        }, {
                            key: fY,
                            value: function(e) {
                                var t = (0, O._)(e, 3),
                                    n = t[0],
                                    r = t[1],
                                    i = t[2];
                                this[ht].setTarget(n, r, i), this[ho].arRenderer.updateTarget()
                            }
                        }, {
                            key: hr,
                            value: function(e, t) {
                                if (L((0, C._)(g.prototype), hr, this).call(this, e, t), !this[ho].isPresenting && this[hd]()) {
                                    var n = performance.now();
                                    if (this[fF]) {
                                        var r = this.interactionPrompt === ff ? this[c5] : this[fH];
                                        this.loaded && n > r + this.interactionPromptThreshold && (this[c9].setAttribute("aria-label", "Use mouse, touch or arrow keys to control the camera!"), this[fF] = !1, this[fB] = n, this[fA].classList.add("visible"))
                                    }
                                    if (isFinite(this[fB]) && this.interactionPromptStyle === fm) {
                                        var i = this[ht],
                                            a = (n - this[fB]) / 5e3 % 1,
                                            o = fu(a),
                                            s = fc(a);
                                        if (this[fR].style.opacity = "".concat(s), o !== this[fz]) {
                                            var l = o * i.width * .05,
                                                u = (o - this[fz]) * Math.PI / 16;
                                            this[fR].style.transform = "translateX(".concat(l, "px)"), this[fk].adjustOrbit(u, 0, 0), this[fz] = o
                                        }
                                    }
                                    this[fk].update(e, t), this[ht].updateTarget(t)
                                }
                            }
                        }, {
                            key: fC,
                            value: function() {
                                this[fF] = !1, this[fA].classList.remove("visible"), this[fB] = 1 / 0
                            }
                        }, {
                            key: fP,
                            value: function(e) {
                                var t = 2 * Math.max(this[ht].boundingRadius, e);
                                this[fk].updateNearFar(0, t)
                            }
                        }, {
                            key: fL,
                            value: function() {
                                var e = this[fV],
                                    t = e.theta,
                                    n = e.phi,
                                    r = this[fk].getCameraSpherical(this[fV]),
                                    i = r.theta,
                                    a = r.phi,
                                    o = this.getRootNode();
                                if (null != o && o.activeElement === this) {
                                    var s = (4 + Math.floor((t % fE + fT) / fM)) % 4,
                                        l = (4 + Math.floor((i % fE + fT) / fM)) % 4,
                                        u = Math.floor(n / fS),
                                        c = Math.floor(a / fS);
                                    if (l !== s || c !== u) {
                                        var h = "View from stage ".concat(fd[c]).concat(fh[l]);
                                        this[c9].setAttribute("aria-label", h)
                                    }
                                }
                            }
                        }, {
                            key: ha,
                            value: function(e) {
                                var t = this,
                                    n = this;
                                return (0, T._)(function() {
                                    var r, i, a, o, s;
                                    return (0, z.YH)(this, function(l) {
                                        switch (l.label) {
                                            case 0:
                                                return r = n[fk], a = (i = n[ht]).adjustedFoV(i.framedFoVDeg), L((0, C._)(g.prototype), ha, t).call(n, e), o = i.adjustedFoV(i.framedFoVDeg), s = r.getFieldOfView() / a, r.updateAspect(n[ht].aspect), [4, n.requestUpdate("maxFieldOfView", n.maxFieldOfView)];
                                            case 1:
                                                return l.sent(), n[fk].setFieldOfView(o * s), n.jumpCameraToGoal(), [2]
                                        }
                                    })
                                })()
                            }
                        }, {
                            key: hi,
                            value: function() {
                                L((0, C._)(g.prototype), hi, this).call(this), this[fW] ? this[fj] = !0 : this[fW] = !0, this.requestUpdate("maxFieldOfView", this.maxFieldOfView), this.requestUpdate("fieldOfView", this.fieldOfView), this.requestUpdate("minCameraOrbit", this.minCameraOrbit), this.requestUpdate("maxCameraOrbit", this.maxCameraOrbit), this.requestUpdate("cameraOrbit", this.cameraOrbit), this.requestUpdate("cameraTarget", this.cameraTarget), this.jumpCameraToGoal()
                            }
                        }]), g
                    }(e);
                    return f = fD, p = fI, m = fO, v = fN, fl([eU({
                        type: Boolean,
                        attribute: "camera-controls"
                    })], g.prototype, "cameraControls", void 0), fl([fe({
                        intrinsics: f_,
                        observeEffects: !0,
                        updateHandler: fq
                    }), eU({
                        type: String,
                        attribute: "camera-orbit",
                        hasChanged: function() {
                            return !0
                        }
                    })], g.prototype, "cameraOrbit", void 0), fl([fe({
                        intrinsics: fw,
                        observeEffects: !0,
                        updateHandler: fY
                    }), eU({
                        type: String,
                        attribute: "camera-target",
                        hasChanged: function() {
                            return !0
                        }
                    })], g.prototype, "cameraTarget", void 0), fl([fe({
                        intrinsics: fv,
                        observeEffects: !0,
                        updateHandler: fX
                    }), eU({
                        type: String,
                        attribute: "field-of-view",
                        hasChanged: function() {
                            return !0
                        }
                    })], g.prototype, "fieldOfView", void 0), fl([fe({
                        intrinsics: fx,
                        updateHandler: fJ
                    }), eU({
                        type: String,
                        attribute: "min-camera-orbit",
                        hasChanged: function() {
                            return !0
                        }
                    })], g.prototype, "minCameraOrbit", void 0), fl([fe({
                        intrinsics: fb,
                        updateHandler: fZ
                    }), eU({
                        type: String,
                        attribute: "max-camera-orbit",
                        hasChanged: function() {
                            return !0
                        }
                    })], g.prototype, "maxCameraOrbit", void 0), fl([fe({
                        intrinsics: fg,
                        updateHandler: fK
                    }), eU({
                        type: String,
                        attribute: "min-field-of-view",
                        hasChanged: function() {
                            return !0
                        }
                    })], g.prototype, "minFieldOfView", void 0), fl([fe({
                        intrinsics: fy,
                        updateHandler: fQ
                    }), eU({
                        type: String,
                        attribute: "max-field-of-view",
                        hasChanged: function() {
                            return !0
                        }
                    })], g.prototype, "maxFieldOfView", void 0), fl([eU({
                        type: Number,
                        attribute: "interaction-prompt-threshold"
                    })], g.prototype, "interactionPromptThreshold", void 0), fl([eU({
                        type: String,
                        attribute: "interaction-prompt-style"
                    })], g.prototype, "interactionPromptStyle", void 0), fl([eU({
                        type: String,
                        attribute: "interaction-prompt"
                    })], g.prototype, "interactionPrompt", void 0), fl([eU({
                        type: String,
                        attribute: "interaction-policy"
                    })], g.prototype, "interactionPolicy", void 0), fl([eU({
                        type: Number,
                        attribute: "orbit-sensitivity"
                    })], g.prototype, "orbitSensitivity", void 0), fl([eU({
                        type: String,
                        attribute: "touch-action"
                    })], g.prototype, "touchAction", void 0), fl([eU({
                        type: Boolean,
                        attribute: "disable-zoom"
                    })], g.prototype, "disableZoom", void 0), fl([eU({
                        type: Number,
                        attribute: "interpolation-decay"
                    })], g.prototype, "interpolationDecay", void 0), fl([eU({
                        type: String,
                        attribute: "bounds"
                    })], g.prototype, "bounds", void 0), g
                }(function(e) {
                    var t, n, r, i, a, o, s, l, u, c, h = function(e) {
                        function h() {
                            var e;
                            return (0, k._)(this, h), e = (0, E._)(this, h, arguments), e.ar = !1, e.arScale = "auto", e.arPlacement = "floor", e.arModes = "webxr scene-viewer", e.iosSrc = null, e.xrEnvironment = !1, e[t] = !1, e[n] = e.shadowRoot.querySelector(".ar-button"), e[r] = document.createElement("a"), e[i] = new Set, e[a] = dy, e[o] = !1, e[s] = function(t) {
                                t.preventDefault(), e.activateAR()
                            }, e[l] = function(t) {
                                var n = t.status;
                                n !== u0 && e[ho].arRenderer.presentedScene !== e[ht] || (e.setAttribute("ar-status", n), e.dispatchEvent(new CustomEvent("ar-status", {
                                    detail: {
                                        status: n
                                    }
                                })), n === u0 ? e.removeAttribute("ar-tracking") : n === u1 && e.setAttribute("ar-tracking", u2))
                            }, e[u] = function(t) {
                                var n = t.status;
                                e.setAttribute("ar-tracking", n), e.dispatchEvent(new CustomEvent("ar-tracking", {
                                    detail: {
                                        status: n
                                    }
                                }))
                            }, e[c] = function(t) {
                                "_apple_ar_quicklook_button_tapped" == t.data && e.dispatchEvent(new CustomEvent("quick-look-button-tapped"))
                            }, e
                        }
                        return (0, P._)(h, e), (0, A._)(h, [{
                            key: "canActivateAR",
                            get: function() {
                                return this[dS] !== dy
                            }
                        }, {
                            key: "connectedCallback",
                            value: function() {
                                L((0, C._)(h.prototype), "connectedCallback", this).call(this), this[ho].arRenderer.addEventListener("status", this[dR]), this.setAttribute("ar-status", u0), this[ho].arRenderer.addEventListener("tracking", this[dC]), this[dE].addEventListener("message", this[dL])
                            }
                        }, {
                            key: "disconnectedCallback",
                            value: function() {
                                L((0, C._)(h.prototype), "disconnectedCallback", this).call(this), this[ho].arRenderer.removeEventListener("status", this[dR]), this[ho].arRenderer.removeEventListener("tracking", this[dC]), this[dE].removeEventListener("message", this[dL])
                            }
                        }, {
                            key: "update",
                            value: function(e) {
                                var t = this,
                                    n = this;
                                return (0, T._)(function() {
                                    return (0, z.YH)(this, function(r) {
                                        return L((0, C._)(h.prototype), "update", t).call(n, e), e.has("arScale") && (n[ht].canScale = "fixed" !== n.arScale), e.has("arPlacement") && (n[ht].updateShadow(), n[hn]()), (e.has("ar") || e.has("arModes") || e.has("src") || e.has("iosSrc")) && (e.has("arModes") && (n[dT] = dp(n.arModes)), n[dP]()), [2]
                                    })
                                })()
                            }
                        }, {
                            key: "activateAR",
                            value: function() {
                                var e = this;
                                return (0, T._)(function() {
                                    return (0, z.YH)(this, function(t) {
                                        switch (t.label) {
                                            case 0:
                                                switch (e[dS]) {
                                                    case dm:
                                                        return [3, 1];
                                                    case dg:
                                                        return [3, 2];
                                                    case dv:
                                                        return [3, 4]
                                                }
                                                return [3, 5];
                                            case 1:
                                                return e[dw](), [3, 6];
                                            case 2:
                                                return [4, e[dx]()];
                                            case 3:
                                                return t.sent(), [3, 6];
                                            case 4:
                                                return e[db](), [3, 6];
                                            case 5:
                                                console.warn("No AR Mode can be activated. This is probably due to missing configuration or device capabilities"), t.label = 6;
                                            case 6:
                                                return [2]
                                        }
                                    })
                                })()
                            }
                        }, {
                            key: (t = dM, n = d_, r = dE, i = dT, a = dS, o = dk, s = dA, l = dR, u = dC, c = dL, dP),
                            value: function() {
                                var e = this;
                                return (0, T._)(function() {
                                    var t, n, r, i, a, o, s, l, u;
                                    return (0, z.YH)(this, function(c) {
                                        switch (c.label) {
                                            case 0:
                                                if (e[dS] = dy, !e.ar) return [3, 10];
                                                if (t = !0, n = !1, r = void 0, !(null != e.src)) return [3, 9];
                                                c.label = 1;
                                            case 1:
                                                c.trys.push([1, 7, 8, 9]), i = e[dT][Symbol.iterator](), c.label = 2;
                                            case 2:
                                                if (t = (a = i.next()).done) return [3, 6];
                                                if (!(s = "webxr" === (o = a.value) && s8 && !dd)) return [3, 4];
                                                return [4, e[ho].arRenderer.supportsPresentation()];
                                            case 3:
                                                s = c.sent(), c.label = 4;
                                            case 4:
                                                if (s) return e[dS] = dg, [3, 6];
                                                if ("scene-viewer" === o && la && !df) return e[dS] = dv, [3, 6];
                                                if ("quick-look" === o && ln) return e[dS] = dm, [3, 6];
                                                c.label = 5;
                                            case 5:
                                                return t = !0, [3, 2];
                                            case 6:
                                                return [3, 9];
                                            case 7:
                                                return l = c.sent(), n = !0, r = l, [3, 9];
                                            case 8:
                                                try {
                                                    t || null == i.return || i.return()
                                                } finally {
                                                    if (n) throw r
                                                }
                                                return [7];
                                            case 9:
                                                !e.canActivateAR && null != e.iosSrc && ln && (e[dS] = dm), c.label = 10;
                                            case 10:
                                                return e.canActivateAR ? (e[d_].classList.add("enabled"), e[d_].addEventListener("click", e[dA])) : e[d_].classList.contains("enabled") && (e[d_].removeEventListener("click", e[dA]), e[d_].classList.remove("enabled"), u = "failed", e.setAttribute("ar-status", u), e.dispatchEvent(new CustomEvent("ar-status", {
                                                    detail: {
                                                        status: u
                                                    }
                                                }))), [2]
                                        }
                                    })
                                })()
                            }
                        }, {
                            key: dx,
                            value: function() {
                                var e = this;
                                return (0, T._)(function() {
                                    var t, n;
                                    return (0, z.YH)(this, function(r) {
                                        switch (r.label) {
                                            case 0:
                                                return console.log("Attempting to present in AR with WebXR..."), [4, e[dI]()];
                                            case 1:
                                                r.sent(), r.label = 2;
                                            case 2:
                                                return r.trys.push([2, 4, 7, 8]), e[d_].removeEventListener("click", e[dA]), (t = e[ho].arRenderer).placeOnWall = "wall" === e.arPlacement, [4, t.present(e[ht], e.xrEnvironment)];
                                            case 3:
                                                return r.sent(), [3, 8];
                                            case 4:
                                                return n = r.sent(), console.warn("Error while trying to present in AR with WebXR"), console.error(n), [4, e[ho].arRenderer.stopPresenting()];
                                            case 5:
                                                return r.sent(), dd = !0, console.warn("Falling back to next ar-mode"), [4, e[dP]()];
                                            case 6:
                                                return r.sent(), e.activateAR(), [3, 8];
                                            case 7:
                                                return e[dP](), [7];
                                            case 8:
                                                return [2]
                                        }
                                    })
                                })()
                            }
                        }, {
                            key: dI,
                            value: function() {
                                var e = this;
                                return (0, T._)(function() {
                                    return (0, z.YH)(this, function(t) {
                                        switch (t.label) {
                                            case 0:
                                                if (e.loaded) return [3, 2];
                                                return e[dk] = !0, e[c6](), [4, function(e, t) {
                                                    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                                                    return new Promise(function(r) {
                                                        e.addEventListener(t, function i(a) {
                                                            n && !n(a) || (r(a), e.removeEventListener(t, i))
                                                        })
                                                    })
                                                }(e, "load")];
                                            case 1:
                                                t.sent(), e[dk] = !1, t.label = 2;
                                            case 2:
                                                return [2]
                                        }
                                    })
                                })()
                            }
                        }, {
                            key: hc,
                            value: function() {
                                return L((0, C._)(h.prototype), hc, this).call(this) || this[dk]
                            }
                        }, {
                            key: db,
                            value: function() {
                                var e = this,
                                    t = self.location.toString(),
                                    n = new URL(t),
                                    r = new URL(this.src, t),
                                    i = new URLSearchParams(r.search);
                                if (n.hash = "#model-viewer-no-ar-fallback", i.set("mode", "ar_preferred"), i.has("disable_occlusion") || i.set("disable_occlusion", "true"), "fixed" === this.arScale && i.set("resizable", "false"), "wall" === this.arPlacement && i.set("enable_vertical_placement", "true"), i.has("sound")) {
                                    var a = new URL(i.get("sound"), t);
                                    i.set("sound", a.toString())
                                }
                                if (i.has("link")) {
                                    var o = new URL(i.get("link"), t);
                                    i.set("link", o.toString())
                                }
                                var s = "intent://arvr.google.com/scene-viewer/1.0?".concat(i.toString() + "&file=" + encodeURIComponent(r.toString()), "#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=").concat(encodeURIComponent(n.toString()), ";end;");
                                self.addEventListener("hashchange", function() {
                                    "#model-viewer-no-ar-fallback" === self.location.hash && (df = !0, self.history.back(), console.warn("Error while trying to present in AR with Scene Viewer"), console.warn("Falling back to next ar-mode"), e[dP]())
                                }, {
                                    once: !0
                                }), this[dE].setAttribute("href", s), console.log("Attempting to present in AR with Scene Viewer..."), this[dE].click()
                            }
                        }, {
                            key: dw,
                            value: function() {
                                var e = this;
                                return (0, T._)(function() {
                                    var t, n, r, i, a, o;
                                    return (0, z.YH)(this, function(s) {
                                        switch (s.label) {
                                            case 0:
                                                if (t = !e.iosSrc, e[d_].classList.remove("enabled"), !t) return [3, 2];
                                                return [4, e.prepareUSDZ()];
                                            case 1:
                                                return i = s.sent(), [3, 3];
                                            case 2:
                                                i = e.iosSrc, s.label = 3;
                                            case 3:
                                                return r = new URL(n = i, self.location.toString()), "fixed" === e.arScale && (r.hash && (r.hash += "&"), r.hash += "allowsContentScaling=0"), (a = e[dE]).setAttribute("rel", "ar"), o = document.createElement("img"), a.appendChild(o), a.setAttribute("href", r.toString()), t && a.setAttribute("download", "model.usdz"), console.log("Attempting to present in AR with Quick Look..."), a.click(), a.removeChild(o), t && URL.revokeObjectURL(n), e[d_].classList.add("enabled"), [2]
                                        }
                                    })
                                })()
                            }
                        }, {
                            key: "prepareUSDZ",
                            value: function() {
                                var e = this;
                                return (0, T._)(function() {
                                    var t, n, r, i, a, o;
                                    return (0, z.YH)(this, function(s) {
                                        switch (s.label) {
                                            case 0:
                                                return t = e[hs].beginActivity(), [4, e[dI]()];
                                            case 1:
                                                return s.sent(), r = (n = e[ht]).shadow, i = !1, null != r && (i = r.visible, r.visible = !1), t(.2), [4, (new di).parse(n.modelContainer)];
                                            case 2:
                                                return a = new Blob([s.sent()], {
                                                    type: "model/vnd.usdz+zip"
                                                }), o = URL.createObjectURL(a), [2, (t(1), null != r && (r.visible = i), o)]
                                        }
                                    })
                                })()
                            }
                        }]), h
                    }(e);
                    return dh([eU({
                        type: Boolean,
                        attribute: "ar"
                    })], h.prototype, "ar", void 0), dh([eU({
                        type: String,
                        attribute: "ar-scale"
                    })], h.prototype, "arScale", void 0), dh([eU({
                        type: String,
                        attribute: "ar-placement"
                    })], h.prototype, "arPlacement", void 0), dh([eU({
                        type: String,
                        attribute: "ar-modes"
                    })], h.prototype, "arModes", void 0), dh([eU({
                        type: String,
                        attribute: "ios-src"
                    })], h.prototype, "iosSrc", void 0), dh([eU({
                        type: Boolean,
                        attribute: "xr-environment"
                    })], h.prototype, "xrEnvironment", void 0), h
                }(function(e) {
                    var t, n, r, i, a, o, s, l, u, c, h, d, f, p, m = function(e) {
                        function m() {
                            for (var e, v, g, y, _ = arguments.length, x = Array(_), b = 0; b < _; b++) x[b] = arguments[b];
                            (0, k._)(this, m), (y = (0, E._)(this, m, (0, F._)(x))).poster = null, y.reveal = f2, y.loading = "auto", y.generateSchema = !1, y.seamlessPoster = !1, y[t] = !1, y[n] = !1, y[r] = 0, y[i] = null, y[a] = y.shadowRoot.querySelector(".slot.poster"), y[o] = y.shadowRoot.querySelector("#default-poster"), y[s] = y.shadowRoot.querySelector("#default-progress-bar > .bar"), y[l] = y.shadowRoot.querySelector("#default-progress-bar > .mask"), y[u] = y[f7].getAttribute("aria-label"), y[c] = (e = function(e) {
                                var t = y[f5].parentNode;
                                requestAnimationFrame(function() {
                                    y[f6].style.opacity = "" + .2 * (1 - e), y[f5].style.transform = "scaleX(".concat(e, ")"), 0 === e && (t.removeChild(y[f5]), t.appendChild(y[f5])), 1 === e ? y[f5].classList.add("hide") : y[f5].classList.remove("hide")
                                })
                            }, v = null, (g = function() {
                                for (var t = arguments.length, n = Array(t), r = 0; r < t; r++) n[r] = arguments[r];
                                null == v && (e.apply(void 0, (0, F._)(n)), v = self.setTimeout(function() {
                                    return v = null
                                }, 100))
                            }).flush = function() {
                                null != v && (self.clearTimeout(v), v = null)
                            }, g), y[h] = function() {
                                y.reveal !== f3 && y.reveal !== f2 && y.dismissPoster()
                            }, y[d] = function(e) {
                                if (y.reveal !== f3) switch (e.keyCode) {
                                    case 32:
                                    case 13:
                                        y.dismissPoster()
                                }
                            }, y[f] = function(e) {
                                var t = e.detail.totalProgress;
                                y[pr] = Math.max(t, y[pr]), 1 !== t || (y[pn].flush(), y[hh]() && (null != y[f9] || y.reveal === f2) && y[pe]()), y[pn](t), y.dispatchEvent(new CustomEvent("progress", {
                                    detail: {
                                        totalProgress: t
                                    }
                                }))
                            }, y[p] = function() {
                                y[pi] = !0;
                                var e = y.getRootNode();
                                e && e.activeElement === y && y[c9].focus();
                                var t = y[f7];
                                t.setAttribute("aria-hidden", "true"), t.tabIndex = -1, y.dispatchEvent(new CustomEvent("poster-dismissed"))
                            };
                            var w = self.ModelViewerElement || {},
                                M = w.dracoDecoderLocation || "https://www.gstatic.com/draco/versioned/decoders/1.4.1/";
                            un.setDRACODecoderLocation(M);
                            var S = w.ktx2TranscoderLocation || "https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/";
                            return un.setKTX2TranscoderLocation(S), w.meshoptDecoderLocation && un.setMeshoptDecoderLocation(w.meshoptDecoderLocation), y
                        }
                        return (0, P._)(m, e), (0, A._)(m, [{
                            key: "dismissPoster",
                            value: function() {
                                this[hh]() ? this[pe]() : (this[f9] = "interaction", this[c6]())
                            }
                        }, {
                            key: "showPoster",
                            value: function() {
                                var e = this[f8],
                                    t = this[f7];
                                t.removeAttribute("tabindex"), t.removeAttribute("aria-hidden"), e.classList.add("show");
                                var n = this.modelIsVisible;
                                this[pt] = !1, this[c3](n), this[pi] = !1
                            }
                        }, {
                            key: "getDimensions",
                            value: function() {
                                return hf(this[ht].size)
                            }
                        }, {
                            key: "connectedCallback",
                            value: function() {
                                L((0, C._)(m.prototype), "connectedCallback", this).call(this), this[f8].addEventListener("click", this[ps]), this[f8].addEventListener("keydown", this[pl]), this[hs].addEventListener("progress", this[pu]), f4.registerInstance(this)
                            }
                        }, {
                            key: "disconnectedCallback",
                            value: function() {
                                L((0, C._)(m.prototype), "disconnectedCallback", this).call(this), this[f8].removeEventListener("click", this[ps]), this[f8].removeEventListener("keydown", this[pl]), this[hs].removeEventListener("progress", this[pu]), f4.unregisterInstance(this)
                            }
                        }, {
                            key: "updated",
                            value: function(e) {
                                var t = this,
                                    n = this;
                                return (0, T._)(function() {
                                    return (0, z.YH)(this, function(r) {
                                        return L((0, C._)(m.prototype), "updated", t).call(n, e), e.has("poster") && null != n.poster && (n[f7].style.backgroundImage = "url(".concat(n.poster, ")")), e.has("alt") && n[f7].setAttribute("aria-label", "".concat(n[c4], ". ").concat(n[po])), (e.has("reveal") || e.has("loading")) && n[c6](), e.has("generateSchema") && (!0 === n.generateSchema ? n[ht].updateSchema(n.src) : n[ht].updateSchema(null)), e.has("seamlessPoster") && (!0 === n.seamlessPoster ? n[f8].classList.add("quick") : n[f8].classList.remove("quick")), [2]
                                    })
                                })()
                            }
                        }, {
                            key: (t = pt, n = pi, r = pr, i = f9, a = f8, o = f7, s = f5, l = f6, u = po, c = pn, h = ps, d = pl, f = pu, hc),
                            value: function() {
                                return !!this.src && (null != this[f9] || "eager" === this.loading || this.reveal === f2 && this[c2])
                            }
                        }, {
                            key: hh,
                            value: function() {
                                return !!this.src && L((0, C._)(m.prototype), hh, this).call(this) && 1 === this[pr]
                            }
                        }, {
                            key: (p = pa, pe),
                            value: function() {
                                var e = this;
                                this[f9] = null;
                                var t = this[f8];
                                if (t.classList.contains("show")) {
                                    var n = this.modelIsVisible;
                                    this[pt] = !0, this[c3](n), requestAnimationFrame(function() {
                                        t.classList.remove("show"), !0 === e.seamlessPoster ? e[pa]() : t.addEventListener("transitionend", e[pa], {
                                            once: !0
                                        })
                                    })
                                } else this[pi] = !0
                            }
                        }, {
                            key: hu,
                            value: function() {
                                return L((0, C._)(m.prototype), hu, this).call(this) && this[pt]
                            }
                        }, {
                            key: hd,
                            value: function() {
                                return L((0, C._)(m.prototype), hd, this).call(this) && this[pi]
                            }
                        }, {
                            key: c6,
                            value: function() {
                                var e = this,
                                    t = this;
                                return (0, T._)(function() {
                                    return (0, z.YH)(this, function(n) {
                                        switch (n.label) {
                                            case 0:
                                                return t[pr] = 0, !0 === t.generateSchema && t[ht].updateSchema(t.src), null != t[ht].currentGLTF && null != t.src && t[hc]() || t.showPoster(), [4, L((0, C._)(m.prototype), c6, e).call(t)];
                                            case 1:
                                                return n.sent(), [2]
                                        }
                                    })
                                })()
                            }
                        }], [{
                            key: "dracoDecoderLocation",
                            get: function() {
                                return un.getDRACODecoderLocation()
                            },
                            set: function(e) {
                                un.setDRACODecoderLocation(e)
                            }
                        }, {
                            key: "ktx2TranscoderLocation",
                            get: function() {
                                return un.getKTX2TranscoderLocation()
                            },
                            set: function(e) {
                                un.setKTX2TranscoderLocation(e)
                            }
                        }, {
                            key: "meshoptDecoderLocation",
                            get: function() {
                                return un.getMeshoptDecoderLocation()
                            },
                            set: function(e) {
                                un.setMeshoptDecoderLocation(e)
                            }
                        }, {
                            key: "mapURLs",
                            value: function(e) {
                                cM.singleton.loader[l9].manager.setURLModifier(e)
                            }
                        }]), m
                    }(e);
                    return f1([eU({
                        type: String
                    })], m.prototype, "poster", void 0), f1([eU({
                        type: String
                    })], m.prototype, "reveal", void 0), f1([eU({
                        type: String
                    })], m.prototype, "loading", void 0), f1([eU({
                        type: Boolean,
                        attribute: "generate-schema"
                    })], m.prototype, "generateSchema", void 0), f1([eU({
                        type: Boolean,
                        attribute: "seamless-poster"
                    })], m.prototype, "seamlessPoster", void 0), m
                }(function(e) {
                    var t, n = function(e) {
                        function n() {
                            for (var e, r = arguments.length, i = Array(r), a = 0; a < r; a++) i[a] = arguments[a];
                            return (0, k._)(this, n), (e = (0, E._)(this, n, [i])).autoplay = !1, e.animationName = void 0, e.animationCrossfadeDuration = 300, e[t] = !0, e[ht].subscribeMixerEvent("loop", function(t) {
                                var n = t.action._loopCount;
                                e.dispatchEvent(new CustomEvent("loop", {
                                    detail: {
                                        count: n
                                    }
                                }))
                            }), e[ht].subscribeMixerEvent("finished", function() {
                                e.currentTime = 0, e[hg] = !0, e[ho].threeRenderer.shadowMap.autoUpdate = !1, e[hv]({
                                    repetitions: 1 / 0,
                                    pingpong: !1
                                }), e.dispatchEvent(new CustomEvent("finished"))
                            }), e
                        }
                        return (0, P._)(n, e), (0, A._)(n, [{
                            key: "availableAnimations",
                            get: function() {
                                return this.loaded ? this[ht].animationNames : []
                            }
                        }, {
                            key: "duration",
                            get: function() {
                                return this[ht].duration
                            }
                        }, {
                            key: "paused",
                            get: function() {
                                return this[hg]
                            }
                        }, {
                            key: "currentTime",
                            get: function() {
                                return this[ht].animationTime
                            },
                            set: function(e) {
                                this[ht].animationTime = e, this[ho].threeRenderer.shadowMap.needsUpdate = !0, this[hn]()
                            }
                        }, {
                            key: "pause",
                            value: function() {
                                this[hg] || (this[hg] = !0, this[ho].threeRenderer.shadowMap.autoUpdate = !1, this.dispatchEvent(new CustomEvent("pause")))
                            }
                        }, {
                            key: "play",
                            value: function() {
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hy;
                                this.availableAnimations.length > 0 && (this[hg] = !1, this[ho].threeRenderer.shadowMap.autoUpdate = !0, this[hv](e), this.dispatchEvent(new CustomEvent("play")))
                            }
                        }, {
                            key: (t = hg, hi),
                            value: function() {
                                L((0, C._)(n.prototype), hi, this).call(this), this[hg] = !0, this.autoplay && (this[hv]({
                                    repetitions: 1 / 0,
                                    pingpong: !1
                                }), this.play())
                            }
                        }, {
                            key: hr,
                            value: function(e, t) {
                                L((0, C._)(n.prototype), hr, this).call(this, e, t), !this[hg] && (this[hd]() || this[ho].isPresenting) && (this[ht].updateAnimation(t / 1e3), this[hn]())
                            }
                        }, {
                            key: "updated",
                            value: function(e) {
                                L((0, C._)(n.prototype), "updated", this).call(this, e), e.has("autoplay") && this.autoplay && this.play(), e.has("animationName") && this[hv]({
                                    repetitions: 1 / 0,
                                    pingpong: !1
                                })
                            }
                        }, {
                            key: c6,
                            value: function() {
                                var e = this,
                                    t = this;
                                return (0, T._)(function() {
                                    return (0, z.YH)(this, function(r) {
                                        return [2, (t[ht].stopAnimation(), L((0, C._)(n.prototype), c6, e).call(t))]
                                    })
                                })()
                            }
                        }, {
                            key: hv,
                            value: function(e) {
                                var t, n = null !== (t = e.repetitions) && void 0 !== t ? t : 1 / 0,
                                    r = e.pingpong ? 2202 : 1 === n ? 2200 : 2201;
                                this[ht].playAnimation(this.animationName, this.animationCrossfadeDuration / 1e3, r, n), this[hg] && (this[ht].updateAnimation(0), this[hn]())
                            }
                        }]), n
                    }(e);
                    return hm([eU({
                        type: Boolean
                    })], n.prototype, "autoplay", void 0), hm([eU({
                        type: String,
                        attribute: "animation-name"
                    })], n.prototype, "animationName", void 0), hm([eU({
                        type: Number,
                        attribute: "animation-crossfade-duration"
                    })], n.prototype, "animationCrossfadeDuration", void 0), n
                }(function(e) {
                    var t = Symbol("endPolyfillCoordination");
                    return function(e) {
                        function n() {
                            var e;
                            return (0, k._)(this, n), e = (0, E._)(this, n, arguments), e[t] = null, e
                        }
                        return (0, P._)(n, e), (0, A._)(n, [{
                            key: "connectedCallback",
                            value: function() {
                                L((0, C._)(n.prototype), "connectedCallback", this) && L((0, C._)(n.prototype), "connectedCallback", this).call(this), null == this[t] && (this[t] = function(e) {
                                    if (null == e.shadowRoot || e.hasAttribute("data-js-focus-visible")) return function() {};
                                    if (!self.applyFocusVisiblePolyfill) {
                                        var t = function() {
                                            self.applyFocusVisiblePolyfill(e.shadowRoot)
                                        };
                                        return self.addEventListener("focus-visible-polyfill-ready", t, {
                                                once: !0
                                            }),
                                            function() {
                                                self.removeEventListener("focus-visible-polyfill-ready", t)
                                            }
                                    }
                                    return self.applyFocusVisiblePolyfill(e.shadowRoot),
                                        function() {}
                                }(this))
                            }
                        }, {
                            key: "disconnectedCallback",
                            value: function() {
                                L((0, C._)(n.prototype), "disconnectedCallback", this) && L((0, C._)(n.prototype), "disconnectedCallback", this).call(this), null != this[t] && (this[t](), this[t] = null)
                            }
                        }]), n
                    }(e)
                }(hp)))))))));
            customElements.define("model-viewer", mj)
        },
        17790: (e, t, n) => {
            var r = n(19852);

            function i(e) {
                this.mode = r.MODE_8BIT_BYTE, this.data = e
            }
            i.prototype = {
                getLength: function(e) {
                    return this.data.length
                },
                write: function(e) {
                    for (var t = 0; t < this.data.length; t++) e.put(this.data.charCodeAt(t), 8)
                }
            }, e.exports = i
        },
        10046: e => {
            function t() {
                this.buffer = [], this.length = 0
            }
            t.prototype = {
                get: function(e) {
                    var t = Math.floor(e / 8);
                    return (this.buffer[t] >>> 7 - e % 8 & 1) == 1
                },
                put: function(e, t) {
                    for (var n = 0; n < t; n++) this.putBit((e >>> t - n - 1 & 1) == 1)
                },
                getLengthInBits: function() {
                    return this.length
                },
                putBit: function(e) {
                    var t = Math.floor(this.length / 8);
                    this.buffer.length <= t && this.buffer.push(0), e && (this.buffer[t] |= 128 >>> this.length % 8), this.length++
                }
            }, e.exports = t
        },
        41537: e => {
            e.exports = {
                L: 1,
                M: 0,
                Q: 3,
                H: 2
            }
        },
        30501: (e, t, n) => {
            var r = n(39341);

            function i(e, t) {
                if (void 0 == e.length) throw Error(e.length + "/" + t);
                for (var n = 0; n < e.length && 0 == e[n];) n++;
                this.num = Array(e.length - n + t);
                for (var r = 0; r < e.length - n; r++) this.num[r] = e[r + n]
            }
            i.prototype = {
                get: function(e) {
                    return this.num[e]
                },
                getLength: function() {
                    return this.num.length
                },
                multiply: function(e) {
                    for (var t = Array(this.getLength() + e.getLength() - 1), n = 0; n < this.getLength(); n++)
                        for (var a = 0; a < e.getLength(); a++) t[n + a] ^= r.gexp(r.glog(this.get(n)) + r.glog(e.get(a)));
                    return new i(t, 0)
                },
                mod: function(e) {
                    if (this.getLength() - e.getLength() < 0) return this;
                    for (var t = r.glog(this.get(0)) - r.glog(e.get(0)), n = Array(this.getLength()), a = 0; a < this.getLength(); a++) n[a] = this.get(a);
                    for (var a = 0; a < e.getLength(); a++) n[a] ^= r.gexp(r.glog(e.get(a)) + t);
                    return new i(n, 0).mod(e)
                }
            }, e.exports = i
        },
        46641: (e, t, n) => {
            var r = n(17790),
                i = n(12835),
                a = n(10046),
                o = n(38759),
                s = n(30501);

            function l(e, t) {
                this.typeNumber = e, this.errorCorrectLevel = t, this.modules = null, this.moduleCount = 0, this.dataCache = null, this.dataList = []
            }
            var u = l.prototype;
            u.addData = function(e) {
                var t = new r(e);
                this.dataList.push(t), this.dataCache = null
            }, u.isDark = function(e, t) {
                if (e < 0 || this.moduleCount <= e || t < 0 || this.moduleCount <= t) throw Error(e + "," + t);
                return this.modules[e][t]
            }, u.getModuleCount = function() {
                return this.moduleCount
            }, u.make = function() {
                if (this.typeNumber < 1) {
                    var e = 1;
                    for (e = 1; e < 40; e++) {
                        for (var t = i.getRSBlocks(e, this.errorCorrectLevel), n = new a, r = 0, s = 0; s < t.length; s++) r += t[s].dataCount;
                        for (var s = 0; s < this.dataList.length; s++) {
                            var l = this.dataList[s];
                            n.put(l.mode, 4), n.put(l.getLength(), o.getLengthInBits(l.mode, e)), l.write(n)
                        }
                        if (n.getLengthInBits() <= 8 * r) break
                    }
                    this.typeNumber = e
                }
                this.makeImpl(!1, this.getBestMaskPattern())
            }, u.makeImpl = function(e, t) {
                this.moduleCount = 4 * this.typeNumber + 17, this.modules = Array(this.moduleCount);
                for (var n = 0; n < this.moduleCount; n++) {
                    this.modules[n] = Array(this.moduleCount);
                    for (var r = 0; r < this.moduleCount; r++) this.modules[n][r] = null
                }
                this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), this.setupTimingPattern(), this.setupTypeInfo(e, t), this.typeNumber >= 7 && this.setupTypeNumber(e), null == this.dataCache && (this.dataCache = l.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), this.mapData(this.dataCache, t)
            }, u.setupPositionProbePattern = function(e, t) {
                for (var n = -1; n <= 7; n++)
                    if (!(e + n <= -1) && !(this.moduleCount <= e + n))
                        for (var r = -1; r <= 7; r++) t + r <= -1 || this.moduleCount <= t + r || (0 <= n && n <= 6 && (0 == r || 6 == r) || 0 <= r && r <= 6 && (0 == n || 6 == n) || 2 <= n && n <= 4 && 2 <= r && r <= 4 ? this.modules[e + n][t + r] = !0 : this.modules[e + n][t + r] = !1)
            }, u.getBestMaskPattern = function() {
                for (var e = 0, t = 0, n = 0; n < 8; n++) {
                    this.makeImpl(!0, n);
                    var r = o.getLostPoint(this);
                    (0 == n || e > r) && (e = r, t = n)
                }
                return t
            }, u.createMovieClip = function(e, t, n) {
                var r = e.createEmptyMovieClip(t, n);
                this.make();
                for (var i = 0; i < this.modules.length; i++)
                    for (var a = 1 * i, o = 0; o < this.modules[i].length; o++) {
                        var s = 1 * o;
                        this.modules[i][o] && (r.beginFill(0, 100), r.moveTo(s, a), r.lineTo(s + 1, a), r.lineTo(s + 1, a + 1), r.lineTo(s, a + 1), r.endFill())
                    }
                return r
            }, u.setupTimingPattern = function() {
                for (var e = 8; e < this.moduleCount - 8; e++) null == this.modules[e][6] && (this.modules[e][6] = e % 2 == 0);
                for (var t = 8; t < this.moduleCount - 8; t++) null == this.modules[6][t] && (this.modules[6][t] = t % 2 == 0)
            }, u.setupPositionAdjustPattern = function() {
                for (var e = o.getPatternPosition(this.typeNumber), t = 0; t < e.length; t++)
                    for (var n = 0; n < e.length; n++) {
                        var r = e[t],
                            i = e[n];
                        if (null == this.modules[r][i])
                            for (var a = -2; a <= 2; a++)
                                for (var s = -2; s <= 2; s++) - 2 == a || 2 == a || -2 == s || 2 == s || 0 == a && 0 == s ? this.modules[r + a][i + s] = !0 : this.modules[r + a][i + s] = !1
                    }
            }, u.setupTypeNumber = function(e) {
                for (var t = o.getBCHTypeNumber(this.typeNumber), n = 0; n < 18; n++) {
                    var r = !e && (t >> n & 1) == 1;
                    this.modules[Math.floor(n / 3)][n % 3 + this.moduleCount - 8 - 3] = r
                }
                for (var n = 0; n < 18; n++) {
                    var r = !e && (t >> n & 1) == 1;
                    this.modules[n % 3 + this.moduleCount - 8 - 3][Math.floor(n / 3)] = r
                }
            }, u.setupTypeInfo = function(e, t) {
                for (var n = this.errorCorrectLevel << 3 | t, r = o.getBCHTypeInfo(n), i = 0; i < 15; i++) {
                    var a = !e && (r >> i & 1) == 1;
                    i < 6 ? this.modules[i][8] = a : i < 8 ? this.modules[i + 1][8] = a : this.modules[this.moduleCount - 15 + i][8] = a
                }
                for (var i = 0; i < 15; i++) {
                    var a = !e && (r >> i & 1) == 1;
                    i < 8 ? this.modules[8][this.moduleCount - i - 1] = a : i < 9 ? this.modules[8][15 - i - 1 + 1] = a : this.modules[8][15 - i - 1] = a
                }
                this.modules[this.moduleCount - 8][8] = !e
            }, u.mapData = function(e, t) {
                for (var n = -1, r = this.moduleCount - 1, i = 7, a = 0, s = this.moduleCount - 1; s > 0; s -= 2)
                    for (6 == s && s--;;) {
                        for (var l = 0; l < 2; l++)
                            if (null == this.modules[r][s - l]) {
                                var u = !1;
                                a < e.length && (u = (e[a] >>> i & 1) == 1), o.getMask(t, r, s - l) && (u = !u), this.modules[r][s - l] = u, -1 == --i && (a++, i = 7)
                            }
                        if ((r += n) < 0 || this.moduleCount <= r) {
                            r -= n, n = -n;
                            break
                        }
                    }
            }, l.PAD0 = 236, l.PAD1 = 17, l.createData = function(e, t, n) {
                for (var r = i.getRSBlocks(e, t), s = new a, u = 0; u < n.length; u++) {
                    var c = n[u];
                    s.put(c.mode, 4), s.put(c.getLength(), o.getLengthInBits(c.mode, e)), c.write(s)
                }
                for (var h = 0, u = 0; u < r.length; u++) h += r[u].dataCount;
                if (s.getLengthInBits() > 8 * h) throw Error("code length overflow. (" + s.getLengthInBits() + ">" + 8 * h + ")");
                for (s.getLengthInBits() + 4 <= 8 * h && s.put(0, 4); s.getLengthInBits() % 8 != 0;) s.putBit(!1);
                for (; !(s.getLengthInBits() >= 8 * h) && (s.put(l.PAD0, 8), !(s.getLengthInBits() >= 8 * h));) s.put(l.PAD1, 8);
                return l.createBytes(s, r)
            }, l.createBytes = function(e, t) {
                for (var n = 0, r = 0, i = 0, a = Array(t.length), l = Array(t.length), u = 0; u < t.length; u++) {
                    var c = t[u].dataCount,
                        h = t[u].totalCount - c;
                    r = Math.max(r, c), i = Math.max(i, h), a[u] = Array(c);
                    for (var d = 0; d < a[u].length; d++) a[u][d] = 255 & e.buffer[d + n];
                    n += c;
                    var f = o.getErrorCorrectPolynomial(h),
                        p = new s(a[u], f.getLength() - 1).mod(f);
                    l[u] = Array(f.getLength() - 1);
                    for (var d = 0; d < l[u].length; d++) {
                        var m = d + p.getLength() - l[u].length;
                        l[u][d] = m >= 0 ? p.get(m) : 0
                    }
                }
                for (var v = 0, d = 0; d < t.length; d++) v += t[d].totalCount;
                for (var g = Array(v), y = 0, d = 0; d < r; d++)
                    for (var u = 0; u < t.length; u++) d < a[u].length && (g[y++] = a[u][d]);
                for (var d = 0; d < i; d++)
                    for (var u = 0; u < t.length; u++) d < l[u].length && (g[y++] = l[u][d]);
                return g
            }, e.exports = l
        },
        12835: (e, t, n) => {
            var r = n(41537);

            function i(e, t) {
                this.totalCount = e, this.dataCount = t
            }
            i.RS_BLOCK_TABLE = [
                [1, 26, 19],
                [1, 26, 16],
                [1, 26, 13],
                [1, 26, 9],
                [1, 44, 34],
                [1, 44, 28],
                [1, 44, 22],
                [1, 44, 16],
                [1, 70, 55],
                [1, 70, 44],
                [2, 35, 17],
                [2, 35, 13],
                [1, 100, 80],
                [2, 50, 32],
                [2, 50, 24],
                [4, 25, 9],
                [1, 134, 108],
                [2, 67, 43],
                [2, 33, 15, 2, 34, 16],
                [2, 33, 11, 2, 34, 12],
                [2, 86, 68],
                [4, 43, 27],
                [4, 43, 19],
                [4, 43, 15],
                [2, 98, 78],
                [4, 49, 31],
                [2, 32, 14, 4, 33, 15],
                [4, 39, 13, 1, 40, 14],
                [2, 121, 97],
                [2, 60, 38, 2, 61, 39],
                [4, 40, 18, 2, 41, 19],
                [4, 40, 14, 2, 41, 15],
                [2, 146, 116],
                [3, 58, 36, 2, 59, 37],
                [4, 36, 16, 4, 37, 17],
                [4, 36, 12, 4, 37, 13],
                [2, 86, 68, 2, 87, 69],
                [4, 69, 43, 1, 70, 44],
                [6, 43, 19, 2, 44, 20],
                [6, 43, 15, 2, 44, 16],
                [4, 101, 81],
                [1, 80, 50, 4, 81, 51],
                [4, 50, 22, 4, 51, 23],
                [3, 36, 12, 8, 37, 13],
                [2, 116, 92, 2, 117, 93],
                [6, 58, 36, 2, 59, 37],
                [4, 46, 20, 6, 47, 21],
                [7, 42, 14, 4, 43, 15],
                [4, 133, 107],
                [8, 59, 37, 1, 60, 38],
                [8, 44, 20, 4, 45, 21],
                [12, 33, 11, 4, 34, 12],
                [3, 145, 115, 1, 146, 116],
                [4, 64, 40, 5, 65, 41],
                [11, 36, 16, 5, 37, 17],
                [11, 36, 12, 5, 37, 13],
                [5, 109, 87, 1, 110, 88],
                [5, 65, 41, 5, 66, 42],
                [5, 54, 24, 7, 55, 25],
                [11, 36, 12],
                [5, 122, 98, 1, 123, 99],
                [7, 73, 45, 3, 74, 46],
                [15, 43, 19, 2, 44, 20],
                [3, 45, 15, 13, 46, 16],
                [1, 135, 107, 5, 136, 108],
                [10, 74, 46, 1, 75, 47],
                [1, 50, 22, 15, 51, 23],
                [2, 42, 14, 17, 43, 15],
                [5, 150, 120, 1, 151, 121],
                [9, 69, 43, 4, 70, 44],
                [17, 50, 22, 1, 51, 23],
                [2, 42, 14, 19, 43, 15],
                [3, 141, 113, 4, 142, 114],
                [3, 70, 44, 11, 71, 45],
                [17, 47, 21, 4, 48, 22],
                [9, 39, 13, 16, 40, 14],
                [3, 135, 107, 5, 136, 108],
                [3, 67, 41, 13, 68, 42],
                [15, 54, 24, 5, 55, 25],
                [15, 43, 15, 10, 44, 16],
                [4, 144, 116, 4, 145, 117],
                [17, 68, 42],
                [17, 50, 22, 6, 51, 23],
                [19, 46, 16, 6, 47, 17],
                [2, 139, 111, 7, 140, 112],
                [17, 74, 46],
                [7, 54, 24, 16, 55, 25],
                [34, 37, 13],
                [4, 151, 121, 5, 152, 122],
                [4, 75, 47, 14, 76, 48],
                [11, 54, 24, 14, 55, 25],
                [16, 45, 15, 14, 46, 16],
                [6, 147, 117, 4, 148, 118],
                [6, 73, 45, 14, 74, 46],
                [11, 54, 24, 16, 55, 25],
                [30, 46, 16, 2, 47, 17],
                [8, 132, 106, 4, 133, 107],
                [8, 75, 47, 13, 76, 48],
                [7, 54, 24, 22, 55, 25],
                [22, 45, 15, 13, 46, 16],
                [10, 142, 114, 2, 143, 115],
                [19, 74, 46, 4, 75, 47],
                [28, 50, 22, 6, 51, 23],
                [33, 46, 16, 4, 47, 17],
                [8, 152, 122, 4, 153, 123],
                [22, 73, 45, 3, 74, 46],
                [8, 53, 23, 26, 54, 24],
                [12, 45, 15, 28, 46, 16],
                [3, 147, 117, 10, 148, 118],
                [3, 73, 45, 23, 74, 46],
                [4, 54, 24, 31, 55, 25],
                [11, 45, 15, 31, 46, 16],
                [7, 146, 116, 7, 147, 117],
                [21, 73, 45, 7, 74, 46],
                [1, 53, 23, 37, 54, 24],
                [19, 45, 15, 26, 46, 16],
                [5, 145, 115, 10, 146, 116],
                [19, 75, 47, 10, 76, 48],
                [15, 54, 24, 25, 55, 25],
                [23, 45, 15, 25, 46, 16],
                [13, 145, 115, 3, 146, 116],
                [2, 74, 46, 29, 75, 47],
                [42, 54, 24, 1, 55, 25],
                [23, 45, 15, 28, 46, 16],
                [17, 145, 115],
                [10, 74, 46, 23, 75, 47],
                [10, 54, 24, 35, 55, 25],
                [19, 45, 15, 35, 46, 16],
                [17, 145, 115, 1, 146, 116],
                [14, 74, 46, 21, 75, 47],
                [29, 54, 24, 19, 55, 25],
                [11, 45, 15, 46, 46, 16],
                [13, 145, 115, 6, 146, 116],
                [14, 74, 46, 23, 75, 47],
                [44, 54, 24, 7, 55, 25],
                [59, 46, 16, 1, 47, 17],
                [12, 151, 121, 7, 152, 122],
                [12, 75, 47, 26, 76, 48],
                [39, 54, 24, 14, 55, 25],
                [22, 45, 15, 41, 46, 16],
                [6, 151, 121, 14, 152, 122],
                [6, 75, 47, 34, 76, 48],
                [46, 54, 24, 10, 55, 25],
                [2, 45, 15, 64, 46, 16],
                [17, 152, 122, 4, 153, 123],
                [29, 74, 46, 14, 75, 47],
                [49, 54, 24, 10, 55, 25],
                [24, 45, 15, 46, 46, 16],
                [4, 152, 122, 18, 153, 123],
                [13, 74, 46, 32, 75, 47],
                [48, 54, 24, 14, 55, 25],
                [42, 45, 15, 32, 46, 16],
                [20, 147, 117, 4, 148, 118],
                [40, 75, 47, 7, 76, 48],
                [43, 54, 24, 22, 55, 25],
                [10, 45, 15, 67, 46, 16],
                [19, 148, 118, 6, 149, 119],
                [18, 75, 47, 31, 76, 48],
                [34, 54, 24, 34, 55, 25],
                [20, 45, 15, 61, 46, 16]
            ], i.getRSBlocks = function(e, t) {
                var n = i.getRsBlockTable(e, t);
                if (void 0 == n) throw Error("bad rs block @ typeNumber:" + e + "/errorCorrectLevel:" + t);
                for (var r = n.length / 3, a = [], o = 0; o < r; o++)
                    for (var s = n[3 * o + 0], l = n[3 * o + 1], u = n[3 * o + 2], c = 0; c < s; c++) a.push(new i(l, u));
                return a
            }, i.getRsBlockTable = function(e, t) {
                switch (t) {
                    case r.L:
                        return i.RS_BLOCK_TABLE[(e - 1) * 4 + 0];
                    case r.M:
                        return i.RS_BLOCK_TABLE[(e - 1) * 4 + 1];
                    case r.Q:
                        return i.RS_BLOCK_TABLE[(e - 1) * 4 + 2];
                    case r.H:
                        return i.RS_BLOCK_TABLE[(e - 1) * 4 + 3];
                    default:
                        return
                }
            }, e.exports = i
        },
        39341: e => {
            for (var t = {
                    glog: function(e) {
                        if (e < 1) throw Error("glog(" + e + ")");
                        return t.LOG_TABLE[e]
                    },
                    gexp: function(e) {
                        for (; e < 0;) e += 255;
                        for (; e >= 256;) e -= 255;
                        return t.EXP_TABLE[e]
                    },
                    EXP_TABLE: Array(256),
                    LOG_TABLE: Array(256)
                }, n = 0; n < 8; n++) t.EXP_TABLE[n] = 1 << n;
            for (var n = 8; n < 256; n++) t.EXP_TABLE[n] = t.EXP_TABLE[n - 4] ^ t.EXP_TABLE[n - 5] ^ t.EXP_TABLE[n - 6] ^ t.EXP_TABLE[n - 8];
            for (var n = 0; n < 255; n++) t.LOG_TABLE[t.EXP_TABLE[n]] = n;
            e.exports = t
        },
        19852: e => {
            e.exports = {
                MODE_NUMBER: 1,
                MODE_ALPHA_NUM: 2,
                MODE_8BIT_BYTE: 4,
                MODE_KANJI: 8
            }
        },
        38759: (e, t, n) => {
            var r = n(19852),
                i = n(30501),
                a = n(39341),
                o = {
                    PATTERN000: 0,
                    PATTERN001: 1,
                    PATTERN010: 2,
                    PATTERN011: 3,
                    PATTERN100: 4,
                    PATTERN101: 5,
                    PATTERN110: 6,
                    PATTERN111: 7
                },
                s = {
                    PATTERN_POSITION_TABLE: [
                        [],
                        [6, 18],
                        [6, 22],
                        [6, 26],
                        [6, 30],
                        [6, 34],
                        [6, 22, 38],
                        [6, 24, 42],
                        [6, 26, 46],
                        [6, 28, 50],
                        [6, 30, 54],
                        [6, 32, 58],
                        [6, 34, 62],
                        [6, 26, 46, 66],
                        [6, 26, 48, 70],
                        [6, 26, 50, 74],
                        [6, 30, 54, 78],
                        [6, 30, 56, 82],
                        [6, 30, 58, 86],
                        [6, 34, 62, 90],
                        [6, 28, 50, 72, 94],
                        [6, 26, 50, 74, 98],
                        [6, 30, 54, 78, 102],
                        [6, 28, 54, 80, 106],
                        [6, 32, 58, 84, 110],
                        [6, 30, 58, 86, 114],
                        [6, 34, 62, 90, 118],
                        [6, 26, 50, 74, 98, 122],
                        [6, 30, 54, 78, 102, 126],
                        [6, 26, 52, 78, 104, 130],
                        [6, 30, 56, 82, 108, 134],
                        [6, 34, 60, 86, 112, 138],
                        [6, 30, 58, 86, 114, 142],
                        [6, 34, 62, 90, 118, 146],
                        [6, 30, 54, 78, 102, 126, 150],
                        [6, 24, 50, 76, 102, 128, 154],
                        [6, 28, 54, 80, 106, 132, 158],
                        [6, 32, 58, 84, 110, 136, 162],
                        [6, 26, 54, 82, 110, 138, 166],
                        [6, 30, 58, 86, 114, 142, 170]
                    ],
                    G15: 1335,
                    G18: 7973,
                    G15_MASK: 21522,
                    getBCHTypeInfo: function(e) {
                        for (var t = e << 10; s.getBCHDigit(t) - s.getBCHDigit(s.G15) >= 0;) t ^= s.G15 << s.getBCHDigit(t) - s.getBCHDigit(s.G15);
                        return (e << 10 | t) ^ s.G15_MASK
                    },
                    getBCHTypeNumber: function(e) {
                        for (var t = e << 12; s.getBCHDigit(t) - s.getBCHDigit(s.G18) >= 0;) t ^= s.G18 << s.getBCHDigit(t) - s.getBCHDigit(s.G18);
                        return e << 12 | t
                    },
                    getBCHDigit: function(e) {
                        for (var t = 0; 0 != e;) t++, e >>>= 1;
                        return t
                    },
                    getPatternPosition: function(e) {
                        return s.PATTERN_POSITION_TABLE[e - 1]
                    },
                    getMask: function(e, t, n) {
                        switch (e) {
                            case o.PATTERN000:
                                return (t + n) % 2 == 0;
                            case o.PATTERN001:
                                return t % 2 == 0;
                            case o.PATTERN010:
                                return n % 3 == 0;
                            case o.PATTERN011:
                                return (t + n) % 3 == 0;
                            case o.PATTERN100:
                                return (Math.floor(t / 2) + Math.floor(n / 3)) % 2 == 0;
                            case o.PATTERN101:
                                return t * n % 2 + t * n % 3 == 0;
                            case o.PATTERN110:
                                return (t * n % 2 + t * n % 3) % 2 == 0;
                            case o.PATTERN111:
                                return (t * n % 3 + (t + n) % 2) % 2 == 0;
                            default:
                                throw Error("bad maskPattern:" + e)
                        }
                    },
                    getErrorCorrectPolynomial: function(e) {
                        for (var t = new i([1], 0), n = 0; n < e; n++) t = t.multiply(new i([1, a.gexp(n)], 0));
                        return t
                    },
                    getLengthInBits: function(e, t) {
                        if (1 <= t && t < 10) switch (e) {
                            case r.MODE_NUMBER:
                                return 10;
                            case r.MODE_ALPHA_NUM:
                                return 9;
                            case r.MODE_8BIT_BYTE:
                            case r.MODE_KANJI:
                                return 8;
                            default:
                                throw Error("mode:" + e)
                        } else if (t < 27) switch (e) {
                            case r.MODE_NUMBER:
                                return 12;
                            case r.MODE_ALPHA_NUM:
                                return 11;
                            case r.MODE_8BIT_BYTE:
                                return 16;
                            case r.MODE_KANJI:
                                return 10;
                            default:
                                throw Error("mode:" + e)
                        } else if (t < 41) switch (e) {
                            case r.MODE_NUMBER:
                                return 14;
                            case r.MODE_ALPHA_NUM:
                                return 13;
                            case r.MODE_8BIT_BYTE:
                                return 16;
                            case r.MODE_KANJI:
                                return 12;
                            default:
                                throw Error("mode:" + e)
                        } else throw Error("type:" + t)
                    },
                    getLostPoint: function(e) {
                        for (var t = e.getModuleCount(), n = 0, r = 0; r < t; r++)
                            for (var i = 0; i < t; i++) {
                                for (var a = 0, o = e.isDark(r, i), s = -1; s <= 1; s++)
                                    if (!(r + s < 0) && !(t <= r + s))
                                        for (var l = -1; l <= 1; l++) !(i + l < 0) && !(t <= i + l) && (0 != s || 0 != l) && o == e.isDark(r + s, i + l) && a++;
                                a > 5 && (n += 3 + a - 5)
                            }
                        for (var r = 0; r < t - 1; r++)
                            for (var i = 0; i < t - 1; i++) {
                                var u = 0;
                                e.isDark(r, i) && u++, e.isDark(r + 1, i) && u++, e.isDark(r, i + 1) && u++, e.isDark(r + 1, i + 1) && u++, (0 == u || 4 == u) && (n += 3)
                            }
                        for (var r = 0; r < t; r++)
                            for (var i = 0; i < t - 6; i++) e.isDark(r, i) && !e.isDark(r, i + 1) && e.isDark(r, i + 2) && e.isDark(r, i + 3) && e.isDark(r, i + 4) && !e.isDark(r, i + 5) && e.isDark(r, i + 6) && (n += 40);
                        for (var i = 0; i < t; i++)
                            for (var r = 0; r < t - 6; r++) e.isDark(r, i) && !e.isDark(r + 1, i) && e.isDark(r + 2, i) && e.isDark(r + 3, i) && e.isDark(r + 4, i) && !e.isDark(r + 5, i) && e.isDark(r + 6, i) && (n += 40);
                        for (var c = 0, i = 0; i < t; i++)
                            for (var r = 0; r < t; r++) e.isDark(r, i) && c++;
                        return n + Math.abs(100 * c / t / t - 50) / 5 * 10
                    }
                };
            e.exports = s
        },
        15286: (e, t, n) => {
            "use strict";

            function r(e) {
                return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }
            var i = ["value", "size", "level", "bgColor", "fgColor", "style", "includeMargin", "imageSettings"],
                a = ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "imageSettings"],
                o = ["renderAs"];

            function s() {
                return (s = Object.assign || function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = arguments[t];
                        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                    }
                    return e
                }).apply(this, arguments)
            }

            function l(e, t) {
                var n = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), n.push.apply(n, r)
                }
                return n
            }

            function u(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? l(Object(n), !0).forEach(function(t) {
                        _(e, t, n[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : l(Object(n)).forEach(function(t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                    })
                }
                return e
            }

            function c(e, t) {
                if (null == e) return {};
                var n, r, i = function(e, t) {
                    if (null == e) return {};
                    var n, r, i = {},
                        a = Object.keys(e);
                    for (r = 0; r < a.length; r++) n = a[r], t.indexOf(n) >= 0 || (i[n] = e[n]);
                    return i
                }(e, t);
                if (Object.getOwnPropertySymbols) {
                    var a = Object.getOwnPropertySymbols(e);
                    for (r = 0; r < a.length; r++) n = a[r], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n])
                }
                return i
            }

            function h(e, t) {
                if (!(e instanceof t)) throw TypeError("Cannot call a class as a function")
            }

            function d(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function f(e, t, n) {
                return t && d(e.prototype, t), n && d(e, n), Object.defineProperty(e, "prototype", {
                    writable: !1
                }), e
            }

            function p(e, t) {
                if ("function" != typeof t && null !== t) throw TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), Object.defineProperty(e, "prototype", {
                    writable: !1
                }), t && m(e, t)
            }

            function m(e, t) {
                return (m = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }

            function v(e) {
                var t = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
                    } catch (e) {
                        return !1
                    }
                }();
                return function() {
                    var n, i = y(e);
                    return n = t ? Reflect.construct(i, arguments, y(this).constructor) : i.apply(this, arguments),
                        function(e, t) {
                            if (t && ("object" === r(t) || "function" == typeof t)) return t;
                            if (void 0 !== t) throw TypeError("Derived constructors may only return object or undefined");
                            return g(e)
                        }(this, n)
                }
            }

            function g(e) {
                if (void 0 === e) throw ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }

            function y(e) {
                return (y = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function _(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            var x = n(96540);
            n(5556);
            var b = n(46641),
                w = n(41537);

            function M(e) {
                for (var t = "", n = 0; n < e.length; n++) {
                    var r = e.charCodeAt(n);
                    r < 128 ? t += String.fromCharCode(r) : (r < 2048 ? t += String.fromCharCode(192 | r >> 6) : (r < 55296 || r >= 57344 ? t += String.fromCharCode(224 | r >> 12) : (n++, t += String.fromCharCode(240 | (r = 65536 + ((1023 & r) << 10 | 1023 & e.charCodeAt(n))) >> 18), t += String.fromCharCode(128 | r >> 12 & 63)), t += String.fromCharCode(128 | r >> 6 & 63)), t += String.fromCharCode(128 | 63 & r))
                }
                return t
            }
            var S = {
                size: 128,
                level: "L",
                bgColor: "#FFFFFF",
                fgColor: "#000000",
                includeMargin: !1
            };

            function T(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = [];
                return e.forEach(function(e, r) {
                    var i = null;
                    e.forEach(function(a, o) {
                        if (!a && null !== i) {
                            n.push("M".concat(i + t, " ").concat(r + t, "h").concat(o - i, "v1H").concat(i + t, "z")), i = null;
                            return
                        }
                        if (o === e.length - 1) {
                            if (!a) return;
                            null === i ? n.push("M".concat(o + t, ",").concat(r + t, " h1v1H").concat(o + t, "z")) : n.push("M".concat(i + t, ",").concat(r + t, " h").concat(o + 1 - i, "v1H").concat(i + t, "z"));
                            return
                        }
                        a && null === i && (i = o)
                    })
                }), n.join("")
            }

            function E(e, t) {
                return e.slice().map(function(e, n) {
                    return n < t.y || n >= t.y + t.h ? e : e.map(function(e, n) {
                        return (n < t.x || n >= t.x + t.w) && e
                    })
                })
            }

            function k(e, t) {
                var n = e.imageSettings,
                    r = e.size,
                    i = e.includeMargin;
                if (null == n) return null;
                var a = t.length + 2 * (i ? 4 : 0),
                    o = Math.floor(.1 * r),
                    s = a / r,
                    l = (n.width || o) * s,
                    u = (n.height || o) * s,
                    c = null == n.x ? t.length / 2 - l / 2 : n.x * s,
                    h = null == n.y ? t.length / 2 - u / 2 : n.y * s,
                    d = null;
                if (n.excavate) {
                    var f = Math.floor(c),
                        p = Math.floor(h),
                        m = Math.ceil(l + c - f),
                        v = Math.ceil(u + h - p);
                    d = {
                        x: f,
                        y: p,
                        w: m,
                        h: v
                    }
                }
                return {
                    x: c,
                    y: h,
                    h: u,
                    w: l,
                    excavation: d
                }
            }
            var A = function() {
                    try {
                        new Path2D().addPath(new Path2D)
                    } catch (e) {
                        return !1
                    }
                    return !0
                }(),
                R = function(e) {
                    p(n, e);
                    var t = v(n);

                    function n() {
                        var e;
                        h(this, n);
                        for (var r = arguments.length, i = Array(r), a = 0; a < r; a++) i[a] = arguments[a];
                        return _(g(e = t.call.apply(t, [this].concat(i))), "_canvas", void 0), _(g(e), "_image", void 0), _(g(e), "state", {
                            imgLoaded: !1
                        }), _(g(e), "handleImageLoad", function() {
                            e.setState({
                                imgLoaded: !0
                            })
                        }), e
                    }
                    return f(n, [{
                        key: "componentDidMount",
                        value: function() {
                            this._image && this._image.complete && this.handleImageLoad(), this.update()
                        }
                    }, {
                        key: "UNSAFE_componentWillReceiveProps",
                        value: function(e) {
                            var t, n;
                            (null === (t = this.props.imageSettings) || void 0 === t ? void 0 : t.src) !== (null === (n = e.imageSettings) || void 0 === n ? void 0 : n.src) && this.setState({
                                imgLoaded: !1
                            })
                        }
                    }, {
                        key: "componentDidUpdate",
                        value: function() {
                            this.update()
                        }
                    }, {
                        key: "update",
                        value: function() {
                            var e = this.props,
                                t = e.value,
                                n = e.size,
                                r = e.level,
                                i = e.bgColor,
                                a = e.fgColor,
                                o = e.includeMargin,
                                s = e.imageSettings,
                                l = new b(-1, w[r]);
                            if (l.addData(M(t)), l.make(), null != this._canvas) {
                                var u = this._canvas,
                                    c = u.getContext("2d");
                                if (!c) return;
                                var h = l.modules;
                                if (null === h) return;
                                var d = o ? 4 : 0,
                                    f = h.length + 2 * d,
                                    p = k(this.props, h);
                                null != s && null != p && null != p.excavation && (h = E(h, p.excavation));
                                var m = window.devicePixelRatio || 1;
                                u.height = u.width = n * m;
                                var v = n / f * m;
                                c.scale(v, v), c.fillStyle = i, c.fillRect(0, 0, f, f), c.fillStyle = a, A ? c.fill(new Path2D(T(h, d))) : h.forEach(function(e, t) {
                                    e.forEach(function(e, n) {
                                        e && c.fillRect(n + d, t + d, 1, 1)
                                    })
                                }), this.state.imgLoaded && this._image && null != p && c.drawImage(this._image, p.x + d, p.y + d, p.w, p.h)
                            }
                        }
                    }, {
                        key: "render",
                        value: function() {
                            var e = this,
                                t = this.props,
                                n = (t.value, t.size),
                                r = (t.level, t.bgColor, t.fgColor, t.style),
                                a = (t.includeMargin, t.imageSettings),
                                o = c(t, i),
                                l = u({
                                    height: n,
                                    width: n
                                }, r),
                                h = null,
                                d = a && a.src;
                            return null != a && null != d && (h = x.createElement("img", {
                                src: d,
                                style: {
                                    display: "none"
                                },
                                onLoad: this.handleImageLoad,
                                ref: function(t) {
                                    return e._image = t
                                }
                            })), x.createElement(x.Fragment, null, x.createElement("canvas", s({
                                style: l,
                                height: n,
                                width: n,
                                ref: function(t) {
                                    return e._canvas = t
                                }
                            }, o)), h)
                        }
                    }]), n
                }(x.PureComponent);
            _(R, "defaultProps", S);
            var C = function(e) {
                p(n, e);
                var t = v(n);

                function n() {
                    return h(this, n), t.apply(this, arguments)
                }
                return f(n, [{
                    key: "render",
                    value: function() {
                        var e = this.props,
                            t = e.value,
                            n = e.size,
                            r = e.level,
                            i = e.bgColor,
                            o = e.fgColor,
                            l = e.includeMargin,
                            u = e.imageSettings,
                            h = c(e, a),
                            d = new b(-1, w[r]);
                        d.addData(M(t)), d.make();
                        var f = d.modules;
                        if (null === f) return null;
                        var p = l ? 4 : 0,
                            m = f.length + 2 * p,
                            v = k(this.props, f),
                            g = null;
                        null != u && null != v && (null != v.excavation && (f = E(f, v.excavation)), g = x.createElement("image", {
                            xlinkHref: u.src,
                            height: v.h,
                            width: v.w,
                            x: v.x + p,
                            y: v.y + p,
                            preserveAspectRatio: "none"
                        }));
                        var y = T(f, p);
                        return x.createElement("svg", s({
                            shapeRendering: "crispEdges",
                            height: n,
                            width: n,
                            viewBox: "0 0 ".concat(m, " ").concat(m)
                        }, h), x.createElement("path", {
                            fill: i,
                            d: "M0,0 h".concat(m, "v").concat(m, "H0z")
                        }), x.createElement("path", {
                            fill: o,
                            d: y
                        }), g)
                    }
                }]), n
            }(x.PureComponent);
            _(C, "defaultProps", S);
            var L = function(e) {
                var t = e.renderAs,
                    n = c(e, o),
                    r = "svg" === t ? C : R;
                return x.createElement(r, n)
            };
            L.defaultProps = u({
                renderAs: "canvas"
            }, S), e.exports = L
        },
        30704: e => {
            e.exports = "/nrws/homepage/4bb321a9914cdd94490c983a8dcff5baedb99ddd/_next/static/boss-assets/ar_dark-b1bbb545fae27914531f424a413675ef.gif"
        },
        30408: e => {
            e.exports = "/nrws/homepage/4bb321a9914cdd94490c983a8dcff5baedb99ddd/_next/static/boss-assets/ar_light-ee23a81bfed0c34ecd04767d6385e2a5.gif"
        }
    }
]);